{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction","text":"<p>Rice is a C++ 17 header-only library that serves dual purposes. First, it makes it much easier to create Ruby bindings for existing C++ libraries. Second, it provides an object-oriented interface to Ruby's C API that makes it easy to embed Ruby and write Ruby extensions in C++.</p> <p>Rice is similar to Boost.Python and pybind11 in that it minimizes boilerplate code needed to interface with C++. It does this by automatically determining type information allowing Ruby objects to be converted to C++ and vice versa.</p> <p>Rice provides:</p> <ul> <li>A C++ based syntax for wrapping and defining classes</li> <li>Automatic type conversions between C++ and Ruby</li> <li>Automatic exception handling between C++ and Ruby</li> <li>Smart pointers for handling garbage collection</li> <li>A C++ API to wrap Ruby's C API</li> </ul> <p>Rice is also part of a larger ecosystem of tools that together provide a complete pipeline from C++ headers to documented, type-annotated Ruby gems.</p>"},{"location":"#project-details","title":"Project Details","text":"<p>Source code is hosted on GitHub: https://github.com/ruby-rice/rice</p> <p>Bug tracking is also hosted on GitHub: https://github.com/ruby-rice/rice/issues</p> <p>API documentation: https://ruby-rice.github.io/4.x</p>"},{"location":"#example-project","title":"Example Project","text":"<p>For a complete, real-world example of a Rice extension, see BitmapPlusPlus-ruby. This gem provides Ruby bindings for a C++ image manipulation library and demonstrates many Rice features including:</p> <ul> <li>Constructor overloading</li> <li>Operator exposure</li> <li>STL integration</li> <li>Iterator support</li> <li>Exception handling</li> </ul> <p>The well-commented binding code makes it a valuable learning resource for developers building their own C++ extensions.</p>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Installation - How to install Rice</li> <li>Tutorial - Get started with Rice</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#4100-2026-02-05","title":"4.10.0 (2026-02-05)","text":"<p>Enhancements: * Add support for incomplete types (PIMPL/opaque handle patterns). Rice now uses <code>typeid(T*)</code> for forward-declared types that are never fully defined. * Add support for <code>noexcept</code> functions, static members, and static member functions * Add support for <code>Buffer&lt;void*&gt;</code> and <code>Pointer&lt;void*&gt;</code> * Add support for <code>std::function</code>. Ruby procs, lambdas, and blocks can be wrapped in <code>std::function</code> objects and passed to C++ methods. C++ functions returning <code>std::function</code> are automatically wrapped. * Add support for <code>std::ostream</code>, <code>std::ostringstream</code>, and <code>std::ofstream</code>. Ruby can write to C++ streams and pass them to C++ functions. Standard streams are exposed as <code>Std::COUT</code> and <code>Std::CERR</code>. * Add support for verifying arrays of non-fundamental types (e.g., <code>MyClass[2]</code>) * Delegate method calls for smart pointers to their wrapped objects via method_missing?</p> <p>Internal: * Refactor type handling by merging <code>TypeMapper</code> into <code>TypeDetail</code> and simplifying class hierarchy * Greatly simplify define_attr</p> <p>Incompatible Changes: * <code>Address_Registration_Guard</code> has been replaced by <code>Pin</code>. If you are using <code>Address_Registration_Guard</code>   to protect Ruby VALUEs from garbage collection, update your code to use <code>Pin</code> instead:</p> <p>Before:   <pre><code>VALUE value_;\nAddress_Registration_Guard guard_;\nMyClass() : value_(rb_str_new2(\"test\")), guard_(&amp;value_) {}\n</code></pre></p> <p>After:   <pre><code>Pin pin_;\nMyClass() : pin_(rb_str_new2(\"test\")) {}\nVALUE getValue() { return pin_.get(); }\n</code></pre></p> <p><code>Pin</code> is self-contained and provides <code>get()</code> and <code>set()</code> methods to access the pinned VALUE.</p> <ul> <li>Rice converts Ruby blocks to procs. Thus if you have a method that expects a block, you must add   a VALUE parameter and tell Rice it is a value. For example:</li> </ul> <pre><code>define_method(\"my_method\", [](VALUE self, VALUE proc)\n{\n}, Arg(\"proc\").setValue())\n</code></pre> <p>Think of this as similar to how you would capture a block in Ruby using the &amp;block syntax.</p> <ul> <li>The <code>Data_Type&lt;T&gt;::define()</code> method has been removed. See the Class Templates documentation for the recommended approach.</li> </ul>"},{"location":"changelog/#491-2026-01-04","title":"4.9.1 (2026-01-04)","text":"<p>This release focuses on improving memory management for STL containers and attribute setters.</p> <p>Enhancements: * Support <code>takeOwnership</code> and <code>keepAlive</code> when setting attributes via <code>Arg(\"value\").takeOwnership()</code> and <code>Arg(\"value\").keepAlive()</code> * Add <code>Arg</code> parameter names to all STL container methods for keyword argument support * Add <code>keepAlive</code> support for STL container operations (vector push/insert, set insert, map/multimap store) * Add <code>keepAlive</code> for map/unordered_map/multimap keys to prevent GC of pointer-type keys</p> <p>Bug Fixes: * Fix error when multiple overloaded methods take different types of vectors * Fix type unknown errors when using <code>std::shared_ptr</code> with g++ * Fix CMake <code>_Ruby_DLEXT</code> variable type (string, not path) * Fix crash caused by static variable in keepAlive implementation * Fix incorrect attribute overloading behavior</p>"},{"location":"changelog/#490-2026-01-01","title":"4.9.0 (2026-01-01)","text":"<p>This release revamps smart pointer support for <code>std::shared_ptr</code> and <code>std::unique_ptr</code>.</p> <p>Rice now always creates wrapper classes for smart pointers under the <code>Std</code> module (e.g., <code>Std::SharedPtr\u227aMyClass\u227b</code>, <code>Std::UniquePtr\u227aMyClass\u227b</code>). These wrapper classes expose methods like <code>empty?</code>, <code>get</code>, <code>swap</code>, and for shared_ptr, <code>use_count</code>. Methods defined on the managed type are automatically forwarded to the wrapper class using Ruby's <code>Forwardable</code> module.</p> <p>This change is backwards compatible for Ruby code but not C++ code. If you have implemented your own Smart Pointer wrapper then please read the Smart Pointer documentation for more information on how to update it.</p>"},{"location":"changelog/#480-2025-12-29","title":"4.8.0 (2025-12-29)","text":"<p>This release focuses on making Rice easier to use:</p> <ul> <li>Compilation times are approximately 2x faster than version 4.7</li> <li>Compiled library sizes are about 30% smaller</li> <li>Improved keyword argument support</li> <li>Improved method override support</li> <li>Improved CMake support</li> <li>Improved rbs generation support</li> <li>Improved api documentation generation support</li> <li>Expanded and improved documentation</li> <li>Enum values can now be compared against their underlying type (e.g., <code>Season::Red == 0</code>)</li> <li>STL containers now support <code>==</code> and <code>eql?</code> for equality comparison</li> <li>Automatic creation of <code>std::shared_ptr&lt;T&gt;</code> Ruby classes</li> <li>Support for C++ references in callbacks</li> <li>Array class now supports random iterators</li> <li>Fixed Ruby detection for Homebrew installations on macOS</li> <li>Added support for references to fundamental types</li> </ul> <p>However, these changes did require some breaking changes, which include:</p> <ul> <li><code>Return().isBuffer()</code> is replaced by <code>ReturnBuffer()</code></li> <li><code>Arg(\"\").isBuffer()</code> is replaced by <code>ArgBuffer(\"\")</code></li> <li><code>Function().noGVL()</code> is replaced by <code>NoGvL()</code></li> <li><code>is_convertible</code> methods must now return a <code>double</code> instead of a <code>Convertible</code> enum</li> <li>All function/method parameter default values are verified. You may see errors like \"ArgumentError: Type is not registered with Rice\" or \"Invalid AnyCast\". In either case, make sure to check that specified default values are correct.</li> </ul>"},{"location":"changelog/#471-2025-10-28","title":"4.7.1 (2025-10-28)","text":"<p>Updates: * Update overload resolution to take into account function arguments that are tagged as buffers via Arg(\"\").setBuffer(). * Make second parameter optional for Array#push and update docs * Remove ostruct runtime dependency</p>"},{"location":"changelog/#470-2025-10-22","title":"4.7.0 (2025-10-22)","text":"<p>Updates: * Refactor Native wrappers - functions, methods, attributes and procs - to enable introspection API * Introduce Pointer class to wrap pointers to fundamental types and arrays. * Add new methods Arg#setBuffer and Return#setBuffer to indicate that a C++ pointer references an array of objects versus a single object * Add a new Introspection API that exposes Rice internals to Ruby * Using the Introspection API, add support for generating RBS files for extensions. See bin/rice-rbs.rb * Using the Introspection API, add support for generating Markdown documentation for extensions. See bin/rice-doc.rb * Don't create attribute writers for const attributes * Support attribute setters for Enums * Support wrapping std::vector&gt; * Update Array#push to not always copy C++ instances. This lays the foundation for extracting references and pointers from tuples, variants and optionals. * Add very basic support for creating std::filesystem::path instances * Remove toy samples and test libraries. These will be replaced by a new gem that wraps the BitMapPlusPlus library (https://github.com/baderouaich/BitmapPlusPlus) * Add support for std::runtime_error since some libraries use that as a base exception class (thus when Rice wraps custom exceptions it also needs to wrap the base class) * Improve std::vector indexing to more closely match Ruby for negative index values * Correctly encode UTF8 Ruby class names in exception messages * Add support for disabling Ruby's global interpreter lock (GIL) when calling native functions <p>Breaking Changes: * Custom implementations of From_Ruby must include a custom constructor:     <code>explicit From_Ruby(Arg* arg)</code> * Custom implementations of To_Ruby must include a custom constructor:     <code>explicit To_Ruby(Return* returnInfo)</code> * You can no longer pass a Buffer to an API that takes a pointer. Instead use Buffer#data or Buffer::release * The Rice_Init method has been removed. * Array#push requires a second argument."},{"location":"changelog/#461-2025-06-25","title":"4.6.1 (2025-06-25)","text":"<ul> <li>Improve attribute handling. Correctly deal with non-copyable/assignable attributes and return references instead of copies of objects</li> <li>Improve Buffer implementation to deal with 4 cases:<ul> <li>array of fundamental types (int*)</li> <li>array of pointers fundamental types (char**)</li> <li>array of objects (someInstance*)</li> <li>array of pointers of objects (someInstance**)</li> </ul> </li> <li>Implement Buffer#to_s</li> <li>Fix header check on Ubuntu 22.04</li> </ul>"},{"location":"changelog/#460-2025-06-09","title":"4.6.0 (2025-06-09)","text":"<p>Rice 4.6 is a major release that adds significant new functionality based on wrapping the OpenCV library, including:</p> <ul> <li>Add a new Buffer class to provide Ruby API support for pointers sent to or returned by C++</li> <li>Support C style out parameters</li> <li>Support C style arrays</li> <li>Rewrite keyword arguments</li> <li>Rewrite default value handling allowing the removal of a lot of boilerplate</li> <li>Add support for std::multimap</li> <li>Add support for std::set</li> <li>Add support for std::tuple</li> <li>Add support for smart pointers (shared_ptr, unique_ptr) to fundamental types (void, int, etc)</li> <li>Improve std::variant support</li> <li>Update is_convertible documentation</li> <li>Fix missing version.rb file in gemspec</li> <li>Add C++ preprocessor defines for Rice version</li> <li>Include Rice::VERSION in published gem</li> <li>Moved auto-generated C++ STL classes (std::vector, std::map, etc.) from the module Rice::Std module to Std module</li> <li>Make Rice const aware to improve overload method support</li> <li>Improve error messages when Rice cannot determine what overloaded method to call</li> <li>Improve handling of unbound Data_Type instances to avoid crashes when initializing global static variables of type Data_Type <li>Make Enums more useful by adding coerce method to enable stringing together bitwise operators - for example Season::Winter | Season::Spring | Season::Summer.</li>"},{"location":"changelog/#45-2025-02-09","title":"4.5 (2025-02-09)","text":"<p>Rice 4.5 is a major release that adds significant new functionality, including:</p> <ul> <li>Support method overloading</li> <li>Support constructor overloading</li> <li>Support rvalues</li> <li>Support using keyword arguments in Ruby to call C++ methods</li> <li>Support C style callbacks, including adding a new define_callback method</li> <li>Support wrapping C/C++ functions as Ruby procs </li> <li>Support calling methods that take pointers</li> <li>Add Data_Type#define method to more easily support C++ template classes</li> <li>Adds #define_constant method</li> <li>Be more flexible on type verification by not throwing errors until all classes/methods have been defined and also allow a error message to be printed instead of thrown</li> <li>Add ability to transfer ownership of Ruby created objects to C++ (useful for sending wrapped pointers to APIs that take smart pointers)</li> <li>Add support for *char</li> <li>Add support for **char</li> <li>Improve C++ exception handling when called from Ruby</li> <li>Improve handling of Ruby exceptions</li> <li>Update std::variant to support references</li> <li>Split NativeAttribute support to NativeAttributeGet and NativeAttributeSet</li> <li>Create base class for Native classes (NativeFunction, NativeIterator, NativeAttributeGet, NativeAttributeSet - make the type registry easier to deal with (thus using type erasure like the Wrapper classes do).</li> <li>Support Ruby 3.4</li> <li>Lots of documentation additions and updates</li> <li>Updated FindRuby to support rbenv (this change is also merged upstream to CMake)</li> </ul> <p>This release also improves STL support by adding:</p> <ul> <li>std::exception</li> <li>std::exception_ptr</li> <li>std::monostage</li> <li>std::shared_ptr <li>std::type_index</li> <li>std::type_info</li> <li>std::vector <p>Please see the migration guide for updating your bindings for version 4.5</p>"},{"location":"changelog/#433-2024-10-19","title":"4.3.3 (2024-10-19)","text":"<ul> <li>Fix complication issue on Ubuntu 20.04 and GCC 9.</li> </ul>"},{"location":"changelog/#432-2024-10-18","title":"4.3.2 (2024-10-18)","text":"<ul> <li>Improve NativeRegistry to reduce possible hash collisions and weird \"bad any cast\" errors.</li> </ul>"},{"location":"changelog/#431-2024-3-16","title":"4.3.1 (2024-3-16)","text":"<ul> <li>Update links and related references to the new repo and docs location: ruby-rice.github.io.</li> </ul>"},{"location":"changelog/#43-2024-2-25","title":"4.3 (2024-2-25)","text":"<ul> <li>Add support for STL containers that contain pointers</li> <li>Add support for std::string_view</li> <li>Fix handling of std::shared_ptr that resulted in moving them instead of copying them</li> <li>Fix container iteration so elements are passed by reference and not copied</li> <li>Avoid unnecessary copies when creating Rice::Identifiers and Rice::Symbols</li> </ul>"},{"location":"changelog/#421-2024-1-20","title":"4.2.1 (2024-1-20)","text":"<ul> <li>Support systems who use <code>#include &lt;experimental/filesystem&gt;</code> over <code>#include&lt;filesystem&gt;</code>. See #197 and #201</li> </ul>"},{"location":"changelog/#42-2024-1-10","title":"4.2 (2024-1-10)","text":"<ul> <li>Support Ruby 3.3.0.</li> <li>Split Object.call to an explicit Object.call_kw for calling methods expecting keyword arguments.</li> <li>Previously, if a wrapper used <code>keepAlive</code> on an argument or return value that was itself a Rice type, calling said method would segfault. We've now added an explicit exception to be thrown in this case, prevending the segfault and providing guidance on what was wrong and how to fix it. See #193 and #194</li> <li>Fix wrapping of std::shared_ptr to properly take default arguments into account.</li> </ul>"},{"location":"changelog/#41-2023-4-21","title":"4.1 (2023-4-21)","text":"<p>Rice 4.1 builds on the 4.0 release and has a number of improvements that both polish Rice and extend its functionality. However, there are three incompatibilities to know about:</p> <ul> <li>Exception handlers are now registered globally versus per module. This requires updating code that calls Class#add_handler to use register_handler instead.</li> <li>Rename Arg#isValue to Arg#setValue and then Arg#getIsValue to Arg#isValue</li> <li>Rename Return#isValue to Return#setValue and Return#getIsValue to Return#isValue </li> </ul> <p>New or improved functionality includes:</p> <ul> <li>Add support for std::map, std::unordered_map, std::variant, std::monostate and std::reference_wrapper</li> <li>Enable calling of C++ member functions that are defined in ancestor classes</li> <li>Make it easy to wrap C++ iterators like std::vector begin and end</li> <li>Enable creating enumerators for C++ collections like std::vector and std::map</li> <li>Enable calling more Ruby API methods including those with a variable number of parameters such as rb_yield_values</li> <li>Add additional C++ to Ruby exception mappings (for example, std::system_error to SystemCallError)</li> <li>Updated documentation, including new pages for instance tracking, iterators, exceptions and newly supported STL classes</li> <li>Add support for calling Ruby methods with keywords from Rice::Object and its descendants</li> <li>Automatically translate C++ character arrays that start with colons to symbols (ie, \":mysymbol\") when sending them to Ruby</li> <li>Add a constructor for Rice::Module that takes a name, to enable code like Module(\"Kernel\")</li> <li>Fix comparison methods in Rice::Object, such as Object#is_equal, to return the correct result</li> <li>Fix various compiler warnings</li> <li>Remove deprecated APIs</li> <li>Remove support for Ruby 2.5 and 2.6 which are officially out of support</li> <li>Add support for building tests with CMake</li> <li>And lots of other fixes and code improvements</li> </ul> <p>Rice also includes experimental support for instance tracking so that Rice maps the same C++ instance to the same Ruby instance each time it is passed to Ruby. See the documentation for more information.</p>"},{"location":"changelog/#40-2021-4-8","title":"4.0 (2021-4-8)","text":"<p>Rice 4.0 is a significant change from 3.0 and has multiple backwards-incompatible changes. Rice 4.0 no longer requires pre-compilation and is now a header-only library, delivered as a combined header file.</p> <p>For migrating from 3 to 4, see the migration guide.</p> <p>There are a ton of changes, but some of the most important ones:</p> <ul> <li>Header only! <code>#include &lt;rice/rice.hpp&gt;</code></li> <li>Requires C++17 or later</li> <li>Brand new, expanded documentation</li> <li>Built-in STL support</li> <li>And so much more. See the documentation for more details.</li> </ul>"},{"location":"changelog/#30-2021-1-8","title":"3.0 (2021-1-8)","text":"<ul> <li>Now requires a compiler supporting for C++14 or later</li> <li>Drop support for Ruby 2.4. Supported versions are now 2.5 through 3.0.</li> <li>Fix build issue on macOS Big Sur</li> <li>Fix a data corruption issue with <code>Rice::Exception::what</code>.</li> <li>Move CI from Travis to GitHub Actions. Now also able to verify Windows builds!</li> </ul>"},{"location":"changelog/#220-2020-1-10","title":"2.2.0 (2020-1-10)","text":"<ul> <li>Deprecate support for Rubies older than 2.4</li> <li>Provide a few more built-in to_ruby/from_ruby conversions</li> <li>Fix compilation error when building under Ruby 2.7.0</li> </ul>"},{"location":"changelog/#213-2019-2-28","title":"2.1.3 (2019-2-28)","text":"<ul> <li>Don't lock down HAVE_CXX11 on the Rice build itself.</li> </ul>"},{"location":"changelog/#212-2017-11-20","title":"2.1.2 (2017-11-20)","text":"<ul> <li>Fix defining custom <code>begin</code> and <code>end</code> methods on an <code>Iterator</code></li> </ul>"},{"location":"changelog/#211-2020-1-10","title":"2.1.1 (2020-1-10)","text":"<ul> <li>Support Ruby 2.4</li> <li>Re-enable Rice::Enum#hash to support putting Enums in Hashes</li> </ul>"},{"location":"changelog/#210-2016-1-1","title":"2.1.0 (2016-1-1)","text":"<ul> <li>Fix compliation issues related to g++ and Ruby 2.3.0   To do this, I had to remove Array::to_c_array which was exposing the internals of a     Ruby RArray type to the system. This is not something that we should support going forward     as these internals are going to change.</li> </ul>"},{"location":"changelog/#200-2015-11-27","title":"2.0.0 (2015-11-27)","text":"<ul> <li>Deprecated all versions of Ruby &lt; 2.0</li> <li>Removed Rice::VM.   Unsure if this class is even used anywhere and it felt strange to be   able to load up a Ruby interpreter inside of Ruby. If you need it, it's   two files that I can easily make available in a gist.</li> <li>Improve build process across architectures and future changes.   Included some extra warnings for XCode updates on Mac OS X.</li> <li>Confirmed that Rice definitely does not work on static Ruby builds,   but that seems to be more because newer Ruby versions don't have good static builds.   Thanks to @Kagetsuki for his help tracking down what's going on here.</li> </ul>"},{"location":"changelog/#170-2015-1-6","title":"1.7.0 (2015-1-6)","text":"<ul> <li>Ruby 2.2 support   Potential breaking changes. Ruby 2.2 removed RHash as a public accessible struct   and as such I changed all of the Builtin_Objects to work directly off of RObject   instead of the specifics (RArray, RStruct, RString, etc). If you've been using these   objects directly I recommend using either the Rice API or Ruby's CAPI instead for   future compatibility.</li> </ul>"},{"location":"changelog/#163-2014-12-18","title":"1.6.3 (2014-12-18)","text":"<ul> <li>Fix complication issue on some 64-bit *nix systems</li> </ul>"},{"location":"changelog/#162-2014-5-5","title":"1.6.2 (2014-5-5)","text":"<ul> <li>Oops! Missed new file in the gemspec</li> </ul>"},{"location":"changelog/#161-2014-5-5","title":"1.6.1 (2014-5-5)","text":"<ul> <li>Support C++x11 uniqe_ptr over auto_ptr</li> <li>Fix some warnings</li> </ul>"},{"location":"changelog/#160-2014-2-3","title":"1.6.0 (2014-2-3)","text":"<ul> <li>Ruby 2.1 support -- Thanks Chai Zhenhua</li> <li>Methods and Constructors have correct method access specifiers [#57]</li> <li>Clean up some 64-bit compiler warnings</li> </ul>"},{"location":"changelog/#153-2013-10-14","title":"1.5.3 (2013-10-14)","text":"<ul> <li>Fix signed / unsigned compiler warning with Hash#each</li> <li>Fix compilation on clang 5 (Xcode 5)</li> </ul>"},{"location":"changelog/#152-2013-10-5","title":"1.5.2 (2013-10-5)","text":"<ul> <li>Update build system to remove deprecation warnings and allow easier building</li> <li>Fix String to work as a parameter in a wrapped method (#59)</li> <li>Update documentation a bit</li> </ul>"},{"location":"changelog/#151-2013-5-2","title":"1.5.1 (2013-5-2)","text":"<ul> <li>Doc string fix</li> </ul>"},{"location":"changelog/#150-2013-5-1","title":"1.5.0 (2013-5-1)","text":"<ul> <li>Ruby 2.0 compatability</li> <li>Bug fixes</li> </ul>"},{"location":"changelog/#143-2011-10-9","title":"1.4.3 (2011-10-9)","text":"<ul> <li>Various build configuration fixes</li> </ul>"},{"location":"changelog/#140-2010-8-30","title":"1.4.0 (2010-8-30)","text":"<ul> <li>Fully compatible with Ruby 1.9.2</li> <li>Constructor supports default arguments</li> <li>Ability to define implicit casting through define_implicit_cast</li> <li>Fixed a few memory-related issues</li> </ul>"},{"location":"ecosystem/","title":"Ecosystem","text":"<p>Rice is part of a larger ecosystem of tools for wrapping C++ libraries for Ruby. Together, these tools provide a complete pipeline from C++ headers to documented, type-annotated Ruby gems.</p>"},{"location":"ecosystem/#toolchain","title":"Toolchain","text":"<pre><code>flowchart TD\n    subgraph Input\n        CPP[C++ Library&lt;br/&gt;headers + source]\n    end\n\n    subgraph Parsing\n        CLANG[Clang / ffi-clang&lt;br/&gt;parse C++ headers]\n    end\n\n    subgraph Generation\n        BINDGEN[ruby-bindgen&lt;br/&gt;generate Rice binding code]\n    end\n\n    subgraph Rice\n        WRAP[Type Conversion&lt;br/&gt;From_Ruby / To_Ruby]\n        INTROSPECT[Introspection&lt;br/&gt;Registry]\n        MEM[Memory Management&lt;br/&gt;prevent GC issues]\n        RBS[RBS Generation&lt;br/&gt;type signatures]\n        DOCS[Doc Generation&lt;br/&gt;Markdown]\n\n        INTROSPECT --&gt; RBS\n        INTROSPECT --&gt; DOCS\n    end\n\n    subgraph Build\n        CMAKE[CMake&lt;br/&gt;build extension]\n    end\n\n    subgraph Output\n        GEM[Ruby Gem&lt;br/&gt;compiled + docs + RBS types]\n    end\n\n    CPP --&gt; CLANG\n    CLANG --&gt; BINDGEN\n    BINDGEN --&gt; Rice\n    Rice --&gt; CMAKE\n    CMAKE --&gt; GEM</code></pre> <p>What once took weeks of manual work can now be done in hours.</p>"},{"location":"ecosystem/#tools","title":"Tools","text":""},{"location":"ecosystem/#clang-ffi-clang","title":"Clang / ffi-clang","text":"<p>Clang is a C/C++ compiler that provides libclang, a library for parsing C++ code. ffi-clang provides Ruby bindings to libclang, allowing Ruby code to walk the C++ AST (Abstract Syntax Tree) and extract classes, methods, constructors, enums, and other declarations.</p>"},{"location":"ecosystem/#ruby-bindgen","title":"ruby-bindgen","text":"<p>ruby-bindgen uses ffi-clang to parse C++ headers and automatically generates Rice binding code. Point it at a library's headers and it produces correct binding code.</p>"},{"location":"ecosystem/#rice","title":"Rice","text":"<p>Rice wraps C++ code and exposes it to Ruby. It also includes:</p> <ul> <li> <p>Introspection API - Rice tracks every class, method, and attribute it wraps in an internal registry. This metadata is exposed to Ruby, enabling documentation and type generation. See Registries.</p> </li> <li> <p>RBS Generation - Generate RBS type signatures for wrapped classes, giving Ruby's type checkers full visibility into your C++ bindings. See RBS.</p> </li> <li> <p>API Documentation Generation - Generate Ruby-style API documentation in Markdown format from wrapped classes. See Documentation.</p> </li> </ul>"},{"location":"ecosystem/#cmake","title":"CMake","text":"<p>CMake is the de-facto C++ build system. Rice includes an improved FindRuby.cmake module with fixes that have been upstreamed to CMake itself, making native extension builds work reliably across platforms. See CMake.</p>"},{"location":"fuzzing_plan/","title":"Rice Fuzzing Implementation Plan","text":"<p>This document outlines a plan to integrate fuzz testing into Rice using AFL++ or libFuzzer on Linux.</p>"},{"location":"fuzzing_plan/#overview","title":"Overview","text":"<p>Fuzzing Rice will help discover: - Buffer overflows in string handling - Integer overflow/underflow in numeric conversions - Memory corruption in STL container conversions - Exception handling edge cases - Null byte and binary data handling issues</p>"},{"location":"fuzzing_plan/#prerequisites","title":"Prerequisites","text":""},{"location":"fuzzing_plan/#system-requirements","title":"System Requirements","text":"<ul> <li>Linux (Ubuntu 22.04+ recommended)</li> <li>Clang 14+ with libFuzzer support</li> <li>Ruby development headers</li> <li>CMake 3.15+</li> </ul>"},{"location":"fuzzing_plan/#installation-ubuntu","title":"Installation (Ubuntu)","text":"<pre><code>sudo apt update\nsudo apt install clang llvm ruby-dev cmake build-essential\n\n# Optional: AFL++ for alternative fuzzing\nsudo apt install afl++\n</code></pre>"},{"location":"fuzzing_plan/#directory-structure","title":"Directory Structure","text":"<pre><code>rice/\n\u251c\u2500\u2500 fuzz/\n\u2502   \u251c\u2500\u2500 CMakeLists.txt          # Fuzzing build configuration\n\u2502   \u251c\u2500\u2500 harnesses/\n\u2502   \u2502   \u251c\u2500\u2500 fuzz_common.hpp     # Shared utilities (Ruby init, helpers)\n\u2502   \u2502   \u251c\u2500\u2500 fuzz_string_conversion.cpp\n\u2502   \u2502   \u251c\u2500\u2500 fuzz_numeric_conversion.cpp\n\u2502   \u2502   \u251c\u2500\u2500 fuzz_array_conversion.cpp\n\u2502   \u2502   \u251c\u2500\u2500 fuzz_hash_conversion.cpp\n\u2502   \u2502   \u251c\u2500\u2500 fuzz_exception.cpp\n\u2502   \u2502   \u2514\u2500\u2500 fuzz_identifier.cpp\n\u2502   \u2514\u2500\u2500 corpus/                  # Seed inputs\n\u2502       \u251c\u2500\u2500 string/\n\u2502       \u251c\u2500\u2500 numeric/\n\u2502       \u251c\u2500\u2500 array/\n\u2502       \u2514\u2500\u2500 hash/\n</code></pre>"},{"location":"fuzzing_plan/#fuzz-targets","title":"Fuzz Targets","text":""},{"location":"fuzzing_plan/#1-string-conversion-fuzz_string_conversioncpp","title":"1. String Conversion (<code>fuzz_string_conversion.cpp</code>)","text":"<ul> <li><code>From_Ruby&lt;std::string&gt;</code> / <code>To_Ruby&lt;std::string&gt;</code></li> <li><code>From_Ruby&lt;std::string_view&gt;</code></li> <li><code>From_Ruby&lt;const char*&gt;</code></li> <li>Tests: embedded nulls, binary data, empty strings, very long strings</li> </ul>"},{"location":"fuzzing_plan/#2-numeric-conversion-fuzz_numeric_conversioncpp","title":"2. Numeric Conversion (<code>fuzz_numeric_conversion.cpp</code>)","text":"<ul> <li>All <code>From_Ruby&lt;T&gt;</code> for: int, long, long long, unsigned variants, float, double, bool, char</li> <li>Tests: boundary values, signedness, overflow, NaN/Inf</li> </ul>"},{"location":"fuzzing_plan/#3-arrayvector-conversion-fuzz_array_conversioncpp","title":"3. Array/Vector Conversion (<code>fuzz_array_conversion.cpp</code>)","text":"<ul> <li><code>From_Ruby&lt;std::vector&lt;T&gt;&gt;</code> for various T</li> <li><code>To_Ruby&lt;std::vector&lt;T&gt;&gt;</code></li> <li>Tests: empty arrays, large arrays, mixed types, nested arrays</li> </ul>"},{"location":"fuzzing_plan/#4-hashmap-conversion-fuzz_hash_conversioncpp","title":"4. Hash/Map Conversion (<code>fuzz_hash_conversion.cpp</code>)","text":"<ul> <li><code>From_Ruby&lt;std::map&lt;K,V&gt;&gt;</code> / <code>std::unordered_map</code></li> <li>Tests: duplicate keys, empty hash, string keys with special chars</li> </ul>"},{"location":"fuzzing_plan/#5-exception-handling-fuzz_exceptioncpp","title":"5. Exception Handling (<code>fuzz_exception.cpp</code>)","text":"<ul> <li><code>Rice::Exception</code> creation</li> <li>C++ to Ruby exception translation</li> <li>Ruby to C++ exception handling</li> </ul>"},{"location":"fuzzing_plan/#6-identifiersymbol-fuzz_identifiercpp","title":"6. Identifier/Symbol (<code>fuzz_identifier.cpp</code>)","text":"<ul> <li><code>Rice::Identifier</code>, <code>Rice::Symbol</code>, <code>Rice::String</code></li> <li>Tests: special characters, empty strings, very long names</li> </ul>"},{"location":"fuzzing_plan/#cmake-configuration","title":"CMake Configuration","text":"<p>Key options: <pre><code>option(USE_LIBFUZZER \"Use libFuzzer (requires Clang)\" ON)\noption(USE_AFL \"Use AFL++ instrumentation\" OFF)\noption(ENABLE_ASAN \"Enable AddressSanitizer\" ON)\noption(ENABLE_UBSAN \"Enable UndefinedBehaviorSanitizer\" ON)\n</code></pre></p> <p>Build commands: <pre><code># libFuzzer build\nCC=clang CXX=clang++ cmake -B build-fuzz -S fuzz \\\n    -DCMAKE_BUILD_TYPE=Debug \\\n    -DUSE_LIBFUZZER=ON \\\n    -DENABLE_ASAN=ON\n\ncmake --build build-fuzz\n\n# AFL++ build\nCC=afl-clang-fast CXX=afl-clang-fast++ cmake -B build-afl -S fuzz \\\n    -DCMAKE_BUILD_TYPE=Debug \\\n    -DUSE_AFL=ON\n\ncmake --build build-afl\n</code></pre></p>"},{"location":"fuzzing_plan/#running-the-fuzzers","title":"Running the Fuzzers","text":""},{"location":"fuzzing_plan/#libfuzzer","title":"libFuzzer","text":"<pre><code># Run with corpus\n./build-fuzz/fuzz_string_conversion corpus/string/\n\n# Run with options\n./build-fuzz/fuzz_string_conversion \\\n    -max_len=4096 \\\n    -timeout=10 \\\n    -jobs=4 \\\n    corpus/string/\n</code></pre>"},{"location":"fuzzing_plan/#afl","title":"AFL++","text":"<pre><code>afl-fuzz -i corpus/string -o findings -- ./build-afl/fuzz_string_conversion\n</code></pre>"},{"location":"fuzzing_plan/#seed-corpus","title":"Seed Corpus","text":"<p>Create minimal valid inputs for each target:</p> <pre><code># String corpus\necho -n \"\" &gt; corpus/string/empty\necho -n \"hello\" &gt; corpus/string/simple\necho -n \"hello world\" &gt; corpus/string/spaces\nprintf '\\x00\\x01\\x02\\xff' &gt; corpus/string/binary\nprintf 'test\\x00null' &gt; corpus/string/embedded_null\n\n# Numeric corpus (binary representations)\nprintf '\\x00\\x00\\x00\\x00' &gt; corpus/numeric/zero\nprintf '\\xff\\xff\\xff\\x7f' &gt; corpus/numeric/max_int32\nprintf '\\x00\\x00\\x00\\x80' &gt; corpus/numeric/min_int32\n\n# Array corpus\nprintf '\\x01\\x00\\x00\\x00' &gt; corpus/array/one_element\nprintf '\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00' &gt; corpus/array/three_elements\n</code></pre>"},{"location":"fuzzing_plan/#key-implementation-details","title":"Key Implementation Details","text":""},{"location":"fuzzing_plan/#ruby-gc-considerations","title":"Ruby GC Considerations","text":"<p>This is critical for fuzzing Rice correctly.</p> <p>Ruby's GC can run at unpredictable times, which creates challenges:</p> <ol> <li>Objects may be collected mid-operation - A VALUE created at the start of a fuzz iteration might be GC'd before the test completes</li> <li>Stack scanning - Ruby's conservative GC scans the C stack, but fuzzer-generated data patterns might confuse it</li> <li>GC timing bugs - Real bugs might only manifest when GC runs at specific moments</li> </ol>"},{"location":"fuzzing_plan/#mitigation-strategies","title":"Mitigation Strategies","text":"<pre><code>// 1. Disable GC during fuzz iteration (simplest)\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {\n    rb_gc_disable();\n\n    // ... fuzzing logic ...\n\n    rb_gc_enable();\n    rb_gc_start();  // Force GC between iterations to catch dangling refs\n    return 0;\n}\n\n// 2. Pin objects to prevent collection\nVALUE rb_str = make_ruby_string(data, size);\nrb_gc_register_address(&amp;rb_str);  // Pin\n// ... use rb_str ...\nrb_gc_unregister_address(&amp;rb_str);  // Unpin\n\n// 3. Use volatile to prevent compiler from optimizing away\nvolatile VALUE rb_str = make_ruby_string(data, size);\nRB_GC_GUARD(rb_str);  // Ruby's guard macro\n</code></pre>"},{"location":"fuzzing_plan/#two-fuzzing-modes","title":"Two Fuzzing Modes","text":"<p>Consider running fuzzers in two modes:</p> <ol> <li> <p>GC Disabled Mode - Find logic bugs without GC interference    <pre><code>rb_gc_disable();\n// ... fuzz ...\nrb_gc_enable();\n</code></pre></p> </li> <li> <p>GC Stress Mode - Find GC-related bugs    <pre><code>rb_gc_stress_set(Qtrue);  // Force GC on every allocation\n// ... fuzz ...\nrb_gc_stress_set(Qfalse);\n</code></pre></p> </li> </ol>"},{"location":"fuzzing_plan/#updated-harness-template","title":"Updated Harness Template","text":"<pre><code>#include &lt;ruby.h&gt;\n\n// Options controlled by environment or compile flags\nstatic bool gc_disabled = false;\nstatic bool gc_stress = false;\n\nextern \"C\" int LLVMFuzzerInitialize(int* argc, char*** argv) {\n    ruby_init();\n    ruby_init_loadpath();\n\n    // Check environment for mode\n    if (getenv(\"FUZZ_GC_DISABLED\")) {\n        gc_disabled = true;\n    }\n    if (getenv(\"FUZZ_GC_STRESS\")) {\n        gc_stress = true;\n        rb_gc_stress_set(Qtrue);\n    }\n\n    return 0;\n}\n\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {\n    if (gc_disabled) rb_gc_disable();\n\n    int state = 0;\n    rb_protect([](VALUE arg) -&gt; VALUE {\n        // Create objects and immediately pin them\n        VALUE obj = /* ... */;\n        volatile VALUE guard = obj;\n        RB_GC_GUARD(guard);\n\n        // ... test logic ...\n\n        return Qnil;\n    }, (VALUE)data, &amp;state);\n\n    if (state) rb_set_errinfo(Qnil);\n\n    if (gc_disabled) {\n        rb_gc_enable();\n        rb_gc_start();  // Clean up between iterations\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"fuzzing_plan/#what-gc-bugs-look-like","title":"What GC Bugs Look Like","text":"<p>When fuzzing finds GC-related issues, you might see: - Use-after-free in ASan (object was collected) - Segfaults accessing VALUE that's now invalid - Corruption when GC moves objects (compacting GC in Ruby 3.x) - Memory leaks (objects never freed due to incorrect prevent_gc)</p>"},{"location":"fuzzing_plan/#testing-keepalive-specifically","title":"Testing keepAlive Specifically","text":"<p>Since Rice has <code>keepAlive()</code> for preventing GC of objects stored in containers, consider a dedicated harness:</p> <pre><code>// fuzz_keepalive.cpp - Test GC safety of container operations\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {\n    rb_gc_stress_set(Qtrue);  // Aggressive GC\n\n    // Create a vector, add Ruby objects, trigger GC, access objects\n    VALUE vec = /* create std::vector wrapper */;\n    VALUE obj = /* create object */;\n\n    // Add to vector (should keepAlive)\n    rb_funcall(vec, rb_intern(\"push\"), 1, obj);\n\n    // Force multiple GC cycles\n    for (int i = 0; i &lt; 10; i++) {\n        rb_gc_start();\n    }\n\n    // Access the object - should still be valid\n    VALUE retrieved = rb_funcall(vec, rb_intern(\"[]\"), 1, INT2NUM(0));\n    // Use retrieved...\n\n    rb_gc_stress_set(Qfalse);\n    return 0;\n}\n</code></pre>"},{"location":"fuzzing_plan/#ruby-vm-initialization","title":"Ruby VM Initialization","text":"<p>The harnesses need to initialize Ruby VM once at startup:</p> <pre><code>class RubyVM {\n    static RubyVM&amp; instance() {\n        static RubyVM vm;\n        return vm;\n    }\nprivate:\n    RubyVM() {\n        ruby_init();\n        ruby_init_loadpath();\n    }\n    ~RubyVM() { ruby_cleanup(0); }\n};\n</code></pre>"},{"location":"fuzzing_plan/#exception-safety","title":"Exception Safety","text":"<p>All fuzzer code must catch exceptions to avoid false positives:</p> <pre><code>extern \"C\" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {\n    int state = 0;\n    rb_protect([](VALUE arg) -&gt; VALUE {\n        // Fuzzing logic here\n        return Qnil;\n    }, (VALUE)data, &amp;state);\n\n    if (state) rb_set_errinfo(Qnil);  // Clear error\n    return 0;\n}\n</code></pre>"},{"location":"fuzzing_plan/#data-provider-pattern","title":"Data Provider Pattern","text":"<p>Use a helper class to consume fuzz input in a structured way:</p> <pre><code>class FuzzDataProvider {\n    const uint8_t* data_;\n    size_t size_, offset_ = 0;\npublic:\n    template&lt;typename T&gt; T consume();\n    std::string consume_string(size_t max_len);\n    bool empty() const;\n};\n</code></pre>"},{"location":"fuzzing_plan/#triage-and-analysis","title":"Triage and Analysis","text":"<p>When fuzzer finds crashes: 1. Crashes saved to <code>findings/crashes/</code> (AFL++) or current dir (libFuzzer) 2. Reproduce: <code>./fuzz_target crash_file</code> 3. Debug: <code>gdb ./fuzz_target</code> then <code>run crash_file</code> 4. Analyze with ASan output for memory issues</p>"},{"location":"fuzzing_plan/#ci-integration-future","title":"CI Integration (Future)","text":"<p>Add to GitHub Actions: <pre><code>fuzz:\n  runs-on: ubuntu-latest\n  steps:\n    - uses: actions/checkout@v4\n    - name: Build fuzzers\n      run: |\n        CC=clang CXX=clang++ cmake -B build-fuzz -S fuzz\n        cmake --build build-fuzz\n    - name: Run fuzzers (short)\n      run: |\n        ./build-fuzz/fuzz_string_conversion -max_total_time=60 corpus/string/\n</code></pre></p>"},{"location":"fuzzing_plan/#next-steps","title":"Next Steps","text":"<ol> <li>Boot to Linux</li> <li>Create the <code>fuzz/</code> directory structure</li> <li>Implement harnesses one at a time, testing each</li> <li>Build seed corpus</li> <li>Run initial fuzzing campaign</li> <li>Triage any findings</li> <li>Add CI integration</li> </ol>"},{"location":"history/","title":"History","text":"<p>Rice originated as Excruby, a project to interface with C++-based trading software at Automated Trading Desk in Mount Pleasant, South Carolina. The Ruby bindings for Swig at the time were not suitable for the needs of the project.</p> <p>Excruby started as a set of helper functions and classes for interfacing with the Ruby interpreter in an exception-safe manner. Over the course of five years, the project grew into wrappers for pieces of the Ruby API, but the original helper functions remained as part of the public interface.</p> <p>This created confusion for the users of the library, because there were multiple ways of accomplishing most tasks -- directly through the C API, through a low-level wrapper around the C API and through a high-level abstraction of the lower-level interfaces.</p> <p>Rice was born in 2008 as an attempt to clean up the interface. Since then Rice has continued to evolve. It has gone through several eras:</p> Era Versions Theme 2003-2008 Excruby Ruby API wrappers 2008-2010 1.2-1.4 Foundation, Ruby 1.9 2011-2014 1.4.3-1.6 C++11, Ruby 2.x 2015-2020 1.7-2.2 Maintenance 2021 3.0-4.0 Header-only rewrite, C++17 2022-2024 4.0.x-4.3 STL expansion 2025 4.5-4.9 OpenCV-driven evolution (buffers, pointers, overloads, etc)"},{"location":"history/#2008-2010-foundation","title":"2008-2010: Foundation","text":"<p>Rice kept the lower-level wrappers, but as an implementation detail hidden behind C++ classes that provided a higher high-level abstraction around the Ruby C API.</p> Version Date Major Features First commit Jan 2008 Rice development begins, evolved from Excruby 1.2.0 Oct 2009 First tagged release 1.4.0 Aug 2010 Ruby 1.9.2, constructor defaults, implicit casting"},{"location":"history/#2011-2014-ruby-2x-and-c11","title":"2011-2014: Ruby 2.x and C++11","text":"<p>Rice kept pace with Ruby's evolution through the 2.x series and adopted C++11 features like unique_ptr.</p> Version Date Major Features 1.5.0 May 2013 Ruby 2.0 1.6.0 Feb 2014 Ruby 2.1, C++11 unique_ptr"},{"location":"history/#2015-2020-maintenance","title":"2015-2020: Maintenance","text":"<p>A quiet period of maintenance. Rice started to show its limitations - it was difficult to use Rice to wrap C++ libraries. A major drawback was that Rice required its own compilation step to create its own library. At the time (and still today), there is not a standard way to install compiled C++ packages.</p> Version Date Major Features 1.7.0 Jan 2015 Ruby 2.2 2.0.0 Nov 2015 Deprecated Ruby &lt; 2.0 2.2.0 Jan 2020 Ruby 2.7"},{"location":"history/#2021-header-only-rewrite","title":"2021: Header-Only Rewrite","text":"<p>Version 4, released in 2021, was a major rewrite that changed Rice into a header-only library. This made it much easier to use Rice to wrap C++ libraries. In addition, version 4 took full advantage of C++ template metaprogramming functionality in C++17 and higher to make it easier to create Ruby extensions for C++ libraries.</p> Version Date Major Features 3.0 Jan 2021 C++14 minimum, GitHub Actions CI 4.0 Apr 2021 Header-only, C++17, From_Ruby/To_Ruby redesign, STL support"},{"location":"history/#2022-2024-stl-expansion","title":"2022-2024: STL Expansion","text":"<p>With the header-only foundation in place, Rice expanded its STL support to cover more container types and use cases.</p> Version Date Major Features 4.1.0 Apr 2023 std::map, std::variant, iterators, enumerators 4.2.0 Jan 2024 Ruby 3.3, Buffer class 4.3 Feb 2024 STL containers with pointers, std::string_view"},{"location":"history/#2025-opencv-driven-evolution","title":"2025: OpenCV-Driven Evolution","text":"<p>In 2025, Rice underwent rapid evolution based on learnings from wrapping the OpenCV library. OpenCV exposes a large C++ API that makes heavy use of C++ templates, overloaded methods and constructors, C style callbacks and other C++ features. To successfully wrap the library required making numerous changes to Rice.</p> Version Date Major Features 4.5.0 Feb 2025 Method/constructor overloading, keyword args, callbacks, rvalues 4.6.0 Jun 2025 Buffer rewrite, std::tuple/set/multimap, const-aware types 4.7.0 Oct 2025 Introspection API, RBS generation, API doc generation 4.8.0 Dec 2025 2x faster compilation, 30% smaller binaries 4.9.0 Dec 2025 Smart pointer redesign (Std::SharedPtr, Std::UniquePtr)"},{"location":"installation/","title":"Installation","text":"<p>Rice is a header-only library and therefore does not need to be built separately. Instead it should be <code>#include</code>d in your C++ project. Rice requires C++17 or later and is tested on Windows (MSVC, Clang and Mingw64), MacOS (Xcode/Clang) and Linux (g++, Clang).</p>"},{"location":"installation/#option-1-install-the-gem","title":"Option 1: Install the Gem","text":"<p>The easiest way to use Rice is to install it as a gem:</p> <pre><code>gem install rice\n</code></pre> <p>This installs the Rice header files and provides the <code>mkmf-rice</code> helper for building extensions with <code>extconf.rb</code>. Note this works for simple projects, but will not scale to large projects. In that case, you will want to use Cmake as described in detail in the packaging section.</p>"},{"location":"installation/#option-2-copy-header-files","title":"Option 2: Copy Header Files","text":"<p>Alternatively, you can copy the Rice header files directly into your project. This is useful if you don't want a gem dependency or need to bundle Rice with your source code.</p> <p>The header files are located in the <code>include/rice</code> folder on GitHub. Copy this folder into your project and add the include path to your build system.</p> <p>The three headers are:</p> <ul> <li><code>rice/rice.hpp</code> - Core Rice functionality</li> <li><code>rice/stl.hpp</code> - STL container support (optional)</li> <li><code>rice/api.hpp</code> - Enables automatic generation of documentation and RBS files (optional)</li> </ul> <p>When copying headers, use a specific release tag rather than the master branch to ensure stability.</p>"},{"location":"installation/#compiler-requirements","title":"Compiler Requirements","text":"<p>Rice requires a C++17 compliant compiler and RTTI to be enabled. See Compiler Settings for the specific flags needed for each compiler.</p>"},{"location":"migration/","title":"Migration","text":""},{"location":"migration/#version-46-to-47","title":"Version 4.6 to 4.7","text":"<p>Version 4.7 has a couple of breaking changes.</p> <p>The <code>Rice_Init</code> method has been removed.</p> <p><code>Buffer&lt;T&gt;</code> classes can no longer be passed to C++ apis that take references or pointers. Instead use <code>Buffer&lt;T&gt;::data</code> or <code>Buffer&lt;T&gt;::release</code>.</p>"},{"location":"migration/#version-45-to-46","title":"Version 4.5 to 4.6","text":"<p>Version 4.6 has a couple of breaking changes.</p> <p>First, all C++ STL classes are now defined in the <code>Std</code> module. Therefore the following methods were removed - <code>define_vector_under</code>, <code>define_map_under</code> and <code>define_unordered_map_under</code>.</p> <p>Second, Rice used to automatically convert Ruby Arrays of fundamental types to std::vectors (and similarly Hashes to std::map). Now you must use Buffers instead.</p>"},{"location":"migration/#version-4-to-45","title":"Version 4.* to 4.5","text":"<p>Version 4.5 is significantly more powerful that previous Rice versions. For the most part it is backwards compatible. The exception is if you defined a custom <code>From_Ruby</code> instantiation. In that case, you will need to add a <code>convertible</code> method. See the From_Ruby specialization documentation for an example.</p>"},{"location":"migration/#version-3-to-4","title":"Version 3 to 4","text":"<p>Version 3 and earlier required compiling code on <code>gem install</code>. This made it difficult to use Rice on some platforms, such as Heroku or Github Actions, where the appropriate shared libraries and/or build systems are not allowed or available.</p> <p>Rice 4 transitions to being a header only library, making it much easier for libraries using Rice to provide binary builds. However, this work was substantial and required making a few backwards-incompatible changes This page documents the major changes that any one using Rice 3 will need to apply to their libraries to work with Rice 4 or newer.</p>"},{"location":"migration/#include","title":"#include  <p>The first change is that Rice is now published as a single, combined header file, so all includes can be changed to just this one. There is one other header file that contains STL wrapper definitions, you can get that with <code>#include &lt;rice/stl.hpp&gt;</code>. For more information see the STL section.</p>","text":""},{"location":"migration/#to_ruby-from_ruby","title":"to_ruby / from_ruby <p>The most notable backwards-incompatible change is how you define Ruby &lt;=&gt; C++ type conversions.</p> <p>In Rice 3, you defined the methods <code>to_ruby</code> and <code>from_ruby</code> like this:</p> <pre><code>template&lt;&gt;\nFoo from_ruby&lt;Foo&gt;(Rice::Object x)\n{\n  // ...\n}\n\ntemplate&lt;&gt;\nRice::Object to_ruby&lt;Foo&gt;(Foo const &amp; x)\n{\n  // ...\n}\n</code></pre> <p>In Rice 4, the structure of these functions has changed significantly. You now define these methods as a <code>convert</code> function in a struct, and they need to live in the <code>Rice::detail</code> namespace:</p> <pre><code>namespace Rice::detail\n{\n  template&lt;&gt;\n  class From_Ruby&lt;Foo&gt;\n  {\n    Foo convert(VALUE x)\n    {\n      // ...\n    }\n  };\n\n  template&lt;&gt;\n  class To_Ruby&lt;Foo&gt;\n  {\n    VALUE convert(Foo const &amp; x)\n    {\n      // ...\n    }\n  };\n}\n</code></pre> <p>In addition, they work with Ruby's VALUE type as opposed to Rice's Object type. This switch was made to avoid making extra copies of objects when translating between C++ and Ruby. For more information, please refer to the type conversion section.</p>","text":""},{"location":"migration/#functions-vs-methods","title":"Functions vs Methods <p>Rice now has different <code>define_</code> methods depending on if you are defining a method on an object or a normal function. If you need <code>self</code>, use <code>define_method</code> or <code>define_singleton_method</code>. Otherwise you should use <code>define_function</code> and <code>define_singleton_function</code>. You can read more in the tutorial.</p>","text":""},{"location":"migration/#default-arguments","title":"Default Arguments <p>They way Rice defines C++ default arguments has subtly changed - this is an easy one to miss and can introduce bugs (default values will not be set correctly). Previously Rice relied on C++'s comma operator to combine arguments together:</p> <pre><code>define_method(\"hello\", &amp;Test::hello, (Arg(\"hello\"), Arg(\"second\") = \"world\"));\n</code></pre> <p>Notice that the two <code>Args</code> are surrounded by parentheses. Rice no longer support this style. Instead, just pass the <code>Args</code> in a more natural way without the parentheses:</p> <pre><code>define_method(\"hello\", &amp;Test::hello, Arg(\"hello\"), Arg(\"second\") = \"world\");\n</code></pre>","text":""},{"location":"migration/#memory-management","title":"Memory Management <p>Rice 4 also requires and provides more tools for explicitly defining which objects should and should not be managed by the Ruby garbage collector. Read more in memory management.</p>","text":""},{"location":"projects/","title":"Projects Using Rice","text":"<p>Rice is used by many Ruby gems to create high-performance bindings to C++ libraries. Below are notable projects organized by category.</p>"},{"location":"projects/#computer-vision","title":"Computer Vision","text":""},{"location":"projects/#opencv-ruby","title":"opencv-ruby","text":"<p>Ruby bindings for OpenCV4 based on its C++ API. Almost all of OpenCV's API is exposed.</p> <ul> <li>GitHub: cfis/opencv-ruby</li> </ul>"},{"location":"projects/#machine-learning","title":"Machine Learning","text":""},{"location":"projects/#torchrb","title":"torch.rb","text":"<p>Deep learning for Ruby, powered by LibTorch (PyTorch's C++ library).</p> <ul> <li>GitHub: ankane/torch.rb</li> <li>RubyGems: torch-rb</li> </ul>"},{"location":"projects/#fasttext","title":"fastText","text":"<p>Efficient text classification and representation learning for Ruby.</p> <ul> <li>GitHub: ankane/fastText-ruby</li> <li>RubyGems: fasttext</li> </ul>"},{"location":"projects/#xgboost","title":"XGBoost","text":"<p>High performance gradient boosting for Ruby.</p> <ul> <li>GitHub: ankane/xgboost-ruby</li> <li>RubyGems: xgboost</li> </ul>"},{"location":"projects/#lightgbm","title":"LightGBM","text":"<p>High performance gradient boosting for Ruby.</p> <ul> <li>GitHub: ankane/lightgbm-ruby</li> <li>RubyGems: lightgbm</li> </ul>"},{"location":"projects/#dimensionality-reduction","title":"Dimensionality Reduction","text":""},{"location":"projects/#ruby-umappp","title":"ruby-umappp","text":"<p>Uniform Manifold Approximation and Projection (UMAP) for Ruby.</p> <ul> <li>GitHub: kojix2/ruby-umappp</li> <li>RubyGems: umappp</li> </ul>"},{"location":"projects/#ruby-qdtsne","title":"ruby-qdtsne","text":"<p>QdTSNE dimensionality reduction for Ruby.</p> <ul> <li>GitHub: kojix2/ruby-qdtsne</li> </ul>"},{"location":"projects/#similarity-search-and-clustering","title":"Similarity Search and Clustering","text":""},{"location":"projects/#faiss","title":"Faiss","text":"<p>Efficient similarity search and clustering for Ruby, using Facebook's Faiss library.</p> <ul> <li>GitHub: ankane/faiss-ruby</li> <li>RubyGems: faiss</li> </ul>"},{"location":"projects/#topic-modeling","title":"Topic Modeling","text":""},{"location":"projects/#tomoto","title":"Tomoto","text":"<p>High performance topic modeling for Ruby with support for LDA, HDP, and Dynamic Topic Models.</p> <ul> <li>GitHub: ankane/tomoto-ruby</li> <li>RubyGems: tomoto</li> </ul>"},{"location":"projects/#anomaly-detection","title":"Anomaly Detection","text":""},{"location":"projects/#isotree","title":"IsoTree","text":"<p>Outlier/anomaly detection for Ruby using Isolation Forest.</p> <ul> <li>GitHub: ankane/isotree-ruby</li> <li>RubyGems: isotree</li> </ul>"},{"location":"projects/#outliertree","title":"OutlierTree","text":"<p>Explainable outlier/anomaly detection for Ruby.</p> <ul> <li>GitHub: ankane/outliertree-ruby</li> <li>RubyGems: outliertree</li> </ul>"},{"location":"projects/#operations-research","title":"Operations Research","text":""},{"location":"projects/#or-tools","title":"OR-Tools","text":"<p>Operations research tools for Ruby including constraint programming, linear programming, routing, and scheduling.</p> <ul> <li>GitHub: ankane/or-tools-ruby</li> <li>RubyGems: or-tools</li> </ul>"},{"location":"projects/#scientific-computing","title":"Scientific Computing","text":""},{"location":"projects/#ruby-alglib","title":"ruby-alglib","text":"<p>ALGLIB numerical analysis and data processing library for Ruby.</p> <ul> <li>GitHub: kojix2/ruby-alglib</li> <li>RubyGems: alglib4</li> </ul>"},{"location":"projects/#numohpp","title":"numo.hpp","text":"<p>C++ header for integrating Numo (Ruby's numerical array library) with Rice.</p> <ul> <li>GitHub: ankane/numo.hpp</li> </ul>"},{"location":"projects/#data-structures","title":"Data Structures","text":""},{"location":"projects/#datasketches","title":"DataSketches","text":"<p>Sketch data structures for Ruby for approximate computations on streaming data.</p> <ul> <li>GitHub: ankane/datasketches-ruby</li> <li>RubyGems: datasketches</li> </ul>"},{"location":"projects/#robotics","title":"Robotics","text":""},{"location":"projects/#rock-base-types","title":"Rock base-types","text":"<p>C++ and Ruby definition of base types for the Robot Construction Kit, including Eigen bindings.</p> <ul> <li>GitHub: rock-core/base-types</li> </ul>"},{"location":"projects/#interactive-computing","title":"Interactive Computing","text":""},{"location":"projects/#xeus-ruby","title":"xeus-ruby","text":"<p>Jupyter kernel for Ruby built on the xeus framework.</p> <ul> <li>GitHub: IsabelParedes/xeus-ruby</li> </ul>"},{"location":"projects/#parsing","title":"Parsing","text":""},{"location":"projects/#antlr4-native","title":"antlr4-native","text":"<p>Create native Ruby extensions from ANTLR4 grammars for high-performance parsing.</p> <ul> <li>GitHub: camertron/antlr4-native-rb</li> <li>RubyGems: antlr4-native</li> </ul>"},{"location":"projects/#geospatial","title":"Geospatial","text":""},{"location":"projects/#ruby-mapnik","title":"Ruby-Mapnik","text":"<p>Ruby bindings for Mapnik, an open source toolkit for developing mapping applications.</p> <ul> <li>GitHub: mapnik/Ruby-Mapnik</li> <li>RubyGems: ruby_mapnik</li> </ul>"},{"location":"projects/#media","title":"Media","text":""},{"location":"projects/#mediainfo-ruby","title":"mediainfo-ruby","text":"<p>MediaInfo library bindings using the C++ shared libraries directly.</p> <ul> <li>GitHub: hackerdude/mediainfo-ruby</li> <li>RubyGems: mediainfo-ruby</li> </ul>"},{"location":"projects/#phone-numbers","title":"Phone Numbers","text":""},{"location":"projects/#gphone","title":"gphone","text":"<p>Ruby bindings to Google's libphonenumber for parsing, validating, and formatting phone numbers.</p> <ul> <li>GitHub: elcamino/gphone</li> <li>RubyGems: gphone</li> </ul>"},{"location":"projects/#ab-testing","title":"A/B Testing","text":""},{"location":"projects/#field-test","title":"Field Test","text":"<p>A/B testing for Rails.</p> <ul> <li>GitHub: ankane/field_test</li> <li>RubyGems: field_test</li> </ul>"},{"location":"projects/#code-generation","title":"Code Generation","text":""},{"location":"projects/#ruby-bindgen","title":"ruby-bindgen","text":"<p>Generates FFI and Rice bindings from C and C++ header files using libclang.</p> <ul> <li>GitHub: ruby-rice/ruby-bindgen</li> <li>RubyGems: ruby_bindgen</li> </ul>"},{"location":"projects/#rb","title":"Rb++","text":"<p>Uses rbgccxml and Rice to automatically generate Ruby extensions around C++ source and libraries.</p> <ul> <li>GitHub: jasonroelofs/rbplusplus</li> <li>RubyGems: rbplusplus</li> </ul>"},{"location":"projects/#more-projects","title":"More Projects","text":"<p>View the complete list of gems that depend on Rice on RubyGems.org.</p>"},{"location":"projects/#add-your-project","title":"Add Your Project","text":"<p>Using Rice in your project? Open an issue or pull request on GitHub to add it to this list.</p>"},{"location":"tutorial/","title":"Tutorial","text":"<p>First install Rice.</p> <p>Next, create an extconf.rb file:</p> <pre><code>require 'mkmf-rice'\ncreate_makefile('test')\n</code></pre> <p>Note that we use <code>mkmf-rice</code> instead of <code>mkmf</code>. This ensures that the extension will be linked with the standard C++ library and allows access to the Rice header files.</p> <p>Note</p> <p>Advanced users may wish to use CMake instead.</p> <p>Next we create an extension and save it to <code>test.cpp</code>:</p> <pre><code>#include &lt;rice/rice.hpp&gt;\n\nextern \"C\"\nvoid Init_test()\n{\n}\n</code></pre> <p>There are two important things to note:</p> <ol> <li> <p>The function must be named <code>Init_&lt;extension_name&gt;</code>, where <code>&lt;extension_name&gt;</code> matches the name passed to <code>create_makefile</code> in your <code>extconf.rb</code>. In this case, it's <code>Init_test</code> because we used <code>create_makefile('test')</code>.</p> </li> <li> <p>The <code>extern \"C\"</code> tells the compiler that the function should have C linkage. This turns off C++ name mangling so that the Ruby interpreter can find the function (Ruby is written in C, not C++).</p> </li> </ol>"},{"location":"tutorial/#symbol-visibility","title":"Symbol Visibility","text":"<p>On some platforms, you may need to explicitly export the <code>Init_</code> function so that Ruby can find it when loading the extension. This is done with platform-specific attributes:</p> <pre><code>#include &lt;rice/rice.hpp&gt;\n\nextern \"C\"\n#if defined(_WIN32)\n__declspec(dllexport)\n#else\n__attribute__((visibility(\"default\")))\n#endif\nvoid Init_test()\n{\n}\n</code></pre> <p>Rice provides a convenience macro <code>RUBY_RICE_EXPORT</code> that handles this for you:</p> <pre><code>#include &lt;rice/rice.hpp&gt;\n\nextern \"C\"\nRUBY_RICE_EXPORT\nvoid Init_test()\n{\n}\n</code></pre> <p>Note</p> <p>When using <code>mkmf-rice</code>, the symbol visibility is usually handled automatically. The explicit export is mainly needed when using CMake or custom build systems.</p>"},{"location":"tutorial/#exception-protection","title":"Exception Protection","text":"<p>If your initialization code could throw a C++ exception, you must protect it using <code>Rice::detail::cpp_protect</code>. This ensures that any C++ exceptions are properly caught and converted to Ruby exceptions, preventing crashes:</p> <pre><code>#include &lt;rice/rice.hpp&gt;\n\nvoid initialize()\n{\n  // Your initialization code here\n  define_class&lt;MyClass&gt;(\"MyClass\")\n    .define_constructor(Constructor&lt;MyClass&gt;())\n    .define_method(\"hello\", &amp;MyClass::hello);\n}\n\nextern \"C\"\nRUBY_RICE_EXPORT\nvoid Init_test()\n{\n  Rice::detail::cpp_protect([]\n  {\n    initialize();\n  });\n}\n</code></pre> <p>The <code>cpp_protect</code> function wraps the initialization in a try-catch block that converts C++ exceptions to Ruby exceptions. Without this protection, an uncaught C++ exception during initialization would crash the Ruby interpreter.</p> <p>So far we haven't put anything into the extension, so it isn't particularly useful. The next step is to define a class so we can add methods to it.</p>"},{"location":"tutorial/#defining-classes","title":"Defining Classes","text":"<p>Defining a class in Rice is a single call:</p> <pre><code>#include &lt;rice/rice.hpp&gt;\n\nusing namespace Rice;\n\nextern \"C\"\nvoid Init_test()\n{\n  Class rb_cTest = define_class(\"Test\");\n}\n</code></pre> <p>This will create a class called <code>Test</code> that inherits from <code>Object</code>. If we wanted to inherit from a different class, we can do so by adding a second parameter:</p> <pre><code>#include &lt;rice/rice.hpp&gt;\n\nusing namespace Rice;\n\nextern \"C\"\nvoid Init_test()\n{\n  Class rb_cMySocket = define_class(\"MySocket\", rb_cIO);\n}\n</code></pre> <p>Note the prefix <code>rb_c</code> on the name of the class. This is a convention that the Ruby interpreter and many extensions use. It signifies that this is a class and not another type of object. Common naming conventions include:</p> <ul> <li><code>rb_c</code> variable name prefix for a Class</li> <li><code>rb_m</code> variable name prefix for a Module</li> <li><code>rb_e</code> variable name prefix for an Exception type</li> <li><code>rb_</code>  function prefix for a function in the Ruby C API</li> <li><code>rb_f_</code> function prefix to differentiate between an API function that takes Ruby objects as arguments and one that takes C argument types</li> <li><code>rb_*_s_</code> indicates the function is a singleton function</li> <li><code>*_m</code> suffix to indicate the function takes variable number of arguments</li> </ul> <p>Also note that we don't include \"ruby.h\" directly. Rice has a wrapper for ruby.h that handles some compatibility issues across platforms and Ruby versions. Always include the Rice headers before including anything that might include \"ruby.h\".</p>"},{"location":"tutorial/#defining-methods","title":"Defining Methods","text":"<p>Now let's add a method to our class:</p> <pre><code>#include &lt;rice/rice.hpp&gt;\n\nusing namespace Rice;\n\nObject test_hello(Object /* self */)\n{\n  String str(\"hello, world\");\n  return str;\n}\n\nextern \"C\"\nvoid Init_test()\n{\n  Class rb_cTest =\n    define_class(\"Test\")\n    .define_method(\"hello\", &amp;test_hello);\n}\n</code></pre> <p>Here we add a method <code>Test#hello</code> that returns the string \"Hello, World\". The method takes self as an implicit parameter, but isn't used, so we comment it out to prevent a compiler warning.</p> <p>We can also add an <code>#initialize</code> method to our class:</p> <pre><code>#include &lt;rice/rice.hpp&gt;\n#include &lt;rice/stl.hpp&gt;\n\nusing namespace Rice;\n\nObject test_initialize(Object self)\n{\n  self.iv_set(\"@foo\", 42);\n  return self;\n}\n\nObject test_hello(Object /* self */)\n{\n  String str(\"hello, world\");\n  return str;\n}\n\nextern \"C\"\nvoid Init_test()\n{\n  Class rb_cTest =\n    define_class(\"Test\")\n    .define_method(\"initialize\", &amp;test_initialize)\n    .define_method(\"hello\", &amp;test_hello);\n}\n</code></pre> <p>The <code>initialize</code> method sets an instance variable <code>@foo</code> to the value 42. The number is automatically converted to a <code>Fixnum</code> before doing the assignment.</p> <p>Note that we're chaining calls on the <code>Class</code> object. Most member functions in <code>Module</code> and <code>Class</code> return a reference to <code>self</code>, so we can chain as many calls as we want to define as many methods as we want.</p> <p>Note</p> <p>If your compiler complains about \"no matching overloaded function found\" followed by \"could not deduce template argument for 'Function_T\" then that means you are working with an overloaded C++ function or method. As a result, you'll need to give Rice some help as explained in the overloaded methods section.</p> <p>For more information refer to the methods section.</p>"},{"location":"tutorial/#defining-methods-with-lambdas","title":"Defining Methods with Lambdas","text":"<p>It is also possible to define_methods using C++ lambdas. Similar to define_method, the lambda takes self as an implicit parameter:</p> <pre><code>Class rb_cTest =\n  define_class(\"Test\")\n  .define_method(\"hello\", [](Object&amp; object) {\n    return test_hello(object);\n  });\n</code></pre> <p>Note that we pass self as a reference since we do not want to copy it!</p> <p>For more information refer to the methods section.</p>"},{"location":"tutorial/#defining-functions","title":"Defining Functions","text":"<p>It is also possible to add methods to a Ruby class using <code>define_function</code>. The difference is that no implicit self parameter is passed. Once again, you can use function pointers or lambdas:</p> <pre><code>void some_function()\n{\n  // do something\n}\n\nextern \"C\"\nvoid Init_test()\n{\n  Class rb_cTest =\n    define_class(\"Test\")\n    .define_function(\"some_function\", &amp;some_function);\n    .define_function(\"some_function_lambda\", []() {\n      return some_function();\n    });\n}\n</code></pre> <p>For more information refer to the methods section.</p>"},{"location":"tutorial/#wrapping-c-types","title":"Wrapping C++ Types","text":"<p>It's useful to be able to define Ruby classes in a C++ style rather than using the Ruby API directly, but the real power Rice is in wrapping already-defined C++ types.</p> <p>Let's assume we have the following C++ class that we want to wrap:</p> <pre><code>class Test\n{\npublic:\n  static std::string static_hello();\npublic:\n  Test();\n  std::string hello();\n};\n</code></pre> <p>This is a C++ version of the Ruby class we just created in the previous section. To wrap it:</p> <pre><code>#include &lt;rice/rice.hpp&gt;\n#include &lt;rice/stl.hpp&gt;\n\nusing namespace Rice;\n\nextern \"C\"\nvoid Init_test()\n{\n  Data_Type&lt;Test&gt; rb_cTest =\n    define_class&lt;Test&gt;(\"Test\")\n    .define_constructor(Constructor&lt;Test&gt;())\n    .define_singleton_function(\"static_hello\", &amp;Test::static_hello)\n    .define_method(\"hello\", &amp;Test::hello);\n}\n</code></pre> <p>In this example we use <code>Data_Type&lt;&gt;</code> instead of <code>Class</code> and the template version of <code>define_class()</code> instead of the non-template version. This creates a binding in the Rice library between the Ruby class <code>Test</code> and the C++ class Test.</p> <p>Next, we define a function <code>static_hello</code> that is implemented by a C++ static member function. Since static functions are not tied to a specific object, there is no self parameter. Therefore we use <code>define_singleton_function</code> instead of <code>define_method</code>.</p> <p>Last, we define a method <code>hello</code> that is implemented by a C++ member function. When Ruby calls this function, instead of passing an implicit self parameter, Rice is smart enough to direct the call to the correct C++ Test instance.</p>"},{"location":"tutorial/#defining-attributes","title":"Defining Attributes","text":"<p>C++ structures, and sometimes classes, often have public member variables that store data. Rice makes it easy to wrap these member variables via the use of <code>define_attr</code>:</p> <pre><code>struct MyStruct\n{\n  int readOnly = 0;\n  int writeOnly = 0;\n  int readWrite = 0;\n};\n\nData_Type&lt;MyStruct&gt; rb_cMyStrut =\n  define_class&lt;MyStruct&gt;(\"MyStruct\")\n  .define_constructor(Constructor&lt;MyStruct&gt;())\n  .define_attr(\"read_only\",  &amp;MyStruct::readOnly, Rice::AttrAccess::Read)\n  .define_attr(\"write_only\", &amp;MyStruct::writeOnly, Rice::AttrAccess::Write)\n  .define_attr(\"read_write\", &amp;MyStruct::readWrite);\n}\n</code></pre> <p>Notice the use of <code>Rice::AttrAccess::Read</code> to define read-only attributes and <code>Rice::AttrAccess::Write</code> for write-only attributes. If you do not specify an AttrAccess value then Rice make the attribute readable and writable.</p> <p>These attributes can then be accessed in the expected way in Ruby:</p> <pre><code>my_struct = MyStruct.new\na = my_struct.read_only\nmy_struct.write_only = 5\nmy_struct.read_write = 10\nb = my_struct.read_write\n</code></pre> <p>Similarly, you can wrap static members via the use of <code>define_singleton_attr</code>:</p> <pre><code>struct MyStruct\n{\n  static int readOnly = 0;\n  static int writeOnly = 0;\n  static int readWrite = 0;\n};\n\nData_Type&lt;MyStruct&gt; rb_cMyStrut =\n  define_class&lt;MyStruct&gt;(\"MyStruct\")\n  .define_constructor(Constructor&lt;MyStruct&gt;())\n  .define_singleton_attr(\"read_only\", &amp;MyStruct::readOnly, Rice::AttrAccess::Read)\n  .define_singleton_attr(\"write_only\", &amp;MyStruct::writeOnly, Rice::AttrAccess::Write)\n  .define_singleton_attr(\"read_write\", &amp;MyStruct::readWrite);\n}\n</code></pre> <p>These attributes can then be accessed in the expected way in Ruby:</p> <pre><code>a = MyStruct.read_only\nMyStruct.write_only = 5\nMyStruct.read_write = 10\nb = MyStruct.read_write\n</code></pre> <p>For more information refer to the Attributes section.</p>"},{"location":"tutorial/#type-conversions","title":"Type Conversions","text":"<p>Rice is smart enough to convert between most Ruby and C++ objects. Let's look again at our example class:</p> <pre><code>class Test\n{\npublic:\n  Test();\n  std::string hello();\n};\n</code></pre> <p>When we wrote our class, we never wrote a single line of code to convert the <code>std::string</code> returned by <code>hello()</code> into a Ruby type. Nevertheless, the conversion works. When we write:</p> <pre><code>test = Test.new\nputs test.hello\n</code></pre> <p>We get the expected result.</p> <p>Rice includes default specializations for many C++ types. To define your own conversion, please refer to the Type Conversions section.</p>"},{"location":"tutorial/#exceptions","title":"Exceptions","text":"<p>Rice automatically handles exceptions. For example, suppose a member function of our example class can throw an exception:</p> <pre><code>class MyException : public std::exception\n{\n};\n\nclass Test\n{\npublic:\n  Test();\n  std::string hello();\n  void error();\n};\n\nextern \"C\"\nvoid Init_test()\n{\n  Data_Type&lt;Test&gt; rb_cTest =\n    define_class&lt;Test&gt;(\"Test\")\n    .define_constructor(Constructor&lt;Test&gt;())\n    .define_method(\"hello\", &amp;Test::hello)\n    .define_method(\"error\", &amp;Test::error);\n}\n</code></pre> <p>When we call the <code>error</code> function from Ruby, C++ will raise an exception. Rice will catch the exception and convert it into a Ruby exception:</p> <pre><code>test = Test.new\nbegin\n  test.error()\nrescue =&gt; e\n  ..\nend\n</code></pre> <p>For more information refer to the Exceptions section.</p>"},{"location":"tutorial/#next-steps","title":"Next Steps","text":"<p>Hopefully this tutorial will help get you started wrapping C++ libraries for use in Ruby. For more detailed information refer to the Wrapping C++ section.</p>"},{"location":"why_rice/","title":"Why Rice?","text":"<p>Wrapping C and C++ libraries so Ruby can use them is difficult. There are number of common problems that need to solved, including:</p>"},{"location":"why_rice/#type-safety","title":"Type Safety","text":"<p>It is easy to mixup integral types such as ID and VALUE. Some of the functions in the Ruby API are not consistent with which types they take (e.g. rb_const_defined takes an ID and rb_mod_remove_const takes a Symbol).</p>"},{"location":"why_rice/#dry-principle","title":"DRY principle","text":"<p>Specifying the number of arguments that each wrapped function takes is easy to get wrong. Adding a new argument to the function means that the number of arguments passed to rb_define_method must also be updated.</p>"},{"location":"why_rice/#type-conversions","title":"Type Conversions","text":"<p>There are many different functions to convert data to and from ruby types. Many of them have different semantics or different forms. For example, to convert a string, one might use the StringValue macro, but to convert a fixnum, one might use FIX2INT. Unwrapping previously wrapped C data uses yet another form.</p>"},{"location":"why_rice/#exception-safety","title":"Exception Safety","text":"<p>It is imperative that C++ exceptions never make their way into C code, and it is also imperative that a Ruby exception never escape while there are objects on the stack with nontrivial destructors. Rules for when it is okay to use which exceptions are difficult to get right, especially as code is maintained through time.</p>"},{"location":"why_rice/#thread-safety","title":"Thread Safety","text":"<p>Because the Ruby interpreter is not thread safe, the Ruby interpreter must not be run from more than one thread. Because of tricks the GC and scheduler play with the C stack, it's not enough to ensure that only one thread runs the interpreter at any given time; once the interpreter has been run from one thread, it must only ever be run from that thread in the future. Additionally, because Ruby copies the stack when it switches threads, C++ code must be careful not to access objects in one Ruby thread that were created on the stack in another Ruby thread.</p>"},{"location":"why_rice/#c-based-api","title":"C-based API","text":"<p>The Ruby API is not always convenient for accessing Ruby data structures such as Hash and Array, especially when writing C++ code, as the interface for these containers is not consistent with standard containers.</p>"},{"location":"why_rice/#calling-conventions","title":"Calling Conventions","text":"<p>Function pointers passed into the Ruby API must follow the C calling convention. This means that it is not possible to pass a pointer to a template function or static member function (that is, it will work on some platforms, but isn't portable).</p>"},{"location":"why_rice/#inheritance","title":"Inheritance","text":"<p>When wrapping C++ objects, it is easy to store a pointer to a derived class, but then methods in the base class must have knowledge of the derived class in order to unwrap the object. It is possible to always store a pointer to the base class and then dynamic_cast the pointer to the derived type when necessary, but this can be slow and cumbersome, and it isn't likely to work with multiple inheritance. A system that properly handles inheritance for all corner cases is nontrivial.</p>"},{"location":"why_rice/#multiple-inheritance","title":"Multiple Inheritance","text":"<p>C++ supports true multiple inheritance, but the Ruby object model uses single inheritance with mixins. When wrapping a library whose public interface uses multiple inheritance, care must be taken in constructing the mapping.</p>"},{"location":"why_rice/#gc-safety","title":"GC Safety","text":"<p>All live Ruby objects must be marked during the garbage collector's mark phase, otherwise they will be prematurely destroyed. The general rule is that object references stored on the heap should be either registered with rb_gc_register_address or marked by a data object's mark function; object references stored on the stack will be automatically marked, provided the Ruby interpreter was properly initialized at startup.</p>"},{"location":"why_rice/#callbacks","title":"Callbacks","text":"<p>C implements callbacks via function pointers, while Ruby typically implements callbacks via procs. Writing an adapter function to call the proc is not difficult, but there is much opportunity for error (particularly with exception safety).</p>"},{"location":"why_rice/#data-serialization","title":"Data Serialization","text":"<p>By default data objects defined at the C layer are not marshalable. The user must explicitly define functions to marshal the data member by member.</p>"},{"location":"why_rice/#rice-solutions","title":"Rice Solutions","text":"<p>Rice addresses these issues in many ways:</p>"},{"location":"why_rice/#type-safety_1","title":"Type Safety","text":"<p>Rice provides encapsulation for all builtin types, such as Object, Identifier, Class, Module, and String. It automatically checks the dynamic type of an object before constructing an instance of a wrapper.</p>"},{"location":"why_rice/#dry-principle_1","title":"DRY Principle","text":"<p>Rice uses introspection through the use of templates and function overloading to automatically determine the number and types of arguments to functions. Default arguments must still be handled explicitly, however.</p>"},{"location":"why_rice/#type-conversions_1","title":"Type Conversions","text":"<p>Rice provides cast style to_ruby&lt;&gt; and from_ruby&lt;&gt; template functions to simplify explicit type conversions. Automatic type conversions for parameters and return values are generated for all wrapped functions.</p>"},{"location":"why_rice/#exception-safety_1","title":"Exception Safety","text":"<p>Rice automatically converts common exceptions and provides a mechanism for converting user^defined exception types. Rice also provides convenience functions for converting exceptions when calling back into ruby code.</p>"},{"location":"why_rice/#thread-safety_1","title":"Thread Safety","text":"<p>Rice provides no mechanisms for dealing with thread safety. Many common thread safety issues should be alleviated by YARV, which supports POSIX threads.</p>"},{"location":"why_rice/#c-based-api_1","title":"C++ Based API","text":"<p>Rice provides an object-oriented C++ style API to most common functions in the Ruby C API.</p>"},{"location":"why_rice/#calling-conventions_1","title":"Calling Conventions","text":"<p>Rice automatically uses C calling convention for all function pointers passed into the Ruby API.</p>"},{"location":"why_rice/#inheritance_1","title":"Inheritance","text":"<p>Rice provides automatic conversion to the base class type when a wrapped member function is called on the base class.</p>"},{"location":"why_rice/#multiple-inheritance_1","title":"Multiple inheritance","text":"<p>Rice provides no mechanism for multiple inheritance. Multiple inheritance can be simulated via mixins, though this is not yet as easy as it could be.</p>"},{"location":"why_rice/#gc-safety_1","title":"GC Safety","text":"<p>Rice provides a handful of convenience classes for interacting with the garbage collector. There are still basic rules which must be followed to ensure that objects get properly destroyed.</p>"},{"location":"why_rice/#callbacks_1","title":"Callbacks","text":"<p>Rice provides a handful of convenience classes for dealing with callbacks.</p>"},{"location":"why_rice/#data-serialization_1","title":"Data Serialization","text":"<p>Rice provides no mechanism for data serialization, but it is likely this may be added in a future release.</p>"},{"location":"architecture/enumerators/","title":"Enumerators","text":"<p>Although not used that frequently, Ruby supports enumerators that enable both internal and external iteration. The easiest way to create an enumerator is to not pass a block to an enumerable method. For example:</p> <pre><code>a = [1, 2, 3, 4, 5]\n\n# Common way to iterate\na.each do |i|\n  puts i\nend\n\n# Get an enumerator instead\nenumerator = a.each\n\n# Now use it\nenumerator.map |i|\n  i * 2\nend\n</code></pre> <p>Rice has built-in support to returning enumerators for STL containers such as std::vector, std::map and std::unordered_map.</p> <p>Implementing enumerators is tricky - and in fact requires a number of Rice features. So let's take a look at how enumerator support is implemented for std::vector.</p>"},{"location":"architecture/enumerators/#implementation","title":"Implementation","text":"<p>Let's start with looking at the code:</p> <pre><code>define_method(\"each\", [](T&amp; vector) -&gt; const std::variant&lt;std::reference_wrapper&lt;T&gt;, Object&gt;\n{\n  if (!rb_block_given_p())\n  {\n    auto rb_size_function = [](VALUE recv, VALUE argv, VALUE eobj) -&gt; VALUE\n    {\n      T* receiver = Data_Object&lt;T&gt;::from_ruby(recv);\n      return detail::To_Ruby&lt;size_t&gt;().convert(receiver-&gt;size());\n    };\n\n    return rb_enumeratorize_with_size(detail::selfThread, Identifier(\"each\").to_sym(), 0, nullptr, rb_size_function);\n  }\n\n  for (Value_T&amp; item : vector)\n  {\n    VALUE element = detail::To_Ruby&lt;Value_T&gt;().convert(item);\n    detail::protect(rb_yield, element);\n  }\n\n  return std::ref(vector);\n});\n</code></pre>"},{"location":"architecture/enumerators/#method-signature","title":"Method Signature","text":"<p>Rice defines an each method to support Ruby's enumerable module. The vector is passed by reference to avoid a copy. The return type is a std::variant because the method can either return a Ruby enumerator or the vector.</p>"},{"location":"architecture/enumerators/#creating-an-enumerator","title":"Creating an Enumerator","text":"<p>If a block is not provided, the method returns an enumerator using rb_enumeratorize_with_size.</p>"},{"location":"architecture/enumerators/#yielding-to-a-block","title":"Yielding to a Block","text":"<p>The code iterates over each item by reference, wraps it in a Ruby object, and yields it to the block.</p>"},{"location":"architecture/enumerators/#returning-self","title":"Returning Self","text":"<p>Returns a reference to the vector wrapped in std::reference_wrapper to enable method chaining.</p>"},{"location":"architecture/incomplete_types/","title":"Incomplete Types","text":"<p>Rice supports working with incomplete (forward-declared) types. This is essential for wrapping C++ libraries that use the PIMPL idiom or opaque handle patterns, where implementation details are hidden behind forward declarations.</p>"},{"location":"architecture/incomplete_types/#what-are-incomplete-types","title":"What Are Incomplete Types?","text":"<p>An incomplete type is a type that has been declared but not defined. The compiler knows the type exists but doesn't know its size or layout:</p> <pre><code>// Forward declaration - incomplete type\nclass WidgetImpl;\n\nclass Widget {\npublic:\n    // Returns pointer to incomplete type\n    WidgetImpl* getImpl();\n\n    // Returns reference to incomplete type\n    WidgetImpl&amp; getImplRef();\n\nprivate:\n    WidgetImpl* pImpl_;  // PIMPL idiom\n};\n</code></pre>"},{"location":"architecture/incomplete_types/#common-patterns","title":"Common Patterns","text":""},{"location":"architecture/incomplete_types/#pimpl-idiom","title":"PIMPL Idiom","text":"<p>The Private Implementation (PIMPL) idiom hides implementation details:</p> <pre><code>// widget.hpp - public header\nclass WidgetImpl;  // Forward declaration only\n\nclass Widget {\npublic:\n    Widget();\n    ~Widget();\n    void doSomething();\n    WidgetImpl* getImpl();\n\nprivate:\n    WidgetImpl* pImpl_;\n};\n\n// widget.cpp - implementation (not exposed to users)\nclass WidgetImpl {\n    int value = 42;\n    // ... implementation details\n};\n</code></pre>"},{"location":"architecture/incomplete_types/#opaque-handles","title":"Opaque Handles","text":"<p>Common in C libraries where handles are passed around without exposing internals:</p> <pre><code>// Forward declaration only - never defined in headers\nstruct OpaqueHandle;\n\nOpaqueHandle* createHandle();\nvoid destroyHandle(OpaqueHandle* handle);\nint getHandleData(OpaqueHandle* handle);\n</code></pre>"},{"location":"architecture/incomplete_types/#wrapping-incomplete-types","title":"Wrapping Incomplete Types","text":"<p>To wrap functions that use incomplete types, you must register the incomplete type with Rice using <code>define_class</code>. Rice doesn't need to know the type's size or layout - it just needs to know the type exists:</p> <pre><code>#include &lt;rice/rice.hpp&gt;\n\n// Forward declaration - WidgetImpl is never defined here\nclass WidgetImpl;\n\nclass Widget {\npublic:\n    WidgetImpl* getImpl();\n    WidgetImpl&amp; getImplRef();\n};\n\nextern \"C\" void Init_widget()\n{\n    using namespace Rice;\n\n    // Register the incomplete type - Rice just needs to know it exists\n    define_class&lt;WidgetImpl&gt;(\"WidgetImpl\");\n\n    // Now we can wrap methods that use WidgetImpl\n    define_class&lt;Widget&gt;(\"Widget\")\n        .define_constructor(Constructor&lt;Widget&gt;())\n        .define_method(\"get_impl\", &amp;Widget::getImpl)\n        .define_method(\"get_impl_ref\", &amp;Widget::getImplRef);\n}\n</code></pre>"},{"location":"architecture/incomplete_types/#supported-operations","title":"Supported Operations","text":"<p>Rice supports incomplete types in the following contexts:</p> Operation Example Supported Return pointer <code>Impl* getImpl()</code> Yes Return reference <code>Impl&amp; getImplRef()</code> Yes Return const reference <code>const Impl&amp; getImplRef() const</code> Yes Parameter pointer <code>void setImpl(Impl* impl)</code> Yes Parameter reference <code>void process(Impl&amp; impl)</code> Yes Parameter const reference <code>void read(const Impl&amp; impl)</code> Yes"},{"location":"architecture/incomplete_types/#error-handling","title":"Error Handling","text":"<p>If you try to use an incomplete type without registering it, Rice will raise a Ruby exception:</p> <pre><code>// Without registering OpaqueHandle...\ndefine_global_function(\"create_handle\", &amp;createHandle);\n\n// Calling from Ruby will raise:\n// Rice::Exception: Type is not registered with Rice: OpaqueHandle\n</code></pre> <p>Always register incomplete types with <code>define_class</code> before wrapping functions that use them.</p>"},{"location":"architecture/incomplete_types/#real-world-example-opencv","title":"Real-World Example: OpenCV","text":"<p>OpenCV uses the PIMPL idiom extensively. For example, <code>cv::dnn::Net</code> has:</p> <pre><code>namespace cv { namespace dnn {\n    class Net {\n    public:\n        struct Impl;  // Forward declaration\n\n        Impl* getImpl() const;\n        Impl&amp; getImplRef();\n\n    private:\n        Ptr&lt;Impl&gt; impl;\n    };\n}}\n</code></pre> <p>To wrap this in Rice:</p> <pre><code>#include &lt;rice/rice.hpp&gt;\n#include &lt;opencv2/dnn.hpp&gt;\n\nextern \"C\" void Init_dnn()\n{\n    using namespace Rice;\n\n    Module rb_mCv = define_module(\"Cv\");\n    Module rb_mDnn = define_module_under(rb_mCv, \"Dnn\");\n\n    // Register the incomplete Impl type\n    define_class_under&lt;cv::dnn::Net::Impl&gt;(rb_mDnn, \"Impl\");\n\n    // Now wrap Net with its getImpl methods\n    define_class_under&lt;cv::dnn::Net&gt;(rb_mDnn, \"Net\")\n        .define_constructor(Constructor&lt;cv::dnn::Net&gt;())\n        .define_method(\"get_impl\", &amp;cv::dnn::Net::getImpl)\n        .define_method(\"get_impl_ref\", &amp;cv::dnn::Net::getImplRef);\n}\n</code></pre>"},{"location":"architecture/incomplete_types/#how-it-works","title":"How It Works","text":"<p>Rice handles incomplete types by:</p> <ol> <li>Storing a pointer to the object without needing to know its size</li> <li>Using type erasure to manage the Ruby VALUE wrapper</li> <li>Tracking the type in Rice's type registry for proper conversion</li> </ol> <p>Since Rice only stores pointers and never copies incomplete types by value, it doesn't need the complete type definition. The actual object lifetime is managed by the C++ code that owns it.</p>"},{"location":"architecture/incomplete_types/#limitations","title":"Limitations","text":"<ul> <li>Cannot create instances of incomplete types from Ruby (no constructor)</li> <li>Cannot copy incomplete types by value</li> <li>Cannot access members of incomplete types directly</li> <li>The incomplete type must be registered before any function using it is called</li> </ul>"},{"location":"architecture/incomplete_types/#smart-pointers-to-incomplete-types","title":"Smart Pointers to Incomplete Types","text":"<p>While Rice supports raw pointers and references to incomplete types, smart pointers (<code>std::shared_ptr</code>, <code>std::unique_ptr</code>, etc.) require special handling.</p>"},{"location":"architecture/incomplete_types/#the-problem","title":"The Problem","text":"<p>Smart pointers need to instantiate their deleter at compile time. When you create a <code>std::shared_ptr&lt;T&gt;</code> from a raw <code>T*</code>, the template must generate code to <code>delete</code> the pointer - which requires <code>T</code> to be a complete type:</p> <pre><code>class Impl;  // Forward declaration - incomplete\n\n// This will cause a compiler warning/error:\n// \"deletion of pointer to incomplete type; no destructor called\"\nstd::shared_ptr&lt;Impl&gt; ptr(new Impl);  // Can't instantiate deleter!\n</code></pre>"},{"location":"architecture/incomplete_types/#rices-solution","title":"Rice's Solution","text":"<p>Rice's <code>define_shared_ptr&lt;T&gt;()</code> function uses <code>is_complete_v&lt;T&gt;</code> to detect incomplete types and skip registering constructors that would require the complete type:</p> <pre><code>// From rice/stl/shared_ptr.ipp\nif constexpr (detail::is_complete_v&lt;T&gt; &amp;&amp; !std::is_void_v&lt;T&gt;)\n{\n    result.define_constructor(Constructor&lt;SharedPtr_T, T*&gt;(),\n        Arg(\"value\").takeOwnership());\n}\n</code></pre> <p>This means: - Complete types: Full smart pointer support including construction from raw pointers - Incomplete types: Smart pointer type is registered, but constructors taking <code>T*</code> are skipped</p>"},{"location":"architecture/incomplete_types/#passing-existing-smart-pointers","title":"Passing Existing Smart Pointers","text":"<p>Even without the <code>T*</code> constructor, you can still pass around existing smart pointers that were created on the C++ side (where the complete type is available):</p> <pre><code>class Widget {\npublic:\n    struct Impl;\n    std::shared_ptr&lt;Impl&gt; getImpl();  // Returns existing shared_ptr - OK!\n    void setImpl(std::shared_ptr&lt;Impl&gt; impl);  // Accepts existing shared_ptr - OK!\nprivate:\n    std::shared_ptr&lt;Impl&gt; pImpl_;\n};\n</code></pre>"},{"location":"architecture/incomplete_types/#custom-smart-pointer-types","title":"Custom Smart Pointer Types","text":"<p>If you're wrapping a library with its own smart pointer type (like OpenCV's <code>cv::Ptr</code>), apply the same pattern:</p> <pre><code>template&lt;typename T&gt;\nData_Type&lt;CustomPtr&lt;T&gt;&gt; define_custom_ptr()\n{\n    // ... setup ...\n\n    // Only define T* constructor for complete types\n    if constexpr (detail::is_complete_v&lt;T&gt; &amp;&amp; !std::is_void_v&lt;T&gt;)\n    {\n        result.define_constructor(Constructor&lt;CustomPtr&lt;T&gt;, T*&gt;(),\n            Arg(\"ptr\").takeOwnership());\n    }\n\n    return result;\n}\n</code></pre>"},{"location":"architecture/incomplete_types/#using-is_complete_v","title":"Using is_complete_v","text":"<p>Rice provides the <code>detail::is_complete_v&lt;T&gt;</code> trait for detecting incomplete types:</p> <pre><code>#include &lt;rice/rice.hpp&gt;\n\nclass Complete { int x; };\nclass Incomplete;\n\nstatic_assert(Rice::detail::is_complete_v&lt;Complete&gt; == true);\nstatic_assert(Rice::detail::is_complete_v&lt;Incomplete&gt; == false);\n</code></pre>"},{"location":"architecture/incomplete_types/#see-also","title":"See Also","text":"<ul> <li>Smart Pointers - Implementing support for custom smart pointer types</li> <li>Pointers - General pointer handling in Rice</li> <li>References - Reference handling in Rice</li> <li>Memory Management - Object lifetime management</li> </ul>"},{"location":"architecture/method_binding/","title":"Method Binding","text":"<p>Method binding connects C++ functions and methods to Ruby. This is handled by the <code>Native</code> class hierarchy.</p>"},{"location":"architecture/method_binding/#native-hierarchy","title":"Native Hierarchy","text":"<p>The <code>Native</code> base class defines the interface for all bound callables:</p> <pre><code>Native (abstract base)\n+-- NativeFunction      - Module/class functions (define_function)\n+-- NativeMethod        - Instance methods (define_method)\n+-- NativeIterator      - Iterator methods (define_iterator)\n+-- NativeAttributeGet  - Attribute readers (define_attr)\n+-- NativeAttributeSet  - Attribute writers (define_attr)\n+-- NativeProc          - Ruby blocks as C++ callables\n+-- NativeCallback      - C-style function pointer callbacks\n</code></pre>"},{"location":"architecture/method_binding/#native-base-class","title":"Native Base Class","text":"<pre><code>class Native\n{\npublic:\n  // Find the best matching overload and invoke it\n  static VALUE resolve(int argc, VALUE* argv, VALUE self);\n\n  // Check if this native matches the given arguments\n  virtual Resolved matches(std::map&lt;std::string, VALUE&gt;&amp; values);\n\n  // Invoke the C++ callable\n  virtual VALUE operator()(std::map&lt;std::string, VALUE&gt;&amp; values, VALUE self) = 0;\n\nprotected:\n  std::string name_;\n  std::unique_ptr&lt;Return&gt; returnInfo_;\n  std::vector&lt;std::unique_ptr&lt;ParameterAbstract&gt;&gt; parameters_;\n};\n</code></pre> <p>Each <code>Native</code> subclass:</p> <ol> <li>Stores the C++ callable (function pointer, method pointer, or lambda)</li> <li>Stores parameter metadata (names, types, defaults)</li> <li>Implements <code>matches()</code> for overload resolution</li> <li>Implements <code>operator()</code> to invoke the C++ code</li> </ol>"},{"location":"architecture/method_binding/#method-resolution","title":"Method Resolution","text":"<p>When Ruby calls a wrapped method, <code>Native::resolve()</code> finds and invokes the correct C++ overload:</p> <ol> <li> <p>Lookup: Retrieve all <code>Native</code> instances registered for this method name from <code>NativeRegistry</code></p> </li> <li> <p>Match: For each candidate, call <code>matches()</code> to check argument compatibility</p> </li> <li> <p>Rank: Score matches by conversion quality using <code>Convertible</code> enum</p> </li> <li> <p>Select: Pick the candidate with the highest score</p> </li> <li> <p>Invoke: Call the winner's <code>operator()</code></p> </li> </ol>"},{"location":"architecture/method_binding/#overload-resolution-example","title":"Overload Resolution Example","text":"<p>Given these overloads:</p> <pre><code>void process(int x);           // Overload 1\nvoid process(double x);        // Overload 2\nvoid process(const string&amp; s); // Overload 3\n</code></pre> <p>When Ruby calls <code>process(42)</code>:</p> <ul> <li>Overload 1: <code>Exact</code> match (Ruby Integer -&gt; C++ int)</li> <li>Overload 2: <code>Narrow</code> match (Ruby Integer -&gt; C++ double)</li> <li>Overload 3: <code>None</code> (Ruby Integer cannot convert to string)</li> </ul> <p>Overload 1 wins with the <code>Exact</code> match.</p>"},{"location":"architecture/method_binding/#invocation-flow","title":"Invocation Flow","text":"<p>When a <code>Native</code> is invoked:</p> <pre><code>VALUE NativeMethod&lt;T, Func&gt;::operator()(std::map&lt;std::string, VALUE&gt;&amp; values, VALUE self)\n{\n  // 1. Get the C++ receiver object\n  T* receiver = From_Ruby&lt;T*&gt;().convert(self);\n\n  // 2. Convert Ruby arguments to C++ types\n  auto args = convertArguments(argc, argv);\n\n  // 3. Call the C++ method\n  auto result = std::apply(\n    [&amp;](auto&amp;&amp;... args) {\n      return (receiver-&gt;*method_)(std::forward&lt;decltype(args)&gt;(args)...);\n    },\n    args\n  );\n\n  // 4. Convert result to Ruby\n  return To_Ruby&lt;ReturnType&gt;().convert(result);\n}\n</code></pre>"},{"location":"architecture/method_binding/#parameter-handling","title":"Parameter Handling","text":"<p>Each parameter is described by a <code>Parameter</code> object containing:</p> <ul> <li>Type information: Used for conversion and overload resolution</li> <li>Arg metadata: Name, default value, whether it's optional</li> </ul>"},{"location":"architecture/method_binding/#default-arguments","title":"Default Arguments","text":"<p>Default arguments are stored in <code>Arg</code> objects:</p> <pre><code>define_method(\"greet\", &amp;Person::greet,\n  Arg(\"name\"),\n  Arg(\"greeting\") = \"Hello\");  // Default value\n</code></pre> <p>When Ruby omits an argument, Rice uses the stored default.</p>"},{"location":"architecture/method_binding/#keyword-arguments","title":"Keyword Arguments","text":"<p>Rice supports Ruby keyword arguments:</p> <pre><code>define_method(\"configure\", &amp;Config::set,\n  Arg(\"timeout\").setKeyword(),\n  Arg(\"retries\").setKeyword() = 3);\n</code></pre> <p>Ruby can then call:</p> <pre><code>obj.configure(timeout: 30, retries: 5)\n</code></pre>"},{"location":"architecture/method_binding/#registration","title":"Registration","text":"<p>When you call <code>define_method</code>, Rice:</p> <ol> <li>Creates a <code>NativeMethod</code> instance storing the method pointer</li> <li>Registers it in <code>NativeRegistry</code> under the method name</li> <li>Defines a Ruby method that calls <code>Native::resolve</code></li> </ol> <pre><code>template&lt;typename Method_T&gt;\nvoid define_method(const char* name, Method_T method)\n{\n  // Create native wrapper\n  auto native = std::make_unique&lt;NativeMethod&lt;T, Method_T&gt;&gt;(name, method);\n\n  // Register in NativeRegistry\n  detail::Registries::instance().natives().add(klass_, std::move(native));\n\n  // Define Ruby method pointing to resolve()\n  rb_define_method(klass_, name, &amp;Native::resolve, -1);\n}\n</code></pre> <p>The <code>-1</code> arity tells Ruby to pass all arguments to <code>resolve()</code>, which then handles overload resolution.</p>"},{"location":"architecture/method_binding/#see-also","title":"See Also","text":"<ul> <li>Types Overview - How arguments are converted</li> <li>Registries - Where natives are stored</li> <li>Methods - User guide for defining methods</li> <li>Overloaded Methods - User guide for overloading</li> </ul>"},{"location":"architecture/overload_resolution/","title":"Overload Resolution","text":"<p>This document explains how Rice resolves C++ method overloads when called from Ruby.</p>"},{"location":"architecture/overload_resolution/#overview","title":"Overview","text":"<p>When a C++ class has multiple methods with the same name but different parameter types (overloads), Rice must determine which one to call based on the Ruby arguments provided. Rice uses a numeric scoring system where each overload receives a score from 0.0 to 1.0, and the highest-scoring overload is selected.</p>"},{"location":"architecture/overload_resolution/#scoring-constants","title":"Scoring Constants","text":"<p>The scoring system is defined in <code>rice/detail/from_ruby.hpp</code>:</p> <pre><code>struct Convertible\n{\n  static constexpr double Exact = 1.0;           // Perfect type match\n  static constexpr double None = 0.0;            // Cannot convert\n  static constexpr double IntToFloat = 0.5;      // Penalty for int to float conversion\n  static constexpr double SignedToUnsigned = 0.5;// Penalty for signed to unsigned (can't represent negatives)\n  static constexpr double FloatToInt = 0.5;      // Penalty for float to int conversion\n  static constexpr double ConstMismatch = 0.99;  // Penalty for const mismatch\n};\n</code></pre>"},{"location":"architecture/overload_resolution/#precision-bits","title":"Precision Bits","text":"<p>Ruby numeric types have precision defined in terms of bits:</p> Ruby Type Precision Bits Notes Integer (Fixnum/Bignum) 63 Same as C++ long long Float 53 Same as C++ double mantissa <p>C++ types use <code>std::numeric_limits&lt;T&gt;::digits</code>:</p> C++ Type Precision Bits char 7 signed char 7 unsigned char 8 short 15 unsigned short 16 int 31 unsigned int 32 long 31 or 63* unsigned long 32 or 64* long long 63 unsigned long long 64 float 24 (mantissa) double 53 (mantissa) <p>* Platform dependent</p>"},{"location":"architecture/overload_resolution/#same-domain-conversions","title":"Same-Domain Conversions","text":"<p>When converting within the same numeric domain (integer-to-integer or float-to-float):</p> <p>Widening conversion (target &gt;= source bits): Score = 1.0</p> <p>Narrowing conversion (target &lt; source bits): Score = targetBits / sourceBits</p> <p>Example: Ruby Integer (63 bits) to C++ short (15 bits) <pre><code>Score = 15 / 63 = 0.238\n</code></pre></p>"},{"location":"architecture/overload_resolution/#signed-to-unsigned","title":"Signed to Unsigned","text":"<p>When converting a Ruby Integer (which is signed) to an unsigned C++ type, a penalty is applied because unsigned types cannot represent negative values:</p> <pre><code>Score = precisionScore * SignedToUnsigned\n      = precisionScore * 0.5\n</code></pre> <p>Example: Ruby Integer (63 bits) to C++ unsigned int (32 bits) <pre><code>precisionScore = 32 / 63 = 0.508\nScore = 0.508 * 0.5 = 0.254\n</code></pre></p> <p>This ensures signed types are preferred over unsigned types. For example, given overloads <code>foo(int)</code> and <code>foo(unsigned int)</code>:</p> Overload Score Calculation foo(int) 0.49 31/63 foo(unsigned int) 0.25 32/63 \u00d7 0.5 <p>Result: <code>foo(int)</code> is selected.</p>"},{"location":"architecture/overload_resolution/#cross-domain-conversions","title":"Cross-Domain Conversions","text":""},{"location":"architecture/overload_resolution/#integer-to-float","title":"Integer to Float","text":"<p>When converting a Ruby Integer to a C++ float type, the score combines precision loss with a domain-change penalty:</p> <pre><code>Score = precisionScore * IntToFloat\n      = precisionScore * 0.5\n</code></pre> <p>Example: Ruby Integer (63 bits) to C++ double (53 bits) <pre><code>precisionScore = min(63, 53) / 63 = 53/63 = 0.841\nScore = 0.841 * 0.5 = 0.42\n</code></pre></p> <p>Example: Ruby Integer (63 bits) to C++ float (24 bits) <pre><code>precisionScore = min(63, 24) / 63 = 24/63 = 0.381\nScore = 0.381 * 0.5 = 0.19\n</code></pre></p>"},{"location":"architecture/overload_resolution/#float-to-integer","title":"Float to Integer","text":"<p>When converting a Ruby Float to a C++ integer type, a penalty is applied because the fractional part is lost:</p> <pre><code>Score = precisionScore * FloatToInt\n      = precisionScore * 0.5\n</code></pre> <p>Example: Ruby Float (53 bits) to C++ int (31 bits) <pre><code>precisionScore = 31 / 53 = 0.585\nScore = 0.585 * 0.5 = 0.292\n</code></pre></p> <p>Example: Ruby Float (53 bits) to C++ long long (63 bits) <pre><code>precisionScore = 53 / 53 = 1.0 (capped, since 63 &gt;= 53)\nScore = 1.0 * 0.5 = 0.5\n</code></pre></p>"},{"location":"architecture/overload_resolution/#type-mapping-reference","title":"Type Mapping Reference","text":"<p>The following table shows conversion scores for all Ruby-to-C++ type combinations, with the underlying calculations.</p> C++ Type Bits True False Nil String Integer Float bool - 1.0 1.0 1.0 char 7 1.0 0.11 = 7/63 0.07 = 7/53\u00d70.5 signed char 7 1.0 0.11 = 7/63 0.07 = 7/53\u00d70.5 unsigned char 8 1.0 0.06 = 8/63\u00d70.5 0.08 = 8/53\u00d70.5 short 15 0.24 = 15/63 0.14 = 15/53\u00d70.5 unsigned short 16 0.13 = 16/63\u00d70.5 0.15 = 16/53\u00d70.5 int 31 0.49 = 31/63 0.29 = 31/53\u00d70.5 unsigned int 32 0.25 = 32/63\u00d70.5 0.30 = 32/53\u00d70.5 long* 31 0.49 = 31/63 0.29 = 31/53\u00d70.5 unsigned long* 32 0.25 = 32/63\u00d70.5 0.30 = 32/53\u00d70.5 long long 63 1.0 = 63/63 0.50 = 1.0\u00d70.5 unsigned long long 64 0.50 = 1.0\u00d70.5 0.50 = 1.0\u00d70.5 float 24 0.19 = 24/63\u00d70.5 0.45 = 24/53 double 53 0.42 = 53/63\u00d70.5 1.0 = 53/53 <p>* <code>long</code> is platform-dependent. On 64-bit systems: <code>long</code> = 63 bits, <code>unsigned long</code> = 64 bits.</p> <p>Score formulas: - Integer \u2192 signed integer: <code>targetBits / 63</code> (narrowing) or <code>1.0</code> (widening) - Integer \u2192 unsigned integer: <code>(targetBits / 63) \u00d7 0.5</code> (SignedToUnsigned penalty) - Integer \u2192 float: <code>min(targetBits, 63) / 63 \u00d7 0.5</code> (IntToFloat penalty) - Float \u2192 integer: <code>min(targetBits, 53) / 53 \u00d7 0.5</code> (FloatToInt penalty) - Float \u2192 float: <code>targetBits / 53</code> (narrowing) or <code>1.0</code> (widening)</p>"},{"location":"architecture/overload_resolution/#default-parameters","title":"Default Parameters","text":"<p>When an overload has default parameters and the caller does not provide all arguments, a small penalty is applied for each default used:</p> <pre><code>parameterMatch = 0.99 ^ defaultCount\n</code></pre> <p>This ensures that overloads that exactly match the argument count are preferred over those that rely on defaults.</p>"},{"location":"architecture/overload_resolution/#final-score-calculation","title":"Final Score Calculation","text":"<p>The final score for an overload is:</p> <pre><code>finalScore = minParameterScore * parameterMatch\n</code></pre> <p>Where: - <code>minParameterScore</code> is the minimum score across all passed arguments - <code>parameterMatch</code> is the penalty for default parameters (0.99 per default)</p> <p>Using the minimum ensures that one bad match cannot be hidden by good matches elsewhere.</p>"},{"location":"architecture/overload_resolution/#const-correctness","title":"Const Correctness","text":"<p>When a Ruby-wrapped C++ object is passed as an argument:</p> <ul> <li>Passing a const object to a non-const parameter: Score = 0.0 (not allowed)</li> <li>Passing a non-const object to a const parameter: Score *= 0.99 (small penalty)</li> <li>Matching constness: No penalty</li> </ul>"},{"location":"architecture/overload_resolution/#resolution-process","title":"Resolution Process","text":"<p>The resolution happens in <code>rice/detail/Native.ipp</code>:</p> <ol> <li><code>Native::resolve()</code> is called when Ruby invokes a method</li> <li>For each registered overload, <code>Native::matches()</code> computes a score</li> <li>Overloads are sorted by score (highest first)</li> <li>The highest-scoring overload is selected</li> <li>If no overload scores above 0.0, an error is raised</li> </ol>"},{"location":"architecture/overload_resolution/#examples","title":"Examples","text":""},{"location":"architecture/overload_resolution/#example-1-exact-match-vs-type-conversion","title":"Example 1: Exact Match vs Type Conversion","text":"<p>Given these C++ overloads: <pre><code>void foo(int x);\nvoid foo(double x);\n</code></pre></p> <p>Called with Ruby Integer <code>foo(42)</code>:</p> Overload Parameter Score Final Score foo(int) 1.0 (exact) 1.0 foo(double) 0.42 (int to float) 0.42 <p>Result: <code>foo(int)</code> is selected.</p> <p>Called with Ruby Float <code>foo(3.14)</code>:</p> Overload Parameter Score Final Score foo(int) 0.5 (float to int) 0.5 foo(double) 1.0 (exact) 1.0 <p>Result: <code>foo(double)</code> is selected.</p>"},{"location":"architecture/overload_resolution/#example-2-default-parameters","title":"Example 2: Default Parameters","text":"<p>Given these C++ overloads: <pre><code>void bar(int x);\nvoid bar(int x, int y = 0);\n</code></pre></p> <p>Called with <code>bar(1)</code>:</p> Overload Min Score Param Match Final Score bar(int) 1.0 1.0 1.0 bar(int, int=0) 1.0 0.99 0.99 <p>Result: <code>bar(int)</code> is selected because it has no defaults.</p> <p>Called with <code>bar(1, 2)</code>:</p> Overload Min Score Param Match Final Score bar(int) N/A N/A 0.0 (too many args) bar(int, int=0) 1.0 1.0 1.0 <p>Result: <code>bar(int, int=0)</code> is selected.</p>"},{"location":"architecture/overload_resolution/#example-3-precision-based-selection","title":"Example 3: Precision-Based Selection","text":"<p>Given these C++ overloads: <pre><code>void baz(short x);\nvoid baz(long long x);\n</code></pre></p> <p>Called with Ruby Integer <code>baz(1)</code>:</p> Overload Parameter Score Final Score baz(short) 15/63 = 0.238 0.238 baz(long long) 63/63 = 1.0 1.0 <p>Result: <code>baz(long long)</code> is selected because it can hold the full precision.</p>"},{"location":"architecture/overload_resolution/#example-4-mixed-arguments","title":"Example 4: Mixed Arguments","text":"<p>Given this C++ overload: <pre><code>void qux(int a, double b);\nvoid qux(double a, int b);\n</code></pre></p> <p>Called with <code>qux(1, 2.0)</code> (Integer, Float):</p> Overload Scores Min Score Final qux(int, double) 1.0, 1.0 1.0 1.0 qux(double, int) 0.42, 0.5 0.42 0.42 <p>Result: <code>qux(int, double)</code> is selected.</p> <p>Called with <code>qux(1.0, 2)</code> (Float, Integer):</p> Overload Scores Min Score Final qux(int, double) 0.5, 0.42 0.42 0.42 qux(double, int) 1.0, 1.0 1.0 1.0 <p>Result: <code>qux(double, int)</code> is selected.</p>"},{"location":"architecture/overload_resolution/#example-5-const-correctness","title":"Example 5: Const Correctness","text":"<p>Given these C++ overloads: <pre><code>void process(MyClass&amp; obj);\nvoid process(const MyClass&amp; obj);\n</code></pre></p> <p>Called with a non-const Ruby-wrapped MyClass:</p> Overload Score process(MyClass&amp;) 1.0 process(const MyClass&amp;) 0.99 <p>Result: <code>process(MyClass&amp;)</code> is selected.</p> <p>Called with a const Ruby-wrapped MyClass:</p> Overload Score process(MyClass&amp;) 0.0 (not allowed) process(const MyClass&amp;) 1.0 <p>Result: <code>process(const MyClass&amp;)</code> is selected.</p>"},{"location":"architecture/overload_resolution/#key-files","title":"Key Files","text":"<ul> <li><code>rice/detail/from_ruby.hpp</code> - Defines Convertible constants</li> <li><code>rice/detail/from_ruby.ipp</code> - Implements rubyPrecisionBits(), precisionScore(), and FromRubyFundamental</li> <li><code>rice/detail/Native.hpp</code> - Defines Resolved struct and Native class</li> <li><code>rice/detail/Native.ipp</code> - Implements resolve(), matches(), and matchParameters()</li> <li><code>rice/detail/Parameter.hpp</code> - Defines Parameter class</li> <li><code>rice/detail/Parameter.ipp</code> - Implements Parameter::matches()</li> </ul>"},{"location":"architecture/overload_resolution/#see-also","title":"See Also","text":"<ul> <li><code>test/test_Overloads.cpp</code> - Test cases for overload resolution</li> </ul>"},{"location":"architecture/overview/","title":"Overview","text":"<p>Rice is a header-only C++ library that bridges Ruby and C++ using template metaprogramming. This section explains the key architectural concepts that make Rice work.</p>"},{"location":"architecture/overview/#core-design-principles","title":"Core Design Principles","text":"<p>Header-Only   Rice requires no compilation\u2014just include the headers. All implementation is in <code>.hpp</code> and <code>.ipp</code> files.</p> <p>Template Metaprogramming   Rice uses C++ templates to automatically deduce types at compile time, eliminating boilerplate code.</p> <p>Type Safety   The C++ type system catches errors at compile time rather than runtime.</p> <p>Minimal Ruby C API Exposure   Rice wraps Ruby's C API (VALUE, rb_* functions) so users rarely interact with it directly.</p>"},{"location":"architecture/overview/#call-flow","title":"Call Flow","text":"<p>The diagram below shows how Rice's components interact when a Ruby method calls into C++:</p> <pre><code>Ruby Code\n    |\n    v\n+------------------+\n|   Ruby VM        |  Calls registered RUBY_METHOD_FUNC\n+--------+---------+\n         |\n         v\n+------------------+\n| Native::resolve  |  Finds matching overload from NativeRegistry\n+--------+---------+\n         |\n         v\n+------------------+\n|   From_Ruby&lt;T&gt;   |  Converts Ruby VALUEs to C++ types\n+--------+---------+\n         |\n         v\n+------------------+\n|   C++ Method     |  Your actual C++ code executes\n+--------+---------+\n         |\n         v\n+------------------+\n|   To_Ruby&lt;T&gt;     |  Converts C++ return value to Ruby VALUE\n+--------+---------+\n         |\n         v\nRuby Code (receives result)\n</code></pre>"},{"location":"architecture/overview/#key-components","title":"Key Components","text":"<p>Rice is organized into several subsystems:</p> <p>Type Binding <code>Data_Type&lt;T&gt;</code> and <code>Wrapper&lt;T&gt;</code> - Binding C++ types to Ruby classes and managing object storage.</p> <p>Method Binding <code>Native</code> hierarchy - Binding C++ functions and methods to Ruby.</p> <p>Overload Resolution   How Rice selects the correct C++ overload based on Ruby arguments using precision-based scoring.</p> <p>Types Overview <code>From_Ruby&lt;T&gt;</code> and <code>To_Ruby&lt;T&gt;</code> - Converting values between languages.</p> <p>Registries   Runtime tracking of types, methods, and instances.</p> <p>Enumerators   Implementing Ruby-style iteration for C++ containers.</p> <p>Procs and Blocks   Bridging Ruby procs/blocks and C++ function pointers.</p> <p>Incomplete Types   Support for forward-declared types (PIMPL idiom, opaque handles).</p>"},{"location":"architecture/overview/#thread-safety","title":"Thread Safety","text":"<p>Rice itself is thread-safe for reading (method invocation). However:</p> <ul> <li>Type registration (<code>define_class</code>, <code>define_method</code>) should happen during extension initialization</li> <li>Ruby's Global VM Lock (GVL) applies to all Ruby-touching code</li> <li>Use <code>NoGVL</code> to release the GVL for long-running C++ operations (see GVL)</li> </ul>"},{"location":"architecture/procs_and_blocks/","title":"Procs and Blocks","text":"<p>Rice provides bidirectional support for Ruby procs/blocks and C++ function pointers. This enables two key use cases:</p> <ol> <li>C++ to Ruby: Wrapping C++ function pointers as Ruby procs</li> <li>Ruby to C++: Passing Ruby blocks/procs to C++ code</li> </ol>"},{"location":"architecture/procs_and_blocks/#c-function-pointers-to-ruby-procs","title":"C++ Function Pointers to Ruby Procs","text":"<p>When a C++ function returns a function pointer, Rice automatically wraps it as a Ruby <code>Proc</code>.</p>"},{"location":"architecture/procs_and_blocks/#example","title":"Example","text":"<pre><code>int square(int i)\n{\n  return i * i;\n}\n\nauto getSquareFunction()\n{\n  return square;  // Returns function pointer\n}\n\n// Expose to Ruby\ndefine_module_function(\"square_proc\", getSquareFunction);\n</code></pre> <p>Ruby code can then call:</p> <pre><code>proc = square_proc\nproc.call(9)  # =&gt; 81\n</code></pre>"},{"location":"architecture/procs_and_blocks/#how-it-works","title":"How It Works","text":"<p>The <code>To_Ruby</code> specialization for function pointers uses <code>NativeProc</code> to create the wrapper:</p> <pre><code>template&lt;typename Return_T, typename ...Parameter_Ts&gt;\nclass To_Ruby&lt;Return_T(*)(Parameter_Ts...)&gt;\n{\n  VALUE convert(Proc_T proc)\n  {\n    return NativeProc&lt;Proc_T&gt;::createRubyProc(proc);\n  }\n};\n</code></pre> <p><code>NativeProc::createRubyProc</code>:</p> <ol> <li>Creates a <code>NativeProc</code> instance storing the C++ function pointer</li> <li>Wraps it in a Ruby proc via <code>rb_proc_new</code></li> <li>Attaches a finalizer to clean up the <code>NativeProc</code> when the Ruby proc is garbage collected</li> </ol> <p>When Ruby invokes the proc, <code>NativeProc::resolve</code> is called which:</p> <ol> <li>Converts Ruby arguments to C++ types</li> <li>Calls the stored function pointer</li> <li>Converts the return value back to Ruby</li> </ol>"},{"location":"architecture/procs_and_blocks/#ruby-blocks-and-procs-to-c","title":"Ruby Blocks and Procs to C++","text":"<p>Rice always converts Ruby blocks to procs. When Ruby passes a block to a method, Rice captures it via <code>rb_block_proc</code> and passes it as the last argument:</p> <pre><code>// In Native.ipp\nif (protect(rb_block_given_p))\n{\n  std::string key = \"arg_\" + std::to_string(result.size());\n  result[key] = protect(rb_block_proc);\n}\n</code></pre> <p>To receive a block in your C++ method, you must:</p> <ol> <li>Include a <code>VALUE</code> parameter at the end of your function signature</li> <li>Mark that parameter with <code>Arg(\"name\").setValue()</code></li> </ol> <p>If you omit <code>setValue()</code>, Rice will attempt to convert the proc using <code>From_Ruby</code>, resulting in an error like \"Proc cannot be converted to Integer\".</p>"},{"location":"architecture/procs_and_blocks/#invoking-procs-in-c","title":"Invoking Procs in C++","text":"<p>Use Rice's <code>Object</code> class to invoke the proc. This works uniformly whether Ruby passed a block or an explicit proc:</p> <pre><code>int squareWithProc(int i, VALUE proc)\n{\n  Object result = Object(proc).call(\"call\", i);\n  return From_Ruby&lt;int&gt;().convert(result);\n}\n\ndefine_module_function(\"square_with_proc\", squareWithProc,\n  Arg(\"i\"), Arg(\"proc\").setValue());\n</code></pre> <p>This can be called from Ruby with a block:</p> <pre><code>square_with_proc(7) { |i| i * i }  # =&gt; 49\n</code></pre> <p>Or with an explicit proc:</p> <pre><code>proc = Proc.new { |i| i * i }\nsquare_with_proc(4, proc)  # =&gt; 16\n</code></pre>"},{"location":"architecture/procs_and_blocks/#callbacks","title":"Callbacks","text":"<p>For more complex callback scenarios where C++ code stores and later invokes Ruby procs (such as event handlers or async callbacks), see the Callbacks documentation. This covers:</p> <ul> <li>C-style callback registration</li> <li>LibFFI closures for multiple callbacks of the same type</li> <li>Passing user data through callbacks</li> </ul>"},{"location":"architecture/procs_and_blocks/#see-also","title":"See Also","text":"<ul> <li>Callbacks - C-style callback support</li> <li>Method Binding - Native hierarchy including NativeProc and NativeCallback</li> </ul>"},{"location":"architecture/registries/","title":"Registries","text":"<p>Rice maintains several registries to track bindings at runtime. These enable type lookup, method resolution, and introspection.</p>"},{"location":"architecture/registries/#registries-singleton","title":"Registries Singleton","text":"<p>All registries are accessed through a singleton:</p> <pre><code>class Registries\n{\npublic:\n  static Registries&amp; instance();\n\n  TypeRegistry&amp; types();\n  NativeRegistry&amp; natives();\n  InstanceRegistry&amp; instances();\n};\n</code></pre>"},{"location":"architecture/registries/#typeregistry","title":"TypeRegistry","text":"<p>Maps C++ types to Ruby classes. The TypeRegistry serves two important purposes:</p>"},{"location":"architecture/registries/#1-polymorphism-support","title":"1. Polymorphism Support","text":"<p>When a C++ method returns a base class pointer that actually points to a derived class, Rice uses RTTI (<code>typeid</code>) to look up the derived type in the registry and wrap it as the correct Ruby class. For example:</p> <pre><code>class Base\n{\n  virtual ~Base() = default;\n};\n\nclass Derived : public Base\n{\n};\n\nBase* create()\n{\n  return new Derived();\n}  // Returns Derived* as Base*\n</code></pre> <p>When <code>create()</code> is called from Ruby, Rice uses <code>typeid(*result)</code> to discover the object is actually a <code>Derived</code>, looks it up in the TypeRegistry, and wraps it as <code>Rb::Derived</code> instead of <code>Rb::Base</code>.</p> <p>Note: This requires RTTI to be enabled.</p>"},{"location":"architecture/registries/#2-unregistered-type-detection","title":"2. Unregistered Type Detection","text":"<p>As Rice processes <code>define_class</code>, <code>define_constructor</code>, <code>define_method</code>, <code>define_attr</code>, etc., it tracks every C++ type it encounters. Types that are used but not yet registered are added to an \"unverified\" list. At the end of extension initialization, Rice can report which types were referenced but never registered with <code>define_class&lt;T&gt;()</code>.</p> <p>This helps developers catch errors early. Without this, an unregistered type would only fail at runtime when Ruby code actually calls a method that uses that type.</p> <pre><code>class TypeRegistry\n{\npublic:\n  // Register a type binding\n  void add(std::type_index type, VALUE klass, rb_data_type_t* rbType);\n\n  // Look up Ruby class for a C++ type\n  std::pair&lt;VALUE, rb_data_type_t*&gt; lookup(std::type_index type);\n\n  // Check if a type is registered\n  bool isDefined(std::type_index type);\n\n  // Verify all encountered types are registered\n  void verify();\n};\n</code></pre> <p>Used when:</p> <ul> <li><code>To_Ruby&lt;T&gt;</code> needs to find the Ruby class to wrap an object</li> <li><code>From_Ruby&lt;T&gt;</code> validates that a Ruby object is the correct type</li> <li>Polymorphic returns need to find the derived class</li> <li>Introspection APIs list all wrapped classes</li> <li>Extension loading verifies all types are registered</li> </ul> <p>Key design:</p> <ul> <li>Uses <code>std::type_index</code> as the key (from <code>typeid(T)</code>)</li> <li>Stores both the Ruby class VALUE and the <code>rb_data_type_t</code> pointer</li> <li>Tracks unverified types for developer feedback</li> <li>Thread-safe for reads after initialization</li> </ul>"},{"location":"architecture/registries/#nativeregistry","title":"NativeRegistry","text":"<p>Stores all wrapped C++ functions, methods, and attributes.</p> <pre><code>class NativeRegistry\n{\npublic:\n  // Register a native for a class/module\n  void add(VALUE klass, std::shared_ptr&lt;Native&gt; native);\n\n  // Get all natives for a method name\n  std::vector&lt;Native*&gt; lookup(VALUE klass, std::string_view name);\n\n  // Get all natives for a class (for introspection)\n  std::vector&lt;Native*&gt; lookup(VALUE klass);\n};\n</code></pre> <p>Used when:</p> <ul> <li><code>Native::resolve()</code> finds overload candidates</li> <li>Introspection APIs enumerate methods for a class</li> </ul> <p>Key design:</p> <ul> <li>Indexed by (klass, method_name) for fast lookup during calls</li> <li>Also indexed by klass alone for introspection</li> <li>Stores <code>shared_ptr&lt;Native&gt;</code> for shared ownership</li> </ul>"},{"location":"architecture/registries/#instanceregistry","title":"InstanceRegistry","text":"<p>Tracks which Ruby objects wrap which C++ instances.</p> <pre><code>class InstanceRegistry\n{\npublic:\n  // Register a Ruby object wrapping a C++ pointer\n  void add(void* ptr, VALUE ruby_object);\n\n  // Find Ruby object for a C++ pointer\n  std::optional&lt;VALUE&gt; lookup(void* ptr);\n\n  // Remove mapping (when Ruby object is collected)\n  void remove(void* ptr);\n};\n</code></pre> <p>Used when:</p> <ul> <li>Returning a C++ object that's already wrapped (avoids double-wrapping)</li> <li>Looking up <code>self</code> for method calls</li> </ul> <p>Key design:</p> <ul> <li>Uses raw <code>void*</code> as key (the C++ object address)</li> <li>Weak references to Ruby objects (doesn't prevent GC)</li> <li>Automatically cleaned up when Ruby objects are collected</li> </ul>"},{"location":"architecture/registries/#moduleregistry","title":"ModuleRegistry","text":"<p>Tracks defined modules for introspection.</p> <pre><code>class ModuleRegistry\n{\npublic:\n  void add(VALUE module);\n  std::vector&lt;VALUE&gt; modules();\n};\n</code></pre> <p>Used when:</p> <ul> <li>Introspection APIs list all defined modules</li> </ul>"},{"location":"architecture/registries/#lifecycle","title":"Lifecycle","text":""},{"location":"architecture/registries/#initialization","title":"Initialization","text":"<p>Registries are populated during extension initialization:</p> <pre><code>extern \"C\" void Init_my_extension()\n{\n  // Each define_class/define_method populates registries\n  define_class&lt;Foo&gt;(\"Foo\")\n    .define_method(\"bar\", &amp;Foo::bar);\n}\n</code></pre> <p>After <code>Init_my_extension</code> returns, registries should be treated as read-only.</p>"},{"location":"architecture/registries/#thread-safety","title":"Thread Safety","text":"<ul> <li>Writes: Only during initialization (single-threaded)</li> <li>Reads: Thread-safe (multiple threads can call methods)</li> </ul> <p>Ruby's GVL ensures that method calls don't race with each other, but registries are also designed for lock-free reads.</p>"},{"location":"architecture/registries/#garbage-collection","title":"Garbage Collection","text":"<p><code>InstanceRegistry</code> interacts with Ruby's GC:</p> <ul> <li>Entries use weak references</li> <li>When Ruby collects a wrapped object, its entry is removed</li> <li>The C++ destructor (via <code>Wrapper</code>) triggers cleanup</li> </ul>"},{"location":"architecture/registries/#introspection-api","title":"Introspection API","text":"<p>The registries power Rice's Ruby introspection API:</p> <pre><code># Access via Rice::Registries singleton\nregistries = Rice::Registries.instance\n\n# List all wrapped classes\nregistries.types.klasses.each { |k| puts k.name }\n\n# Get methods for a class\nregistries.natives.native_methods(MyClass).each do |native|\n  puts native.name\nend\n</code></pre> <p>See Ruby API for the full Ruby API documentation.</p>"},{"location":"architecture/registries/#see-also","title":"See Also","text":"<ul> <li>Registries - Ruby API for Registries</li> <li>TypeRegistry - Ruby API for TypeRegistry</li> <li>NativeRegistry - Ruby API for NativeRegistry</li> </ul>"},{"location":"architecture/smart_pointers/","title":"Smart Pointer Architecture","text":"<p>This document describes how Rice implements smart pointer support and how to add support for custom smart pointer types.</p>"},{"location":"architecture/smart_pointers/#overview","title":"Overview","text":"<p>Rice's smart pointer support involves three key components:</p> <ol> <li>Wrapper specialization - A <code>Wrapper&lt;SmartPtr&lt;T&gt;&gt;</code> class that stores the smart pointer and provides access to both the smart pointer and its managed object</li> <li>Type verification - A <code>Type&lt;SmartPtr&lt;T&gt;&gt;</code> specialization that registers the smart pointer type with Rice</li> <li>Ruby class definition - A function that creates the Ruby class and exposes methods</li> </ol>"},{"location":"architecture/smart_pointers/#wrapper-specialization","title":"Wrapper Specialization","text":"<p>The <code>Wrapper</code> class is responsible for storing C++ objects that are wrapped by Ruby. For smart pointers, you need to specialize <code>Wrapper</code> to handle the dual nature of smart pointers: they are both a container and provide access to a contained object.</p>"},{"location":"architecture/smart_pointers/#declaration","title":"Declaration","text":"<pre><code>namespace Rice::detail\n{\n  template&lt;typename T&gt;\n  class Wrapper&lt;my_smart_ptr&lt;T&gt;&gt; : public WrapperBase\n  {\n  public:\n    Wrapper(rb_data_type_t* rb_data_type, const my_smart_ptr&lt;T&gt;&amp; data);\n    ~Wrapper();\n    void* get(rb_data_type_t* requestedType) override;\n\n  private:\n    my_smart_ptr&lt;T&gt; data_;\n    rb_data_type_t* inner_rb_data_type_;\n  };\n}\n</code></pre> <p>Key points:</p> <ul> <li>Inherit from <code>WrapperBase</code></li> <li>Store the smart pointer in <code>data_</code></li> <li>Store the <code>rb_data_type_t*</code> for the inner type <code>T</code> in <code>inner_rb_data_type_</code></li> </ul>"},{"location":"architecture/smart_pointers/#constructor","title":"Constructor","text":"<p>The constructor must:</p> <ol> <li>Call the <code>WrapperBase</code> constructor with the <code>rb_data_type</code></li> <li>Store the smart pointer</li> <li>Look up the <code>rb_data_type_t*</code> for the inner type</li> </ol> <pre><code>template&lt;typename T&gt;\nWrapper&lt;my_smart_ptr&lt;T&gt;&gt;::Wrapper(rb_data_type_t* rb_data_type, const my_smart_ptr&lt;T&gt;&amp; data)\n  : WrapperBase(rb_data_type), data_(data)\n{\n  using Intrinsic_T = intrinsic_type&lt;T&gt;;\n\n  if constexpr (std::is_fundamental_v&lt;Intrinsic_T&gt;)\n  {\n    inner_rb_data_type_ = Data_Type&lt;Pointer&lt;Intrinsic_T&gt;&gt;::ruby_data_type();\n  }\n  else\n  {\n    inner_rb_data_type_ = Data_Type&lt;Intrinsic_T&gt;::ruby_data_type();\n  }\n}\n</code></pre>"},{"location":"architecture/smart_pointers/#destructor","title":"Destructor","text":"<p>The destructor must remove the instance from Rice's instance registry:</p> <pre><code>template&lt;typename T&gt;\nWrapper&lt;my_smart_ptr&lt;T&gt;&gt;::~Wrapper()\n{\n  Registries::instance.instances.remove(this-&gt;get(this-&gt;rb_data_type_));\n}\n</code></pre>"},{"location":"architecture/smart_pointers/#get-method","title":"get() Method","text":"<p>The <code>get()</code> method is the heart of smart pointer support. It examines the <code>requestedType</code> and returns either:</p> <ul> <li>A pointer to the smart pointer itself (when the caller wants the smart pointer)</li> <li>The raw pointer to the managed object (when the caller wants <code>T*</code>)</li> </ul> <pre><code>template&lt;typename T&gt;\nvoid* Wrapper&lt;my_smart_ptr&lt;T&gt;&gt;::get(rb_data_type_t* requestedType)\n{\n  if (rb_typeddata_inherited_p(this-&gt;rb_data_type_, requestedType))\n  {\n    // Caller wants the smart pointer itself\n    return &amp;this-&gt;data_;\n  }\n  else if (rb_typeddata_inherited_p(this-&gt;inner_rb_data_type_, requestedType))\n  {\n    // Caller wants the managed object\n    return this-&gt;data_.get();\n  }\n  else\n  {\n    throw Exception(rb_eTypeError, \"wrong argument type (expected %s)\",\n        requestedType-&gt;wrap_struct_name);\n  }\n}\n</code></pre> <p>This allows Rice to automatically pass either the smart pointer or the raw pointer to C++ methods based on their signature.</p>"},{"location":"architecture/smart_pointers/#type-specialization","title":"Type Specialization","text":"<p>The <code>Type</code> specialization tells Rice how to verify and register the smart pointer type:</p> <pre><code>namespace Rice::detail\n{\n  template&lt;typename T&gt;\n  struct Type&lt;my_smart_ptr&lt;T&gt;&gt;\n  {\n    static bool verify()\n    {\n      // First verify the inner type.\n      // Note: The is_fundamental check is only needed if your smart pointer\n      // supports fundamental types (int, double, etc.)\n      bool result = true;\n      if constexpr (std::is_fundamental_v&lt;T&gt;)\n      {\n        result = result &amp;&amp; Type&lt;Pointer&lt;T&gt;&gt;::verify();\n      }\n      else\n      {\n        result = result &amp;&amp; Type&lt;T&gt;::verify();\n      }\n\n      // Then register the smart pointer type\n      if (result)\n      {\n        define_my_smart_ptr&lt;T&gt;();\n      }\n\n      return result;\n    }\n  };\n}\n</code></pre>"},{"location":"architecture/smart_pointers/#ruby-class-definition","title":"Ruby Class Definition","text":"<p>Create a function to define the Ruby class with appropriate methods:</p> <pre><code>template&lt;typename T&gt;\nData_Type&lt;my_smart_ptr&lt;T&gt;&gt; define_my_smart_ptr(std::string klassName)\n{\n  using SmartPtr_T = my_smart_ptr&lt;T&gt;;\n  using Data_Type_T = Data_Type&lt;SmartPtr_T&gt;;\n\n  // Generate class name if not provided\n  if (klassName.empty())\n  {\n    detail::TypeMapper&lt;SmartPtr_T&gt; typeMapper;\n    klassName = typeMapper.rubyName();\n  }\n\n  // Check if already defined (use your own module, not Std)\n  Module rb_mModule = define_module(\"YourModule\");\n  if (Data_Type_T::check_defined(klassName, rb_mModule))\n  {\n    return Data_Type_T();\n  }\n\n  // Define the Ruby class with methods appropriate for your smart pointer\n  Identifier id(klassName);\n  Data_Type_T result = define_class_under&lt;detail::intrinsic_type&lt;SmartPtr_T&gt;&gt;(rb_mModule, id).\n    define_method(\"empty?\", &amp;SmartPtr_T::operator bool).\n    define_method(\"get\", &amp;SmartPtr_T::get);\n\n  // Setup method forwarding to the managed type\n  if constexpr (!std::is_void_v&lt;T&gt; &amp;&amp; !std::is_fundamental_v&lt;T&gt;)\n  {\n    detail::define_forwarding(result.klass(), Data_Type&lt;T&gt;::klass());\n  }\n\n  return result;\n}\n</code></pre>"},{"location":"architecture/smart_pointers/#method-and-attribute-forwarding","title":"Method and Attribute Forwarding","text":"<p>Rice uses Ruby's <code>Forwardable</code> module to forward method and attribute calls from the smart pointer wrapper to the managed object. This is implemented in <code>detail::define_forwarding()</code>.</p> <p>To avoid conflicts, methods or attributes that are already defined on the wrapper class are not forwarded. For example, if both the smart pointer wrapper and the managed type define a <code>swap</code> method, only the wrapper's version is directly accessible. To call the managed object's version, use <code>ptr.get.swap</code>.</p> <pre><code>inline void define_forwarding(VALUE wrapper_klass, VALUE wrapped_klass)\n{\n  protect(rb_require, \"forwardable\");\n  Object forwardable = Object(rb_cObject).const_get(\"Forwardable\");\n  Object(wrapper_klass).extend(forwardable.value());\n\n  // Get wrapper class's method and attribute names to avoid conflicts\n  std::set&lt;std::string&gt; wrapperMethodSet;\n  std::vector&lt;std::string&gt; wrapperMethods = Registries::instance.natives.lookup(wrapper_klass, NativeKind::Method);\n  wrapperMethodSet.insert(wrapperMethods.begin(), wrapperMethods.end());\n  std::vector&lt;std::string&gt; wrapperReaders = Registries::instance.natives.lookup(wrapper_klass, NativeKind::AttributeReader);\n  wrapperMethodSet.insert(wrapperReaders.begin(), wrapperReaders.end());\n  std::vector&lt;std::string&gt; wrapperWriters = Registries::instance.natives.lookup(wrapper_klass, NativeKind::AttributeWriter);\n  wrapperMethodSet.insert(wrapperWriters.begin(), wrapperWriters.end());\n\n  // Get wrapped class's method and attribute names, including ancestor classes\n  std::set&lt;std::string&gt; wrappedMethodSet;\n  Class klass(wrapped_klass);\n  while (klass.value() != rb_cObject &amp;&amp; klass.value() != Qnil)\n  {\n    std::vector&lt;std::string&gt; methods = Registries::instance.natives.lookup(klass.value(), NativeKind::Method);\n    wrappedMethodSet.insert(methods.begin(), methods.end());\n\n    std::vector&lt;std::string&gt; readers = Registries::instance.natives.lookup(klass.value(), NativeKind::AttributeReader);\n    wrappedMethodSet.insert(readers.begin(), readers.end());\n\n    std::vector&lt;std::string&gt; writers = Registries::instance.natives.lookup(klass.value(), NativeKind::AttributeWriter);\n    wrappedMethodSet.insert(writers.begin(), writers.end());\n\n    klass = klass.superclass();\n  }\n\n  // Build arguments: [:get, :method1, :method2, ...]\n  // Skip methods already defined on the wrapper class\n  Array args;\n  args.push(Symbol(\"get\"));\n  for (const std::string&amp; method : wrappedMethodSet)\n  {\n    if (wrapperMethodSet.find(method) == wrapperMethodSet.end())\n    {\n      args.push(Symbol(method));\n    }\n  }\n\n  // Call def_delegators\n  Object(wrapper_klass).vcall(\"def_delegators\", args);\n}\n</code></pre>"},{"location":"architecture/smart_pointers/#from_ruby-specialization-optional","title":"From_Ruby Specialization (Optional)","text":"<p>If your smart pointer has special copy/move semantics (like move-only types), you may need a <code>From_Ruby</code> specialization:</p> <pre><code>template &lt;typename T&gt;\nclass From_Ruby&lt;my_smart_ptr&lt;T&gt;&gt;\n{\npublic:\n  From_Ruby() = default;\n\n  explicit From_Ruby(Arg* arg) : arg_(arg)\n  {\n  }\n\n  double is_convertible(VALUE value)\n  {\n    switch (rb_type(value))\n    {\n      case RUBY_T_DATA:\n        return Convertible::Exact;\n      default:\n        return Convertible::None;\n    }\n  }\n\n  my_smart_ptr&lt;T&gt; convert(VALUE value)\n  {\n    my_smart_ptr&lt;T&gt;* result = detail::unwrap&lt;my_smart_ptr&lt;T&gt;&gt;(\n      value,\n      Data_Type&lt;my_smart_ptr&lt;T&gt;&gt;::ruby_data_type(),\n      this-&gt;arg_ &amp;&amp; this-&gt;arg_-&gt;isOwner());\n    return std::move(*result);  // Use std::move for move-only types\n  }\n\nprivate:\n  Arg* arg_ = nullptr;\n};\n</code></pre>"},{"location":"architecture/smart_pointers/#summary","title":"Summary","text":"<p>To add support for a custom smart pointer:</p> <ol> <li>Specialize <code>Wrapper&lt;YourSmartPtr&lt;T&gt;&gt;</code> with a <code>get()</code> method that can return either the smart pointer or the managed object</li> <li>Specialize <code>Type&lt;YourSmartPtr&lt;T&gt;&gt;</code> to verify and register the type</li> <li>Create a <code>define_your_smart_ptr&lt;T&gt;()</code> function to define the Ruby class</li> <li>Optionally specialize <code>From_Ruby</code> if your smart pointer has special copy/move semantics</li> </ol>"},{"location":"architecture/smart_pointers/#complete-code","title":"Complete Code","text":"<p>Here is all the code together for easy copy-paste:</p> <pre><code>namespace Rice::detail\n{\n  // Wrapper specialization\n  template&lt;typename T&gt;\n  class Wrapper&lt;my_smart_ptr&lt;T&gt;&gt; : public WrapperBase\n  {\n  public:\n    Wrapper(rb_data_type_t* rb_data_type, const my_smart_ptr&lt;T&gt;&amp; data)\n      : WrapperBase(rb_data_type), data_(data)\n    {\n      using Intrinsic_T = intrinsic_type&lt;T&gt;;\n\n      // Note: The is_fundamental check is only needed if your smart pointer\n      // supports fundamental types (int, double, etc.)\n      if constexpr (std::is_fundamental_v&lt;Intrinsic_T&gt;)\n      {\n        inner_rb_data_type_ = Data_Type&lt;Pointer&lt;Intrinsic_T&gt;&gt;::ruby_data_type();\n      }\n      else\n      {\n        inner_rb_data_type_ = Data_Type&lt;Intrinsic_T&gt;::ruby_data_type();\n      }\n    }\n\n    ~Wrapper()\n    {\n      Registries::instance.instances.remove(this-&gt;get(this-&gt;rb_data_type_));\n    }\n\n    void* get(rb_data_type_t* requestedType) override\n    {\n      if (rb_typeddata_inherited_p(this-&gt;rb_data_type_, requestedType))\n      {\n        return &amp;this-&gt;data_;\n      }\n      else if (rb_typeddata_inherited_p(this-&gt;inner_rb_data_type_, requestedType))\n      {\n        return this-&gt;data_.get();\n      }\n      else\n      {\n        throw Exception(rb_eTypeError, \"wrong argument type (expected %s)\",\n            requestedType-&gt;wrap_struct_name);\n      }\n    }\n\n  private:\n    my_smart_ptr&lt;T&gt; data_;\n    rb_data_type_t* inner_rb_data_type_;\n  };\n\n  // Type specialization\n  template&lt;typename T&gt;\n  struct Type&lt;my_smart_ptr&lt;T&gt;&gt;\n  {\n    static bool verify()\n    {\n      // Note: The is_fundamental check is only needed if your smart pointer\n      // supports fundamental types (int, double, etc.)\n      bool result = true;\n      if constexpr (std::is_fundamental_v&lt;T&gt;)\n      {\n        result = result &amp;&amp; Type&lt;Pointer&lt;T&gt;&gt;::verify();\n      }\n      else\n      {\n        result = result &amp;&amp; Type&lt;T&gt;::verify();\n      }\n\n      if (result)\n      {\n        define_my_smart_ptr&lt;T&gt;();\n      }\n\n      return result;\n    }\n  };\n}\n\nnamespace Rice\n{\n  // Ruby class definition\n  template&lt;typename T&gt;\n  Data_Type&lt;my_smart_ptr&lt;T&gt;&gt; define_my_smart_ptr(std::string klassName = \"\")\n  {\n    using SmartPtr_T = my_smart_ptr&lt;T&gt;;\n    using Data_Type_T = Data_Type&lt;SmartPtr_T&gt;;\n\n    if (klassName.empty())\n    {\n      detail::TypeMapper&lt;SmartPtr_T&gt; typeMapper;\n      klassName = typeMapper.rubyName();\n    }\n\n    Module rb_mModule = define_module(\"YourModule\");\n    if (Data_Type_T::check_defined(klassName, rb_mModule))\n    {\n      return Data_Type_T();\n    }\n\n    // Define the Ruby class with methods appropriate for your smart pointer\n    Identifier id(klassName);\n    Data_Type_T result = define_class_under&lt;detail::intrinsic_type&lt;SmartPtr_T&gt;&gt;(rb_mModule, id).\n      define_method(\"empty?\", &amp;SmartPtr_T::operator bool).\n      define_method(\"get\", &amp;SmartPtr_T::get);\n\n    if constexpr (!std::is_void_v&lt;T&gt; &amp;&amp; !std::is_fundamental_v&lt;T&gt;)\n    {\n      detail::define_forwarding(result.klass(), Data_Type&lt;T&gt;::klass());\n    }\n\n    return result;\n  }\n}\n</code></pre>"},{"location":"architecture/smart_pointers/#see-also","title":"See Also","text":"<ul> <li>Incomplete Types - Handling forward-declared types, including smart pointers to incomplete types</li> </ul>"},{"location":"architecture/type_binding/","title":"Type Binding","text":"<p>Type binding connects C++ types to Ruby classes. This is handled by two key classes: <code>Data_Type&lt;T&gt;</code> for registration and <code>Wrapper&lt;T&gt;</code> for object storage.</p>"},{"location":"architecture/type_binding/#data_type","title":"Data_Type <p><code>Data_Type&lt;T&gt;</code> is the central class that binds a C++ type to a Ruby class. When you write:</p> <pre><code>define_class&lt;MyClass&gt;(\"MyClass\")\n</code></pre> <p>Rice creates a Ruby class and registers the binding in the <code>TypeRegistry</code>. This mapping persists for the lifetime of the Ruby process.</p> <p>Key responsibilities:</p> <ul> <li>Creates Ruby class with <code>rb_define_class</code></li> <li>Sets up <code>rb_data_type_t</code> for Ruby's garbage collector</li> <li>Provides fluent interface for defining methods, constructors, attributes</li> <li>Tracks inheritance relationships between C++ types</li> </ul>","text":""},{"location":"architecture/type_binding/#class-hierarchy","title":"Class Hierarchy","text":"<p><code>Data_Type&lt;T&gt;</code> inherits from <code>Class</code>, which inherits from <code>Module</code>:</p> <pre><code>Module\n  |\n  +-- Class\n        |\n        +-- Data_Type&lt;T&gt;\n</code></pre> <p>This means <code>Data_Type&lt;T&gt;</code> has access to all module/class methods like <code>define_method</code>, <code>define_singleton_method</code>, <code>include_module</code>, etc.</p>"},{"location":"architecture/type_binding/#one-time-binding","title":"One-Time Binding","text":"<p>Each C++ type can only be bound once. Attempting to bind the same type twice raises an error:</p> <pre><code>define_class&lt;Foo&gt;(\"Foo\");   // OK\ndefine_class&lt;Foo&gt;(\"Bar\");   // Error! Foo already bound\n</code></pre> <p>This is enforced by static class members that track binding state.</p>"},{"location":"architecture/type_binding/#wrapper","title":"Wrapper <p>When a C++ object is returned to Ruby, it must be stored in a way Ruby's garbage collector can manage. <code>Wrapper&lt;T&gt;</code> handles this.</p>","text":""},{"location":"architecture/type_binding/#template-specializations","title":"Template Specializations","text":"<p>Different specializations handle different storage needs:</p> <p>Value types (<code>Wrapper&lt;T&gt;</code>)</p> <pre><code>template &lt;typename T&gt;\nclass Wrapper : public WrapperBase\n{\n  T data_;  // Stores object directly (copy or move)\n};\n</code></pre> <p>Pointer types (<code>Wrapper&lt;T*&gt;</code>)</p> <pre><code>template &lt;typename T&gt;\nclass Wrapper&lt;T*&gt; : public WrapperBase\n{\n  T* data_;      // Stores pointer\n  bool isOwner_; // Tracks ownership for deletion\n};\n</code></pre> <p>Reference types (<code>Wrapper&lt;T&amp;&gt;</code>)</p> <pre><code>template &lt;typename T&gt;\nclass Wrapper&lt;T&amp;&gt; : public WrapperBase\n{\n  T&amp; data_;  // Stores reference (never owns)\n};\n</code></pre>"},{"location":"architecture/type_binding/#ownership","title":"Ownership","text":"<p>The <code>isOwner_</code> flag determines whether the wrapper deletes the C++ object when Ruby garbage collects it:</p> <ul> <li>Owner: Wrapper deletes the object in its destructor</li> <li>Non-owner: Wrapper leaves the object alone</li> </ul> <p>Ownership rules:</p> <ul> <li>Objects created via Ruby constructors are owned</li> <li>Objects returned by value are owned (moved into wrapper)</li> <li>Objects returned by pointer: controlled by <code>Return().takeOwnership()</code></li> <li>Objects returned by reference are never owned</li> </ul>"},{"location":"architecture/type_binding/#ruby-integration","title":"Ruby Integration","text":""},{"location":"architecture/type_binding/#rb_data_type_t","title":"rb_data_type_t","text":"<p>Rice uses Ruby's typed data API (<code>rb_data_type_t</code>) to integrate with the garbage collector:</p> <pre><code>rb_data_type_t rb_data_type = {\n  .wrap_struct_name = \"MyClass\",\n  .function = {\n    .dmark = mark_callback,   // Mark referenced Ruby objects\n    .dfree = free_callback,   // Delete C++ object\n    .dsize = size_callback    // Report memory usage\n  }\n};\n</code></pre> <p>mark callback: Called during GC marking phase. Rice marks any Ruby objects stored in <code>keepAlive_</code> to prevent premature collection.</p> <p>free callback: Called when Ruby collects the object. Deletes the C++ object if the wrapper is the owner.</p> <p>size callback: Reports memory usage for Ruby's memory profiling.</p>"},{"location":"architecture/type_binding/#keep-alive","title":"Keep Alive","text":"<p>Sometimes a C++ object holds references to Ruby objects that must not be collected. The <code>keepAlive_</code> mechanism handles this:</p> <pre><code>class WrapperBase\n{\n  std::vector&lt;VALUE&gt; keepAlive_;  // Ruby objects to mark\n\n  void addKeepAlive(VALUE value);\n  void ruby_mark();  // Marks all keepAlive_ values\n};\n</code></pre> <p>This is used by the <code>Return().keepAlive()</code> feature to prevent Ruby arguments from being collected while the C++ object references them.</p>"},{"location":"architecture/type_binding/#see-also","title":"See Also <ul> <li>Types Overview - How types are converted</li> <li>Memory Management - Ownership when returning objects</li> </ul>","text":""},{"location":"bindings/attributes/","title":"Attributes","text":"<p>C++ structures, and sometimes classes, often have public member variables that store data. Rice makes it easy to wrap these member variables via the use of <code>define_attr</code>:</p> <pre><code>struct MyStruct\n{\n  int readOnly = 0;\n  int writeOnly = 0;\n  int readWrite = 0;\n};\n\nData_Type&lt;MyStruct&gt; rb_cMyStrut =\n  define_class&lt;MyStruct&gt;(\"MyStruct\")\n  .define_constructor(Constructor&lt;MyStruct&gt;())\n  .define_attr(\"read_only\",  &amp;MyStruct::readOnly, Rice::AttrAccess::Read)\n  .define_attr(\"write_only\", &amp;MyStruct::writeOnly, Rice::AttrAccess::Write)\n  .define_attr(\"read_write\", &amp;MyStruct::readWrite);\n}\n</code></pre> <p>Notice the use of <code>Rice::AttrAccess::Read</code> to define read-only attributes and <code>Rice::AttrAccess::Write</code> for write-only attributes. If you do not specify an AttrAccess value then Rice make the attribute readable and writable.</p> <p>These attributes can then be accessed in the expected way in Ruby:</p> <pre><code>my_struct = MyStruct.new\na = my_struct.read_only\nmy_struct.write_only = 5\nmy_struct.read_write = 10\nb = my_struct.read_write\n</code></pre> <p>Similarly, you can wrap static members via the use of <code>define_singleton_attr</code>:</p> <pre><code>struct MyStruct\n{\n  static int readOnly = 0;\n  static int writeOnly = 0;\n  static int readWrite = 0;\n};\n\nData_Type&lt;MyStruct&gt; rb_cMyStrut =\n  define_class&lt;MyStruct&gt;(\"MyStruct\")\n  .define_constructor(Constructor&lt;MyStruct&gt;())\n  .define_singleton_attr(\"read_only\", &amp;MyStruct::readOnly, Rice::AttrAccess::Read)\n  .define_singleton_attr(\"write_only\", &amp;MyStruct::writeOnly, Rice::AttrAccess::Write)\n  .define_singleton_attr(\"read_write\", &amp;MyStruct::readWrite);\n}\n</code></pre> <p>These attributes can then be accessed in the expected way in Ruby:</p> <pre><code>a = MyStruct.read_only\nMyStruct.write_only = 5\nMyStruct.read_write = 10\nb = MyStruct.read_write\n</code></pre>"},{"location":"bindings/buffers/","title":"Buffers","text":"<p>Buffers are often used in C and C++ APIs. Examples include:</p> <ul> <li>Buffers of fundamental types</li> <li>Pointers to arrays of fundamental type or C++ objects</li> <li>Pointer to a fundamental type (often used to support function parameters used to return values)</li> </ul> <p>Rice supports these uses cases via its <code>Buffer&lt;T&gt;</code> Ruby class. For example, a Buffer to an int, <code>Buffer&lt;T&gt;</code>, will be wrapped by a Ruby class named <code>Rice::Buffer\u227aint\u227b</code>.</p> <p>The pointers documentation describes how to create <code>Buffer&lt;T&gt;</code> classes.</p>"},{"location":"bindings/buffers/#fundamental-types","title":"Fundamental Types","text":"<p>It is common for C and C++ APIs to take pointers to blocks of memory consisting of fundamental types like unsigned chars. For example, the OpenCV library includes an API to create a <code>Mat</code> instance like this:</p> <pre><code>Matrix(int rows, int columns, void uint8_t* data)\n</code></pre> <p><code>data</code> is a pointer to a buffer consisting of uint_8 values.</p> <p>To call this API from Ruby, first create a <code>Buffer</code> from a Ruby array like this:</p> <pre><code>data = [1, 2, 3, 4]\nbuffer = Rice::Buffer\u227aunsigned char\u227b.new(data)\nmat = Matrix.new(2, 2, buffer.data)\n</code></pre> <p>It is your responsibility to manage the memory of the buffer. When the <code>buffer</code> variable goes out of scope, Ruby will garbage collect it which will free the underlying buffer. In most cases, the target API will immediately use the buffer so this is not a problem. In cases where a C++ API takes ownership of the buffer then make sure to call <code>release</code> on the buffer.</p> <pre><code>mat = Matrix.new(2, 2, buffer.release)\n</code></pre>"},{"location":"bindings/buffers/#array-of-objects","title":"Array of Objects","text":"<p>C++ APIs can also take a pointer to an array of objects. For example:</p> <pre><code>Matrix Matrix::operator()(const Range* ranges) const\n</code></pre> <p>This code creates a view onto an existing Matrix based on an array of <code>Range</code> objects. The length of the array is equal to the Matrix's number of dimensions.</p> <p>To call this from Ruby:</p> <pre><code>data = [Cv::Range.new(0, 10), Cv::Range(30, 40)]\nbuffer = Rice::Buffer\u227aCv::Range\u227b.new(data)\n\nmatrix = Matrix.new(100, 100)\nmatrix[buffer.data]\n</code></pre>"},{"location":"bindings/buffers/#array-of-pointers","title":"Array of Pointers","text":"<p>The above example also works with an array of pointers. In that case:</p> <pre><code>Matrix Matrix::operator()(const Range** ranges) const\n</code></pre> <p>Notice the <code>ranges</code> parameter is now a <code>**</code> - or an array of pointers. You would call this method from Ruby in the exact same way as the example above.</p>"},{"location":"bindings/buffers/#out-parameters","title":"Out Parameters","text":"<p>C and C++ APIs sometimes return values via function parameters. For example, from OpenCV:</p> <pre><code>void cv::minMaxLoc(cv::InputArray src,\n    double*         minVal,\n    double*         maxVal = 0,\n    Point*          minLoc = 0,\n    Point*          maxLoc = 0,\n    cv::InputArray  mask = cv::noArray())\n</code></pre> <p>All of <code>minVal</code>, <code>maxVal</code>, <code>minLoc</code> and <code>maxLoc</code> are out parameters designed to return values.</p> <p>One way to wrap this code is to return a tuple as explained in out parameters with tuples. An alternative is to use <code>Buffers</code> like this:</p> <pre><code>min_val = Rice::Buffer\u227adouble\u227b.new()\nmax_val = Rice::Buffer\u227adouble\u227b.new()\nmin_loc = Cv::Point.new\nmax_loc = Cv::Point.new\nCV::min_max_loc(min_val.data, max_val.data, min_loc, max_loc)\n\n# Read the min_val\nputs min_val[0]\n</code></pre>"},{"location":"bindings/buffers/#ruby-api","title":"Ruby API","text":"<p>Buffer's have the following Ruby API:</p> <ul> <li>new(value) - Create a new buffer from a Ruby object such as an Array</li> <li>new(value, size) - Create a new buffer from a Ruby object with a specified size</li> <li>size - The size of the buffer in bytes</li> <li>to_s - A user friendly representation of the buffer</li> <li>bytes - A Ruby string with a binary encoding. Buffer#size must be set</li> <li>bytes(count) - A Ruby string with a binary encoding of the specified length</li> <li>to_ary - A Ruby array. Buffer#size must be set</li> <li>to_ary(count) - A Ruby array of the specified length</li> <li><code>[](index)</code> - Get the item at the specified index</li> <li><code>[]=(index)</code> - Update the item at the specified index</li> <li>data - Get a <code>Pointer&lt;T&gt;</code> object to the Buffer's managed memory that can be passed to C++ APIs</li> <li>release - Same as #data but tells the buffer to release ownership of its memory</li> </ul>"},{"location":"bindings/callbacks/","title":"Callbacks","text":"<p>Starting with version 4.5, Rice supports C style callbacks which are pointers to functions. Rice enables Ruby methods, lambdas and procs to serve as callback functions.</p> <p>As an example, OpenCV defines a <code>MouseCallback</code> signature:</p> <pre><code>typedef void (*MouseCallback)(int event, int x, int y, int flags, void* userdata);\n</code></pre> <p>It then provides a function to register a callback:</p> <pre><code>void setMouseCallback(const String&amp; winname, MouseCallback onMouse, void* userdata = 0);\n</code></pre> <p>Once a client registers a callback, it will be called whenever the user performs an action with the mouse.</p> <p>To wrap this code in Rice, first expose the register function to Ruby:</p> <pre><code>// Create a new module\nModule rb_mCv = define_module(\"Cv\");\n\n// Expose the register method\nrb_mCv.define_module_function(\"set_mouse_callback\", &amp;cv::setMouseCallback,\n  Arg(\"winname\"), Arg(\"on_mouse\"), Arg(\"userdata\") = static_cast&lt;void *&gt;(0));\n</code></pre> <p>Next, in Ruby, define a Proc to handle the callback and then call the register function:</p> <pre><code># Create a Proc to handle the event\non_mouse_event = Proc.new do |event, x, y, flags, user_data|\n  if event == Cv::MouseEventTypes::EVENT_LBUTTONDOWN.to_i\n    # Do Stuff\n  end\nend\n\n# Register the proc\nCv::set_mouse_callback(\"Starry\", on_mouse_event)\n</code></pre> <p>You can also use Ruby <code>blocks</code> and <code>lambdas</code> in addition to <code>Procs</code></p>"},{"location":"bindings/callbacks/#user-data","title":"User Data","text":"<p>Notice that the <code>MouseCallback</code> callback defines a parameter called <code>userdata</code> which has a type of <code>void*</code>. This is a common pattern in C style callbacks and allows clients to pass information into the callback - it's a way of handling state.</p> <p>Rice enables Ruby code to pass Ruby objects from the client to the callback. To do this, you must tell Rice that it should not try to convert the Ruby object to C++ or from C++ to Ruby. This is done by using the <code>setOpaque</code> method:</p> <pre><code>Module rb_mCv = define_module(\"Cv\");\nrb_mCv.define_module_function(\"set_mouse_callback\", &amp;cv::setMouseCallback,\n  Arg(\"winname\"), Arg(\"on_mouse\"), Arg(\"userdata\").setOpaque() = static_cast&lt;void *&gt;(0));\n</code></pre> <p>Notice the addition of <code>Arg(\"userdata\").setOpaque()</code>. Ruby code can now call the register function like this:</p> <pre><code>Cv::set_mouse_callback(\"Starry\", on_mouse_event, self)\n</code></pre> <p>This allows the current Ruby object, <code>self</code>, to pass a reference to itself to the callback method.</p> <p>However, this only solves 1/2 the problem - passing a Ruby object unchanged to C++. When C++ later invokes the callback, Rice will try to translate it from C++ to Ruby. Of course, that does not make sense for the self reference, so we need to tell Rice not to do it. This is done by using the <code>define_callback</code> function.</p> <pre><code>define_callback&lt;cv::MouseCallback&gt;(Arg(\"event\"), Arg(\"x\"), Arg(\"y\"), Arg(\"flags\"), Arg(\"user_data\").setOpaque());\n</code></pre> <p>Notice the fifth argument, which is specified as <code>Arg(\"user_data\").setOpaque()</code>. This tells Rice to not covert the parameter from C++ to Ruby.</p> <p>Finally, let's update the Ruby proc:</p> <pre><code>on_mouse_event = Proc.new do |event, x, y, flags, self|\n  self.mouse_event_count+=1\nend\n</code></pre>"},{"location":"bindings/callbacks/#associating-callbacks-with-procs","title":"Associating Callbacks with Procs","text":"<p>Remember that C style callbacks are simply function pointers, they do not have a place to store any state. Thus when a C style callback is invoked, Rice needs to determine what Ruby <code>Proc</code> to call. This is a tricky problem to solve.</p>"},{"location":"bindings/callbacks/#simple-callback","title":"Simple Callback","text":"<p>In the simplest case, a callback is only used once in a code base. Thus there is a one-to-one mapping between a callback and its associated Ruby <code>Proc</code>.</p> <p>This is easy to implement - Rice generates a new C++ class based on the callback's signature using the NativeCallbackSimple class template. The generated class has a static member field that stores the <code>Proc</code>. Thus every callback is associated with a single instantiation of the <code>NativeCallbackSimple</code> template.</p>"},{"location":"bindings/callbacks/#libffi-callback","title":"LibFFI Callback","text":"<p>However, a library often times use a callback in multiple places. For example:</p> <pre><code>void setMouseClickCallback(MouseCallback_T onSingleClick, MouseCallback_T onDoubleClick);\nvoid setMouseEnterExitCallback(MouseCallback_T onEnterExit);\n</code></pre> <p>The above code uses the same callback type 3 different times, thus the one-to-one mapping between callback type and C++ class is broken. Therefore the simple solution of using a static member variable to store the Ruby proc no longer works. Instead, we need to store 3 different <code>Procs</code> and figure out which one to call when the callback is invoked.</p> <p>In this case, Rice can use libffi's closure API. The closure API associates a piece of user data, in this case the <code>Proc</code>, with a callback and then dynamically generates a new function which is what is invoked by the callback function.</p> <p>Since you are working with Ruby, it is highly likely that LibFFI is already installed since the Fiddle gem requires it.</p> <p>However, you must opt into using libffi. To do this update your <code>extconf.rb</code> file like this:</p> <pre><code>abort \"libffi not found\" unless have_libffi\n</code></pre> <p>If you are using CMake, you will need to add a C++ preprocessor define called <code>HAVE_LIBFFI</code> and link to libffi.</p>"},{"location":"bindings/callbacks/#memory-management","title":"Memory Management","text":"<p>Callback wrappers (NativeCallback instances) are intentionally never freed. This is because:</p> <ol> <li>C code may call the callback at any time, even after the Ruby code that registered it has finished executing</li> <li>Ruby users commonly pass blocks to C callbacks, which Rice converts to Procs internally. Without special handling, these Procs would be garbage collected and the callback would crash when invoked</li> </ol> <p>Rice uses <code>Pin</code> internally to prevent the Ruby Proc from being garbage collected, ensuring the callback remains valid for the lifetime of the program.</p> <p>In practice, this means each unique callback registration consumes a small amount of memory that is never reclaimed. For most applications this is not a concern, as callbacks are typically registered once during initialization.</p>"},{"location":"bindings/class_templates/","title":"Class Templates","text":"<p>Some C++ libraries make heavy use of class templates. A class template is not a type, nor an object, but instead is blueprint used to create classes. Examples include STL containers such as <code>std::vector</code> or <code>std::map</code>. In addition, many libraries define their own custom class templates.</p> <p>Since class templates are not types and cannot be instantiated, they cannot be wrapped by Rice. Instead class templates must be turned into classes so that they can be wrapped. For example, <code>std::vector&lt;int&gt;</code> is a class type that Rice can wrap.</p>"},{"location":"bindings/class_templates/#wrapping-class-templates","title":"Wrapping Class Templates","text":"<p>Redefining the same methods over and over for every class that a class template generates would be tedious.</p> <p>Lets look at an example, the Mat_ class template from OpenCV:</p> <pre><code>template&lt;typename _Tp&gt;\nclass Mat_ : public Mat\n{\npublic:\n    Mat_();\n    Mat_(int _rows, int _cols);\n\n    template &lt;std::size_t _Nm&gt;\n    explicit Mat_(const std::array&lt;_Tp, _Nm&gt;&amp; arr, bool copyData=false);\n\n    iterator begin();\n    iterator end();\n\n    _Tp&amp; operator ()(int row, int col);\n};\n</code></pre> <p>After defining the class template, OpenCV then defines a number of concrete classes. The list below is just a subset of them:</p> <pre><code>typedef Mat_&lt;uchar&gt; Mat1b;\ntypedef Mat_&lt;Vec2b&gt; Mat2b;\ntypedef Mat_&lt;Vec3b&gt; Mat3b;\ntypedef Mat_&lt;Vec4b&gt; Mat4b;\n\ntypedef Mat_&lt;int&gt;   Mat1i;\ntypedef Mat_&lt;Vec2i&gt; Mat2i;\ntypedef Mat_&lt;Vec3i&gt; Mat3i;\ntypedef Mat_&lt;Vec4i&gt; Mat4i;\n\n...\n</code></pre> <p>A naive approach to wrapping these classes is to define each one separately. Don't do that!</p> <p>Instead, write a function template that creates and returns the wrapper:</p> <pre><code>template&lt;typename _Tp&gt;\ninline Data_Type&lt;cv::Mat_&lt;_Tp&gt;&gt; Mat__instantiate(VALUE module, const char* name)\n{\n  return define_class_under&lt;cv::Mat_&lt;_Tp&gt;, cv::Mat&gt;(module, name)\n    .define_constructor(Constructor&lt;cv::Mat_::Mat_&lt;_Tp&gt;&gt;())\n    .define_constructor(Constructor&lt;cv::Mat_::Mat_&lt;_Tp&gt;, int, int&gt;(), Arg(\"_rows\"), Arg(\"_cols\"))\n\n    .template define_iterator&lt;typename cv::Mat_&lt;_Tp&gt;::iterator(cv::Mat_&lt;_Tp&gt;::*)()&gt;(&amp;cv::Mat_&lt;_Tp&gt;::begin, &amp;cv::Mat_&lt;_Tp&gt;::end, \"each\")\n    .template define_method&lt;_Tp&amp;(cv::Mat_&lt;_Tp&gt;::*)(int, int)&gt;(\"[]\", &amp;cv::Mat_&lt;_Tp&gt;::operator(), Arg(\"row\"), Arg(\"col\"))\n\n    .define_method(\"[]=\", [](cv::Mat_&lt;_Tp&gt;&amp; self, int row, int column, _Tp&amp; value)\n    {\n      self(row, column) = value;\n    });\n}\n</code></pre> <p>Then call this function to instantiate each concrete class:</p> <pre><code>VALUE rb_cMat1b = Mat__instantiate&lt;unsigned char&gt;(rb_mCv, \"Mat1b\");\n\nVALUE rb_cMat2b = Mat__instantiate&lt;cv::Vec&lt;unsigned char, 2&gt;&gt;(rb_mCv, \"Mat2b\");\n\n...\n</code></pre> <p>There are few things to notice about the above code.</p> <p>First, by convention, the function is named <code>\"#{template_name}_instantiate\"</code>. So in this case <code>Mat__instantiate</code>. You may of course name the function anything you want.</p> <p>Second, the <code>template</code> keyword needs to be used in front of methods:</p> <pre><code>.template define_iterator&lt;typename cv::Mat_&lt;_Tp&gt;::iterator(cv::Mat_&lt;_Tp&gt;::*)()&gt;(&amp;cv::Mat_&lt;_Tp&gt;::begin, &amp;cv::Mat_&lt;_Tp&gt;::end, \"each\")\n\n.template define_method&lt;_Tp&amp;(cv::Mat_&lt;_Tp&gt;::*)(int, int)&gt;(\"[]\", &amp;cv::Mat_&lt;_Tp&gt;::operator(), Arg(\"row\"), Arg(\"col\"))\n</code></pre> <p>Third, the array constructor cannot be wrapped because it uses a template parameter that is not defined:</p> <pre><code>template &lt;std::size_t _Nm&gt;\nexplicit Mat_(const std::array&lt;_Tp, _Nm&gt;&amp; arr, bool copyData=false);\n</code></pre> <p>Fourth, the <code>operator()</code> is mapped to two Ruby methods, <code>[]</code> and <code>[]=</code>.</p> <pre><code>.template define_method&lt;_Tp&amp;(cv::Mat_&lt;_Tp&gt;::*)(int, int)&gt;(\"[]\", &amp;cv::Mat_&lt;_Tp&gt;::operator(), Arg(\"row\"), Arg(\"col\"))\n\n.define_method(\"[]=\", [](cv::Mat_&lt;_Tp&gt;&amp; self, int row, int column, _Tp&amp; value)\n{\n  self(row, column) = value;\n});\n</code></pre> <p>Once you have created an instantiation function it is easy to create new C++ classes from class templates and wrap them in Ruby.</p>"},{"location":"bindings/classes/","title":"Classes","text":"<p>Rice provides two ways to define Ruby classes: creating new Ruby-only classes and wrapping existing C++ classes.</p>"},{"location":"bindings/classes/#ruby-only-classes","title":"Ruby-Only Classes","text":"<p>To create a Ruby class without wrapping a C++ type, use the non-template version of <code>define_class</code>:</p> <pre><code>#include &lt;rice/rice.hpp&gt;\n\nusing namespace Rice;\n\nextern \"C\"\nvoid Init_test()\n{\n  Class rb_cTest = define_class(\"Test\");\n}\n</code></pre> <p>This creates a Ruby class called <code>Test</code> that inherits from <code>Object</code>. You can then add methods using <code>define_method</code> with function pointers or lambdas.</p>"},{"location":"bindings/classes/#wrapping-c-classes","title":"Wrapping C++ Classes","text":"<p>To wrap an existing C++ class, use the template version of <code>define_class&lt;T&gt;()</code>:</p> <pre><code>class MyClass\n{\npublic:\n  MyClass();\n  void do_something();\n};\n\nextern \"C\"\nvoid Init_test()\n{\n  Data_Type&lt;MyClass&gt; rb_cMyClass =\n    define_class&lt;MyClass&gt;(\"MyClass\")\n    .define_constructor(Constructor&lt;MyClass&gt;())\n    .define_method(\"do_something\", &amp;MyClass::do_something);\n}\n</code></pre> <p>The template parameter specifies the C++ type being wrapped. This creates a binding between the Ruby class and the C++ class, allowing Rice to automatically manage object lifetimes and method dispatch.</p>"},{"location":"bindings/classes/#data_type-vs-class","title":"Data_Type vs Class","text":"<p>When wrapping C++ types, <code>define_class&lt;T&gt;()</code> returns a <code>Data_Type&lt;T&gt;</code> instead of a <code>Class</code>. The <code>Data_Type&lt;T&gt;</code> class provides the same interface as <code>Class</code> but includes additional type information that Rice uses for type conversions and safety checks.</p>"},{"location":"bindings/classes/#defining-classes-under-modules","title":"Defining Classes Under Modules","text":"<p>To define a class within a module namespace, use <code>define_class_under</code>:</p> <pre><code>Module rb_mMyModule = define_module(\"MyModule\");\n\nData_Type&lt;MyClass&gt; rb_cMyClass =\n  define_class_under&lt;MyClass&gt;(rb_mMyModule, \"MyClass\");\n</code></pre> <p>This creates <code>MyModule::MyClass</code> in Ruby. You can nest classes arbitrarily deep:</p> <pre><code>Module rb_mOuter = define_module(\"Outer\");\nModule rb_mInner = define_module_under(rb_mOuter, \"Inner\");\n\nData_Type&lt;MyClass&gt; rb_cMyClass =\n  define_class_under&lt;MyClass&gt;(rb_mInner, \"MyClass\");\n</code></pre> <p>This creates <code>Outer::Inner::MyClass</code>.</p>"},{"location":"bindings/classes/#inheritance","title":"Inheritance","text":""},{"location":"bindings/classes/#inheriting-from-ruby-classes","title":"Inheriting from Ruby Classes","text":"<p>For Ruby-only classes, specify a parent class as the second parameter:</p> <pre><code>Class rb_cMySocket = define_class(\"MySocket\", rb_cIO);\n</code></pre>"},{"location":"bindings/classes/#inheriting-from-c-classes","title":"Inheriting from C++ Classes","text":"<p>When wrapping C++ class hierarchies, specify the parent C++ type as a second template parameter:</p> <pre><code>class Base\n{\npublic:\n  virtual void base_method();\n};\n\nclass Derived : public Base\n{\npublic:\n  void derived_method();\n};\n\nextern \"C\"\nvoid Init_test()\n{\n  Data_Type&lt;Base&gt; rb_cBase =\n    define_class&lt;Base&gt;(\"Base\")\n    .define_constructor(Constructor&lt;Base&gt;())\n    .define_method(\"base_method\", &amp;Base::base_method);\n\n  Data_Type&lt;Derived&gt; rb_cDerived =\n    define_class&lt;Derived, Base&gt;(\"Derived\")\n    .define_constructor(Constructor&lt;Derived&gt;())\n    .define_method(\"derived_method\", &amp;Derived::derived_method);\n}\n</code></pre> <p>The second template parameter tells Rice about the inheritance relationship, enabling proper type conversions and polymorphic behavior.</p> <p>Note: Rice requires RTTI to be enabled for polymorphism to work correctly. When a C++ method returns a <code>Base*</code> that actually points to a <code>Derived</code> object, Rice uses RTTI to wrap it as the correct Ruby class. See RTTI for details.</p> <p>If you want to create Ruby classes that inherit from wrapped C++ classes and override virtual methods, see the Directors section.</p>"},{"location":"bindings/classes/#method-chaining","title":"Method Chaining","text":"<p>Most methods on <code>Class</code> and <code>Data_Type</code> return a reference to self, allowing you to chain method calls:</p> <pre><code>Data_Type&lt;MyClass&gt; rb_cMyClass =\n  define_class&lt;MyClass&gt;(\"MyClass\")\n  .define_constructor(Constructor&lt;MyClass&gt;())\n  .define_method(\"method1\", &amp;MyClass::method1)\n  .define_method(\"method2\", &amp;MyClass::method2)\n  .define_attr(\"value\", &amp;MyClass::value)\n  .define_singleton_function(\"create\", &amp;MyClass::create);\n</code></pre>"},{"location":"bindings/classes/#naming-conventions","title":"Naming Conventions","text":"<p>When naming your C++ variables that hold Ruby classes, follow Ruby's conventions:</p> Prefix Type Example <code>rb_c</code> Class <code>rb_cMyClass</code> <code>rb_m</code> Module <code>rb_mMyModule</code> <code>rb_e</code> Exception <code>rb_eMyError</code>"},{"location":"bindings/classes/#complete-example","title":"Complete Example","text":"<p>Here's a complete example showing various class definition features:</p> <pre><code>#include &lt;rice/rice.hpp&gt;\n#include &lt;rice/stl.hpp&gt;\n\nusing namespace Rice;\n\nclass Shape\n{\npublic:\n  virtual ~Shape() = default;\n  virtual double area() const = 0;\n};\n\nclass Rectangle : public Shape\n{\npublic:\n  Rectangle(double width, double height)\n    : width_(width), height_(height) {}\n\n  double area() const override { return width_ * height_; }\n\n  double width() const { return width_; }\n  double height() const { return height_; }\n\nprivate:\n  double width_;\n  double height_;\n};\n\nextern \"C\"\nvoid Init_shapes()\n{\n  Module rb_mGeometry = define_module(\"Geometry\");\n\n  Data_Type&lt;Shape&gt; rb_cShape =\n    define_class_under&lt;Shape&gt;(rb_mGeometry, \"Shape\")\n    .define_method(\"area\", &amp;Shape::area);\n\n  Data_Type&lt;Rectangle&gt; rb_cRectangle =\n    define_class_under&lt;Rectangle, Shape&gt;(rb_mGeometry, \"Rectangle\")\n    .define_constructor(Constructor&lt;Rectangle, double, double&gt;())\n    .define_method(\"width\", &amp;Rectangle::width)\n    .define_method(\"height\", &amp;Rectangle::height);\n}\n</code></pre> <p>Usage in Ruby:</p> <pre><code>rect = Geometry::Rectangle.new(3.0, 4.0)\nputs rect.area    # =&gt; 12.0\nputs rect.width   # =&gt; 3.0\nputs rect.height  # =&gt; 4.0\n</code></pre>"},{"location":"bindings/constants/","title":"Constants","text":"<p>C++ allows constants to be defined globally, on namespaces and classes/structs.</p> <pre><code>constexpr int CONSTANT_1 = 1;\n\nnamespace SomeNamespace\n{\n  constexpr int CONSTANT_2 = 2;\n}\n\nclass MyClass\n{\n  static constexpr int CONSTANT_3 = 3;\n}\n</code></pre> <p>These constants can be wrapped like this:</p> <pre><code>Object(rb_cObject).define_constant(\"CONSTANT_1\", CONSTANT_1);\n\nModule rb_mSomeNamespace = define_module(\"SomeNamespace\");\nrb_mSomeNamespace.define_constant(\"CONSTANT_2\", CONSTANT_2);\n\nData_Type&lt;MyClass&gt; rb_cMyClass = define_class&lt;MyClass&gt;(\"MyClass\").\n  define_constant(\"CONSTANT_3\", CONSTANT_3);\n</code></pre>"},{"location":"bindings/constants/#enums-as-constants","title":"Enums as Constants","text":"<p>Older C++ code sometimes uses anonymous C style enums as a hack for defining class constants. For more information see Nested and Anonymous Enums.</p>"},{"location":"bindings/constructors/","title":"Constructors","text":"<p>In the tutorial we touched upon how to wrap C++ constructors. Now let's go into more depth.</p> <p>Unlike Ruby, C++ supports several types of constructors, including:</p> <ul> <li>Default constructors</li> <li>Custom constructors</li> <li>Copy constructors</li> <li>Move constructors</li> </ul> <p>In addition, a C++ class may have multiple constructors.</p>"},{"location":"bindings/constructors/#default-constructor","title":"Default Constructor","text":"<p>Most C++ classes include a default constructor that takes no arguments. These are mapped to Rice like this:</p> <pre><code>define_constructor(Constructor&lt;Mat&gt;())\n</code></pre> <p>This defines a constructor that takes no arguments. It can be invoked from Ruby using the following code:</p> <pre><code>Mat.new\n</code></pre> <p>Under the hood, the <code>define_constructor</code> call creates a new <code>initialize</code> method on the Ruby <code>Mat</code> class. The <code>initialize</code> method is responsible for creating a new C++ <code>Mat</code> instance and associating it with the wrapper Ruby object. Thus if you override the <code>initialize</code> method you MUST call <code>super</code>:</p> <pre><code>class Mat\n  def initialize\n    super  # &lt;--- You MUST call super first\n    ...your code..\n  end\nend\n</code></pre>"},{"location":"bindings/constructors/#custom-constructors","title":"Custom Constructors","text":"<p>The <code>Mat</code> class defines two custom constructors:</p> <pre><code>define_constructor(Constructor&lt;Mat, int, int, int&gt;())\ndefine_constructor(Constructor&lt;Mat, const std::vector&lt;int&gt;&amp;, int&gt;())\n</code></pre> <p>These are invoked from Ruby like this:</p> <pre><code>Mat.new(1, 2, 3)\n\nvec = Std::Vector&lt;int&gt;.new\nMat.new(vec, 4)\n</code></pre> <p>Similarly to default constructors, calling <code>define_constructor</code> will creates a new <code>initialize</code> method on the corresponding Ruby class.</p>"},{"location":"bindings/constructors/#copy-constructors","title":"Copy Constructors","text":"<p>Most C++ classes include a copy constructor that takes one argument. These are mapped to Rice like this:</p> <pre><code>define_constructor(Constructor&lt;const Mat&amp;&gt;())\n</code></pre> <p>Rice maps copy constructors to Ruby's <code>clone</code> and <code>dup</code> methods:</p> <pre><code>mat1 = Mat.new(1, 2, 3)\nmat2 = mat1.dup\nmat3 = mat1.clone\n</code></pre> <p>Under the hood, the <code>define_constructor</code> call creates a new <code>initialize_copy</code> method on the Ruby Mat class. The <code>initialize_copy</code> method is responsible for calling the C++ copy constructor and assigning the new C++ instance to the wrapper Ruby object. Thus if you override the <code>initialize_copy</code> method you MUST call <code>super</code>:</p> <pre><code>class Mat\n  def initialize_copy\n    super  # &lt;--- You MUST call super first\n    ...your code..\n  end\nend\n</code></pre>"},{"location":"bindings/constructors/#move-constructors","title":"Move Constructors","text":"<p>Rice does not support move constructors because there is no clean mapping of them to Ruby.</p>"},{"location":"bindings/constructors/#multiple-constructors","title":"Multiple Constructors","text":"<p>As seen in the examples above, a C++ clas can have multiple constructors. For example, consider this simplified version of OpenCV's Mat class:</p> <pre><code>class Mat\n{\npublic:\n    Mat();\n    Mat(int rows, int cols, int type);\n    Mat(const std::vector&lt;int&gt;&amp; sizes, int type);\n    Mat(const Mat&amp; m);\n    Mat(Mat&amp;&amp; m);\n}\n</code></pre> <p>The Rice binding for the above example is:</p> <pre><code>#include &lt;rice/rice.hpp&gt;\n#include &lt;rice/stl.hpp&gt;\n\nusing namespace Rice;\n\nextern \"C\"\nvoid Init_Mat()\n{\n  Data_Type&lt;Test&gt; rb_cMat = define_class&lt;Mat&gt;(\"Mat\")\n    .define_constructor(Constructor&lt;Mat&gt;())\n    .define_constructor(Constructor&lt;Mat, int, int, int&gt;())\n    .define_constructor(Constructor&lt;Mat, const std::vector&lt;int&gt;&amp;, int&gt;())\n    .define_constructor(Constructor&lt;const Mat&amp;&gt;())\n    .define_constructor(Constructor&lt;Mat&amp;&amp;&gt;());\n}\n</code></pre> <p>Notice that the Constructor template requires the full list of argument types needed by the constructor.</p> <p>For more information on how Rice decides which constructor to call, please see the overloaded methods section.</p>"},{"location":"bindings/directors/","title":"Directors","text":"<p>Inheritance becomes much more complex if you want to create Ruby classes that inherit from wrapped C++ classes. This introduces several problems:</p> <ul> <li>Ruby classes should be able to override C++ virtual methods</li> <li>Overridden virtual methods should be able to call <code>super</code> and invoke the overridden C++ method</li> <li>C++ code calling the virtual methods should invoke the overridden version in Ruby</li> </ul> <p>Rice supports these use cases through the use of <code>Director</code> classes. <code>Directors</code> are proxies that correctly dispatch method invocations up or down a Class hierarchy.</p> <p>Note</p> <p>The name Director comes from SWIG - for more information see https://www.swig.org/Doc4.0/SWIGPlus.html#SWIGPlus_director_classes_introduction.</p> <p>Take the following class:</p> <pre><code>class VirtualBase\n{\n  public:\n    VirtualBase();\n    virtual int doWork();\n    virtual int processWorker() = 0;\n};\n</code></pre> <p>Due to the abstract nature of this class, we cannot directly wrap it in Rice, as any C++ compiler will complain about trying to instantiate a virtual class. Even without the pure virtual function, any call to <code>VirtualBase::doWork</code> will stop at the C++ level and execution will not pass down into any Ruby subclasses.</p> <p>To properly wrap both of these methods, use a <code>Rice::Director</code> subclass as a proxy and use this new proxy class as the type to wrap with <code>define_class</code>:</p> <pre><code>#include &lt;rice/rice.hpp&gt;\n\nclass VirtualBaseProxy : public VirtualBase, public Rice::Director\n{\n  public:\n    VirtualBaseProxy(Object self) : Rice::Director(self)\n    { }\n\n    int doWork() override\n    {\n      int result = getSelf().call(\"do_work\");\n      return detail::From_Ruby&lt;int&gt;().convert(result);\n    }\n\n    int default_doWork()\n    {\n      return VirtualBase::doWork();\n    }\n\n    int processWorker() override\n    {\n      int result = getSelf().call(\"process_worker\");\n      return detail::From_Ruby&lt;int&gt;().convert(result);\n    }\n\n    int default_processWorker()\n    {\n      raisePureVirtual();\n    }\n};\n</code></pre> <p>There is a lot going on here, so we'll go through each part.</p> <pre><code>class VirtualBaseProxy : public Virtualbase, public Rice::Director { }\n</code></pre> <p>First, the class needs to subclass both the virtual class in question and <code>Rice::Director</code>.</p> <pre><code>  public:\n    VirtualBaseProxy(Object self) : Rice::Director(self) { }\n</code></pre> <p>For <code>Rice::Director</code> to work its magic, every instance of this class needs to have a handle to its Ruby instance. The constructor must take a <code>Rice::Object</code> as the first argument and pass it to <code>Rice::Director</code>.</p> <p>Next we implement <code>doWork</code>. The director class overrides it by forwarding the invocation to the Ruby instance.</p> <pre><code>    int doWork() override\n    {\n      int result = getSelf().call(\"do_work\");\n      return detail::From_Ruby&lt;int&gt;().convert(result);\n    }\n\n    int default_doWork()\n    {\n      return VirtualBase::doWork();\n    }\n</code></pre> <p>The director also implements <code>default_doWork</code> which enables Ruby to call the overridden virtual C++ method. The <code>default_</code> prefix is a naming convention to help keep straight which methods perform which functions.</p> <p>If Ruby should never call the C++ method then the <code>default_</code> implementation should call <code>raisePureVirtual()</code>:</p> <pre><code>int default_processWorker()\n{\n  raisePureVirtual();\n}\n</code></pre> <p>The method <code>raisePureVirtual()</code> exists to allow wrapping a pure virtual method into Ruby (and ensuring compilation is possible) while also making sure any users of this extension get an exception if they try to call an unimplemented C++ method.</p> <p>After defining the Director class is C++ it's time to wrap it for use in Ruby:</p> <pre><code>extern \"C\"\nvoid Init_virtual() {\n  define_class&lt;VirtualBase&gt;(\"VirtualBase\")\n    .define_director&lt;VirtualBaseProxy&gt;()\n    .define_constructor(Constructor&lt;VirtualBaseProxy, Rice::Object&gt;())\n    .define_method(\"do_work\", &amp;VirtualBaseProxy::default_doWork)\n    .define_method(\"process_worker\", &amp;VirtualBaseProxy::default_processWorker);\n}\n</code></pre> <p>There are a couple of new things in this code.</p> <p>First, note the addition of the <code>define_director</code> call which takes the <code>VirtualBaseProxy</code> as a template parameter.</p> <p>Second, the <code>Constructor</code> template parameter must include the <code>VirtualBaseProxy</code> class to allow proper object construction and destruction of the derived objects.</p> <p>Third, the <code>define_method</code> calls should point to the <code>default_*</code> implementations.</p>"},{"location":"bindings/directors/#ruby-usage","title":"Ruby Usage","text":"<p>Once the Director class is wrapped, Ruby classes can inherit from it and override virtual methods.</p>"},{"location":"bindings/directors/#basic-subclassing","title":"Basic Subclassing","text":"<p>Create a Ruby class that inherits from the wrapped C++ class and implements the pure virtual method:</p> <pre><code>class MyWorker &lt; VirtualBase\n  def process_worker\n    42\n  end\nend\n\nworker = MyWorker.new\nworker.process_worker  # =&gt; 42\n</code></pre>"},{"location":"bindings/directors/#overriding-virtual-methods-with-super","title":"Overriding Virtual Methods with Super","text":"<p>Ruby subclasses can override virtual methods and call <code>super</code> to invoke the original C++ implementation:</p> <pre><code>class MyWorker &lt; VirtualBase\n  def do_work\n    super * 2  # Calls C++ VirtualBase::doWork(), then doubles the result\n  end\nend\n\nworker = MyWorker.new\nworker.do_work  # =&gt; C++ result * 2\n</code></pre>"},{"location":"bindings/directors/#pure-virtual-methods","title":"Pure Virtual Methods","text":"<p>If a Ruby subclass calls <code>super</code> on a pure virtual method, Rice raises a <code>NotImplementedError</code>:</p> <pre><code>class MyWorker &lt; VirtualBase\n  def process_worker\n    super  # Raises NotImplementedError\n  end\nend\n</code></pre>"},{"location":"bindings/directors/#polymorphism-from-c","title":"Polymorphism from C++","text":"<p>The real power of Directors is that C++ code calling virtual methods will correctly invoke the Ruby implementations. For example, if you have a C++ class that processes workers:</p> <pre><code>class Handler\n{\n  std::vector&lt;Worker*&gt; workers;\n\npublic:\n  void addWorker(Worker* worker) { workers.push_back(worker); }\n\n  int processWorkers(int start)\n  {\n    int result = start;\n    for (auto* worker : workers)\n    {\n      result = worker-&gt;process(result);  // Calls Ruby override!\n    }\n    return result;\n  }\n};\n</code></pre> <p>Ruby subclasses passed to C++ will have their overridden methods called:</p> <pre><code>class Doubler &lt; Worker\n  def process(num)\n    num * 2\n  end\nend\n\nclass Adder &lt; Worker\n  def process(num)\n    num + 10\n  end\nend\n\nhandler = Handler.new\nhandler.add_worker(Doubler.new)\nhandler.add_worker(Adder.new)\nhandler.process_workers(5)  # =&gt; (5 * 2) + 10 = 20\n</code></pre> <p>This enables true polymorphism where C++ code can work with Ruby-defined subclasses seamlessly.</p>"},{"location":"bindings/enums/","title":"Enums","text":"<p>Rice supports both C enums and newer C++ enum classes.</p> <pre><code>enum Color\n{\n  RED,\n  BLACK,\n  GREEN\n};\n\nenum class Season\n{\n  Spring,\n  Summer,\n  Fall,\n  Winter\n};\n</code></pre> <p>To expose an enum to Ruby, use <code>define_enum</code> like this:</p> <pre><code>Enum&lt;Color&gt; colors = define_enum&lt;Color&gt;(\"Color\")\n  .define_value(\"RED\", RED)\n  .define_value(\"BLACK\", BLACK)\n  .define_value(\"GREEN\", GREEN);\n</code></pre> <p><code>define_enum&lt;Color&gt;(\"Color\")</code> creates a new Ruby class called <code>Color</code>. Each call to <code>define_value</code> defines a new instance of Color that is stored as a constant on the Color class. Thus from the Ruby side of things, the mapping looks like:</p> <pre><code>class Color\n  RED = Color.new(RED)\n  BLACK = Color.new(BLACK)\n  GREEN = Color.new(GREEN)\nend\n</code></pre>"},{"location":"bindings/enums/#nested-and-anonymous-enums","title":"Nested and Anonymous Enums","text":"<p>C/C++ supports the concept of anonymous enums. They used to be used as hack to define constants before C++ compilers supported member constants. For example:</p> <pre><code>class MyClass\n{\n  public:\n    static const int SOME_CONSTANT = 42;\n\n    enum class Season\n    {\n      Spring,\n      Summer,\n      Fall,\n      Winter\n    };\n\n    // Enum hack that used to be needed by compilers\n    enum\n    {\n        HACKED_CLASS_CONSTANT_1 = 43,\n        HACKED_CLASS_CONSTANT_2 = 44\n    };\n};\n</code></pre> <p>In this case, there is one class enum and one anonymous enum. The anonymous enum should be mapped to static member constants like this:</p> <pre><code>// Define the class. Map anonymous enums to constants\nData_Type&lt;MyClass&gt; rb_cMyClass = define_class&lt;MyClass&gt;(\"MyClass\").\n  define_constructor(Constructor&lt;MyClass&gt;()).\n  define_constant(\"SOME_CONSTANT\", 42).\n  define_constant(\"HACKED_CLASS_CONSTANT_1\", (int)MyClass::HACKED_CLASS_CONSTANT_1).\n  define_constant(\"HACKED_CLASS_CONSTANT_2\", (int)MyClass::HACKED_CLASS_CONSTANT_2);\n\n // Define the class and enum and nest it under MyClass\n Enum&lt;Season&gt; seasons = define_enum_under&lt;Season&gt;(\"Season\", rb_cMyClass)\n  .define_value(\"Spring\", Season::Spring)\n  .define_value(\"Summer\", Season::Summer)\n  .define_value(\"Fall\", Season::Fall)\n  .define_value(\"Winter\", Season::Winter);\n</code></pre> <p>From the Ruby side, this creates:</p> <pre><code>class MyClass\n  SOME_CONSTANT = 42\n  HACKED_CLASS_CONSTANT_1 = MyClass::HACKED_CLASS_CONSTANT_1\n  HACKED_CLASS_CONSTANT_2 = MyClass::HACKED_CLASS_CONSTANT_2\n\n  class Season\n    Spring = Color.new(Season::Spring)\n    Summer = Color.new(Season::Summer)\n    Fall = Color.new(Season::Fall)\n    Winter = Color.new(Season::Winter)\n  end\nend\n</code></pre>"},{"location":"bindings/enums/#ruby-api","title":"Ruby API","text":"<p>Generated enum classes have the following Ruby API.</p> <pre><code>Enum.from_int\n\nEnum#&lt;=&gt;\nEnum#eql?\nEnum#hash\nEnum#each\nEnum#inspect\nEnum#to_int\nEnum#to_s\n\nEnum#&amp;\nEnum#|\nEnum#^\nEnum#~\nEnum#&lt;&lt;\nEnum#&gt;&gt;\n</code></pre> <p>In addition, they have the following aliases:</p> <pre><code>Enum#===\nEnum#eql?\nEnum#to_i\nEnum#to_int\n</code></pre> <p>And mixin the following modules:</p> <ul> <li>Comparable</li> <li>Enumerable</li> </ul>"},{"location":"bindings/exceptions/","title":"Exceptions","text":"<p>Rice automatically handles exceptions - making sure that C++ exceptions do not propagate to Ruby code and Ruby exceptions do not propagate to C++. If either happen then your program will crash.</p> <p>It may be necessary, however, for your C++ code to call Ruby code. And that Ruby code, in turn, may call into C++ code. Rice makes it easy to handle that situation as explained below.</p>"},{"location":"bindings/exceptions/#exceptions-translation","title":"Exceptions Translation","text":"<p>When Ruby code calls C++ functions or methods or reads or writes C++ attributes, Rice installs an exception handler that traps any raised C++ exceptions. The handler then translates the C++ exception to a Ruby exception and re-raises it so that it can be handled by the calling Ruby code.</p> <p>The mapping of C++ exceptions to Ruby exceptions is summarized in the table below:</p> C++ Exception Ruby Exception <code>std::bad_alloc</code> <code>NoMemoryError</code> <code>std::domain_error</code> <code>FloatDomainError</code> <code>std::exception</code> <code>RuntimeError</code> <code>std::invalid_argument</code> <code>ArgumentError</code> <code>std::filesystem::filesystem_error</code> <code>IOError</code> <code>std::length_error</code> <code>RuntimeError</code> <code>std::out_of_range</code> <code>IndexError</code> <code>std::overflow_error</code> <code>RangeError</code> <code>std::range_error</code> <code>RangeError</code> <code>std::regex_error</code> <code>RegexpError</code> <code>std::system_error</code> <code>SystemCallError</code> <code>std::underflow_error</code> <code>RangeError</code> <code>Rice::Exception</code> <code>RuntimeError</code> Any other exception <code>RuntimeError</code> <p>Note the Rice::Exception class is a custom exception type defined by Rice and used when Rice itself needs to raise an exception.</p>"},{"location":"bindings/exceptions/#custom-handlers","title":"Custom Handlers","text":"<p>Rice also enables you to register a custom exception handler. This can be done like this:</p> <pre><code>extern \"C\"\nvoid Init_test()\n{\n  register_handler&lt;MyException&gt;(handle_my_exception);\n\n  Data_Type&lt;Test&gt; rb_cTest =\n    define_class&lt;Test&gt;(\"Test\")\n    .define_constructor(Constructor&lt;Test&gt;())\n    .define_method(\"hello\", &amp;Test::hello)\n    .define_method(\"error\", &amp;Test::error);\n}\n</code></pre> <p>The <code>handle_my_exception</code> can any type of exception it wants. For example, it can throw a C++ exception:</p> <pre><code>void handle_my_exception(const MyException&amp; ex)\n{\n  throw std::runtime_error(ex.what());\n}\n</code></pre> <p>Perhaps more useful though is to translate a C++ exception to a Ruby exception. That is done by using the <code>Rice::Exception</code> class like this:</p> <pre><code>void handle_my_exception(const MyException&amp; ex)\n{\n  throw Rice::Exception(rb_eRuntimeError, ex.what_without_backtrace());\n}\n</code></pre>"},{"location":"bindings/exceptions/#handler-order","title":"Handler Order","text":"<p>Previous versions of Rice allowed you to install multiple exception handlers. That support was removed in version 4.5.</p> <p>Exception handlers are global, meaning they are used when Ruby calls C++ functions or reads/writes attributes. They are also applied if you use cpp_protect (see C++ Exceptions).</p>"},{"location":"bindings/exceptions/#ruby-exceptions","title":"Ruby Exceptions","text":"<p>If your C++ code calls a Ruby API it must protect the call to catch any Ruby exceptions. Rice provides a <code>protect</code> method do this. For example, assume you have implemented an <code>each</code> method to add enumerable support to a custom C++ class. The <code>each</code> method should yield values to a user specified block using <code>rb_yield</code>. However if you directly call <code>rb_yield</code> and the Ruby code raises an exception, your program will crash. Instead, use the <code>protect</code> function:</p> <pre><code>      .define_method(\"each\", [](T&amp; vector) -&gt; Object\n      {\n        for (Value_T&amp; item : vector)\n        {\n          VALUE element = detail::To_Ruby&lt;Value_T&gt;().convert(item);\n          detail::protect(rb_yield, element);\n        }\n\n        return vector;\n</code></pre> <p>In almost all cases, the <code>protect</code> method will correctly map its function parameters to the Ruby API being called. However, in rare instances you must help it deduce the correct parameter types. See the C++ Exceptions section below for an example.</p> <p>Rice uses a similar class called <code>Jump_Tag</code> to handle symbols thrown by Ruby's <code>throw</code>/<code>catch</code> or other non-local jumps from inside the Ruby VM.</p>"},{"location":"bindings/exceptions/#c-exceptions","title":"C++ Exceptions","text":"<p>If your C++ code calls a Ruby API which then in turns calls C++ code, you will need to catch any potential C++ exceptions. This is an uncommon case, but can happen when iterating over a Ruby collection from C++. For example:</p> <pre><code>  static int convertPair(VALUE key, VALUE value, VALUE user_data)\n  {\n    // Get the map\n    std::map&lt;T, U&gt;* result = (std::map&lt;T, U&gt;*)(user_data);\n\n    // This method is being called from Ruby so we cannot let any C++\n    // exceptions propagate back to Ruby\n    return cpp_protect([&amp;]\n    {\n      result-&gt;operator[](From_Ruby&lt;T&gt;().convert(key)) = From_Ruby&lt;U&gt;().convert(value);\n      return ST_CONTINUE;\n    });\n  }\n\n  static std::map&lt;T, U&gt; createFromHash(VALUE value)\n  {\n    std::map&lt;T, U&gt; result;\n    VALUE user_data = (VALUE)(&amp;result);\n\n    // MSVC needs help here, but g++ does not\n    using Rb_Hash_ForEach_T = void(*)(VALUE, int(*)(VALUE, VALUE, VALUE), VALUE);\n    detail::protect&lt;Rb_Hash_ForEach_T&gt;(rb_hash_foreach, value, convertPair, user_data);\n\n    return result;\n  }\n</code></pre> <p>This code creates a new std::map from a Ruby hash. To do this, it iterates over the hash  using <code>rb_hash_foreach</code>. The <code>rb_hash_foreach</code> function takes a pointer to a C++ function, in our case called <code>convertPair</code>. Note this is a rare case where the <code>protect</code> call needs help understanding the types of the method it is calling. In this case, the function signature of <code>rb_hash_foreach</code> is <code>void(*)(VALUE, int(*)(VALUE, VALUE, VALUE), VALUE)</code>.</p> <p>For each item in the hash, Ruby calls the <code>convertPair</code> function. Thus we have gone from C++ to Ruby to C++. The <code>convertPair</code> function must catch any raised C++ exceptions. It does that by wrapping the function's code inside a <code>cpp_protect</code> lambda:</p> <pre><code>    // This method is being called from Ruby so we cannot let any C++\n    // exceptions propagate back to Ruby\n    return cpp_protect([&amp;]\n    {\n      result-&gt;operator[](From_Ruby&lt;T&gt;().convert(key)) = From_Ruby&lt;U&gt;().convert(value);\n      return ST_CONTINUE;\n    });\n</code></pre>"},{"location":"bindings/gvl/","title":"Global Virtual Machine Lock (GVL)","text":"<p>Ruby's Global Virtual Machine Lock, commonly known as the GVL, prevents multiple native threads from executing Ruby code simultaneously. This ensures thread safety within the Ruby VM by serializing access to Ruby's internal data structures and preventing race conditions.</p> <p>While the GVL simplifies Ruby's internal implementation and makes extension development safer, it also means that multi-threaded Ruby programs cannot achieve true parallelism when executing Ruby code, even on multi-core systems.</p> <p>However, C++ code called from Ruby often does not need to hold the GVL. If the native code is going to take a significant amount of time to execute, then holding the GVL unnecessarily prevents other Ruby threads from making progress.</p>"},{"location":"bindings/gvl/#functionmethod-annotation","title":"Function/Method Annotation","text":"<p>Rice lets you mark functions and methods that can be run without the GVL.</p> <p>Assume you are wrapping a function that will take a long time to complete:</p> <pre><code>void slowFunction()\n{\n  std::this_thread::sleep_for(std::chrono::milliseconds(100000));\n}\n</code></pre> <p>You can tell Rice to run this code without holding the GVL by using the <code>NoGVL</code> object to mark it as GVL safe:</p> <pre><code>Module m = define_module(\"Testing\");\nm.define_module_function(\"slow_function\", &amp;slowFunction, NoGvl());\n</code></pre> <p>When <code>slow_function</code> is called from Ruby, Rice will first ask Ruby to release the GVL before executing the C++ code.</p>"},{"location":"bindings/gvl/#helper-method","title":"Helper Method","text":"<p>Sometimes you may wish to manually release the GVL. Ruby provides two APIs to do this, <code>rb_thread_call_without_gvl</code> and <code>rb_thread_call_without_gvl2</code>. However, calling them is inconvenient because they require passing in a callback function and figuring out how to pass state to the callback and then return results.</p> <p>To make this easier, Rice provides a helper method called <code>detail:no_gvl</code>. It is simple to use:</p> <pre><code>int result = detail::no_gvl(&amp;slowFunction);\n</code></pre> <p>Rice will ask Ruby to release the GVL, call <code>slowFunction</code> and then reacquire the GVL before returning.</p> <p>This also works for functions and member functions that take multiple arguments. For example, assume this member function:</p> <pre><code>class Task\n{\n  public:\n    int run(bool arg1)\n    {\n    }\n};\n</code></pre> <p>To call the <code>run</code> method without the GVL, pass the object instance as the first parameter and any additional method parameters next.</p> <pre><code>Task task(84);\nint result = detail::no_gvl(&amp;Task::run, task, false);\n</code></pre>"},{"location":"bindings/gvl/#acquire-the-gvl","title":"Acquire the GVL","text":"<p>If a thread releases the GVL, it may not interact with any Ruby objects or the Ruby VM. If you need to call Ruby, then you have to reacquire the GVL. This can be done using Ruby's CAPI <code>rb_thread_call_with_gvl()</code>. Rice currently does not provide a helper method to call this function.</p>"},{"location":"bindings/instance_registry/","title":"Instance Registry","text":"<p>Rice 4.1 added an instance registry which tracks which C++ objects have been wrapped by Ruby objects. This done via a global <code>std::map</code> maintained by Rice.</p>"},{"location":"bindings/instance_registry/#enabled","title":"Enabled","text":"<p>When the instance registry is enabled, Rice will check if a C++ instance has been wrapped by a Ruby instance. If it has, then the existing Ruby instance is returned.</p> <p>By default, instance tracking is disabled. To turn it on:</p> <pre><code>detail::Internal::intance.instances.isEnabled = true;\n</code></pre>"},{"location":"bindings/instance_registry/#disabled","title":"Disabled","text":"<p>When the instance registry is disabled, Rice will wrap a C++ instance in a new Ruby instance regardless of whether it is already wrapped by a Ruby instance. Therefore if you make multiple calls to a C++ method that returns the same C++ object each time via a reference or pointer, multiple wrapping Ruby objects will be created. By default having multiple Ruby objects wrap a C++ object is fine since the Ruby objects do not own the C++ object. For more information please carefully read the C++ to Ruby topic.</p> <p>There is one exception to this rule, which happens when a C++ method returns back itself. Rice recognizes that the C++ object is wrapped by the Ruby object making the call, and thus it is returning self (see return self).</p>"},{"location":"bindings/instance_registry/#why-is-tracking-disabled","title":"Why is Tracking Disabled?","text":"<p>Enabling the instance registry can significantly increase performance. Although tracking introduces a small amount of overhead, it avoids creating duplicate Ruby objects and C++ wrapper objects.</p> <p>However, its unknown if tracking is fully reliable. There are a few potential issues.</p> <p>First, the implementation is not thread-safe. Due to Ruby's GIL, this is not considered an issue.</p> <p>Second, pairs in the global map are removed when a Ruby object is freed by the garbage collector. There could be a window where a Ruby object is marked for deletion but the underlying C++ object is returned back to Ruby. Then the Ruby object would be freed resulting in a crash. It is unknown if this really happens, it has never been observed.</p> <p>Third, a C++ instance wrapped by Ruby instance may be freed on the C++ side. As long as ownership rules have been correctly setup, this is fine. However, if a new C++ instance is created that has the same address as the deleted C++ object and then is passed to Ruby the instance tracker will return the old deleted object. This has been observed in the Rice tests. It is unknown if this is due to how the tests are written or is a more general problem.</p>"},{"location":"bindings/iterators/","title":"Iterators","text":"<p>C++ iterators are used to traverse through elements stored in a container. C++ iterators are external iterators that work in pairs, with a beginning iterator and an ending iterator. For example, <code>std::vector</code> has begin/end, cbegin/cend, rbegin/rend, etc.</p>"},{"location":"bindings/iterators/#enumerable-support-internal-iterators","title":"Enumerable Support (Internal Iterators)","text":"<p>Rice makes it easy to add Enumerable support to C++ classes. The Enumerable module adds internal iterator support to a Ruby class as long as it defines an <code>each</code> instance method.</p> <p>Rice makes this easy via the <code>define_iterator</code> method. <code>define_iterator</code> creates an <code>each</code> method and also mixes in the <code>Enumerable</code> module.</p> <p>For example let's create a simple wrapper around std::vector (for full support please see std::vector).</p> <pre><code>#include &lt;vector&gt;\n#include &lt;rice/rice.hpp&gt;\n\nusing namespace Rice;\n\nextern \"C\"\nvoid Init_IntVector()\n{\n  using IntVector = std::vector&lt;int&gt;;\n  define_class&lt;IntVector&gt;(\"IntVector\")\n    .define_constructor(Constructor&lt;IntVector&gt;())\n    .define_method&lt;void(IntVector::*)(const IntVector::value_type&amp;)&gt;(\"push_back\", &amp;IntVector::push_back)\n    .define_iterator&lt;IntVector::iterator(IntVector::*)()&gt;(&amp;IntVector::begin, &amp;IntVector::end);\n}\n</code></pre> <p>Notice that we have to tell Rice which overloaded version of <code>push_back</code>, <code>begin</code> and <code>end</code> we want to expose For more information please see overloaded methods.</p> <p>Once the iterator is defined you can write standard Ruby code such as:</p> <pre><code>intVector = IntVector.new\nintVector.push_back(1)\nintVector.push_back(2)\nintVector.push_back(3)\n\nresult = intVector.map do |value|\n  value * 2\nend\n</code></pre> <p>Where the result will be <code>[2, 4, 6]</code>.</p> <p>Let's say you also want to expose std::vector's reverse iterator to Ruby using the method name <code>reach</code>. This is done by adding a third parameter to the <code>define_iterator</code> call, in this case it is set to <code>\"reach\"</code>:</p> <pre><code>extern \"C\"\nvoid Init_IntVector()\n{\n  define_class&lt;IntVector&gt;(\"IntVector\")\n    .define_iterator&lt;IntVector::reverse_iterator(IntVector::*)()&gt;(&amp;IntVector::rbegin, &amp;IntVector::rend, \"reach\");\n}\n</code></pre> <p>Example Ruby code is then:</p> <pre><code>intVector = IntVector.new\nintVector.push_back(1)\nintVector.push_back(2)\nintVector.push_back(3)\n\nresult = intVector.reach do |value|\n  result &lt;&lt; value * 2\nend\n</code></pre> <p>Where the result will be <code>[6, 4, 2]</code>.</p>"},{"location":"bindings/iterators/#iterator-requirements","title":"Iterator Requirements","text":"<p>Rice uses <code>std::iterator_traits</code> to determine the value type, reference type, and other properties of iterators. This means your iterator must either:</p> <ol> <li>Define the standard iterator typedefs (<code>value_type</code>, <code>reference</code>, <code>pointer</code>, <code>difference_type</code>, <code>iterator_category</code>), or</li> <li>Have a specialization of <code>std::iterator_traits</code> defined for it</li> </ol> <p>Most STL iterators and well-designed C++ iterators already satisfy these requirements. However, some libraries define iterators that lack these typedefs.</p>"},{"location":"bindings/iterators/#missing-iterator-traits","title":"Missing Iterator Traits","text":"<p>If you encounter a compiler error like:</p> <pre><code>error C2039: 'value_type': is not a member of 'std::iterator_traits&lt;MyIterator&gt;'\n</code></pre> <p>You need to provide a <code>std::iterator_traits</code> specialization for that iterator. For example:</p> <pre><code>#include &lt;iterator&gt;\n\n// Specialization for an iterator that lacks proper traits\nnamespace std\n{\n  template&lt;&gt;\n  struct iterator_traits&lt;MyNamespace::MyIterator&gt;\n  {\n    using iterator_category = forward_iterator_tag;\n    using value_type = MyValueType;\n    using difference_type = ptrdiff_t;\n    using pointer = MyValueType*;\n    using reference = MyValueType&amp;;\n  };\n}\n</code></pre> <p>Place this specialization before your Rice bindings code, typically right after the includes.</p>"},{"location":"bindings/iterators/#common-iterator-categories","title":"Common Iterator Categories","text":"<p>Choose the appropriate <code>iterator_category</code> based on your iterator's capabilities:</p> Category Operations Supported <code>input_iterator_tag</code> Read-only, single-pass (<code>++</code>, <code>*</code>, <code>==</code>) <code>forward_iterator_tag</code> Read/write, multi-pass (<code>++</code>, <code>*</code>, <code>==</code>) <code>bidirectional_iterator_tag</code> Forward + backward (<code>++</code>, <code>--</code>, <code>*</code>, <code>==</code>) <code>random_access_iterator_tag</code> Bidirectional + random access (<code>+</code>, <code>-</code>, <code>[]</code>, <code>&lt;</code>)"},{"location":"bindings/iterators/#enumerator-support-external-iterators","title":"Enumerator Support (External Iterators)","text":"<p>Ruby supports external iterators via the Enumerator class. The <code>define_iterator</code> method automatically adds support for Enumerators.</p> <p>Enumerators can be created by calling an iterator method without a block, in the same way you can call <code>Array#each</code> or other methods without a block. For example:</p> <pre><code>intVector = IntVector.new\nintVector.push_back(1)\nintVector.push_back(2)\nintVector.push_back(3)\n\n# Get an enumerator\nenumerator = intVector.each\n\n# Now  use it\nenumerator.map |i|\n  i * 2\nend\n</code></pre>"},{"location":"bindings/memory_management/","title":"Memory Management","text":"<p>The trickiest part of wrapping a C++ API is correctly managing memory shared between C++ and Ruby. It is critical to get this right - otherwise your program will crash. The key to getting it right is being crystal clear on who owns each piece of memory.</p> <p>Rice divides native types into Builtin types and external types. Builtin types are copied between C++ and Ruby while external types are wrapped. For additional information about builtin types please refer to the Type Conversions section.</p> <p>The rest of this section discusses how to manage memory of external types.</p>"},{"location":"bindings/memory_management/#c-to-ruby","title":"C++ to Ruby","text":"<p>By default Rice assumes that C++ instances passed to Ruby continue to be owned by C++. Thus there is no transfer of ownership. In this case, the transfer follows these rules:</p> Method Return Type (T) C++ to Ruby Cleanup Value (T) Copy constructor Ruby frees the copy, C++ the original Reference (T&amp;) No copy C++ frees the C++ instance Pointer (T*) No copy C++ frees the C++ instance <p>However, many APIs transfer ownership of returned values to the caller. Thus Ruby take ownership of the value. In this case the transfer follows these rules:</p> Method Return Type (T) C++ to Ruby Cleanup Value (T) Copy constructor Ruby frees the copy, C++ the original Reference (T&amp;) Move constructor Ruby frees the C++ instance Pointer (T*) No copy Ruby frees the C++ instance <p>Let's look at an example:</p> <pre><code>class MyClass\n{\n}\n\nclass Factory\n{\npublic:\n  static MyClass* create()\n  {\n    return new MyClass();;\n  }\n}\n\nextern \"C\"\nvoid Init_test()\n{\n  Data_Type&lt;MyClass&gt; rb_cMyClass = define_class&lt;MyClass&gt;(\"MyClass\");\n\n  Data_Type&lt;Factory&gt; rb_cFactory = define_class&lt;Factory&gt;(\"Factory\")\n      .define_function(\"create\", &amp;Factory::create); &lt;--- WRONG, results in memory leak\n}\n</code></pre> <p>Each time <code>Factory#create</code> is called from Ruby, a new C++ instance of MyClass will be created. Using Rice's default rules, this will result in a memory leak because those instance will never be freed.</p> <pre><code>1_000.times do\n  my_class = Factory.create\nend\n</code></pre> <p>To fix this, you need to tell Rice that it should take ownership of the returned instance:</p> <pre><code>define_function(\"create\", &amp;Factory::create, Return().takeOwnership());\n</code></pre> <p>Notice the addition of the <code>Return().takeOwnership()</code>, which creates an instance of the Return class and tells it to take ownership of the instance returned from C++.</p>"},{"location":"bindings/memory_management/#ruby-to-c","title":"Ruby to C++","text":"<p>Sometimes it is necessary to tie the lifetime of one Ruby object to another. This often times happens with containers. For example, imagine we have a <code>Listener</code> and a <code>ListenerContainer</code> class.</p> <pre><code>class Listener\n{\n};\n\nclass ListenerContainer\n{\n  public:\n    void addListener(Listener* listener)\n    {\n      mListeners.push_back(listener);\n    }\n\n    int process()\n    {\n      for(const Listener&amp; listener : mListeners)\n      {\n      }\n    }\n\n  private:\n    std::vector&lt;Listener*&gt; mListeners;\n};\n</code></pre> <p>Assuming these classes are wrapped with Rice, the following code crash:</p> <pre><code>@handler = ListenerContainer.new\n@handler.add_listener(Listener.new)\nGC.start\n@handler.process !!!! crash !!!!!\n</code></pre> <p>The Ruby garbage collector will notice that the <code>Listener.new</code> object is orphaned and will free it. That it turn frees the underlying C++ Listener object resulting in a crash when <code>process</code> is called.</p> <p>To prevent this, we want to tie the lifetime of the Ruby listener instance to the container. This is done by calling <code>keepAlive()</code> in the argument list:</p> <pre><code>define_class&lt;ListenerContainer&gt;(\"ListenerContainer\")\n  .define_method(\"add_listener\", &amp;ListenerContainer::addListener, Arg(\"listener\").keepAlive())\n</code></pre> <p>With this change, when a listener is added to the container, the container keeps a reference to it and will call <code>rb_gc_mark</code> to keep it alive. This is exactly the same thing Ruby's collection classes, such as Arrays and Hashes, do. The <code>Listener</code> object will not be freed until the container itself goes out of scope.</p>"},{"location":"bindings/memory_management/#limitation-removing-objects-from-containers","title":"Limitation: Removing Objects from Containers","text":"<p>It is important to understand that <code>keepAlive</code> references are not released when objects are removed from containers. The reference persists until the container itself is garbage collected.</p> <p>For example:</p> <pre><code>container = ListenerContainer.new\nlistener = Listener.new\ncontainer.add_listener(listener)    # keepAlive stores reference\ncontainer.remove_listener(listener) # reference is NOT removed\nlistener = nil\nGC.start\n# The original Listener is still alive, held by container's keepAlive list\n</code></pre> <p>This is a known trade-off shared by similar libraries like pybind11. Properly tracking removals would require intercepting every removal operation (erase, pop, clear, etc.) and maintaining a more complex reference tracking system.</p> <p>In practice, this means containers using <code>keepAlive</code> may hold references to objects longer than strictly necessary. If this causes memory pressure in your application, consider alternative approaches such as transferring ownership to C++ via <code>takeOwnership()</code> instead.</p> <p>Another example is when a returned object is dependent upon the original object. For example:</p> <pre><code>class Column;\n\nclass Database\n{\npublic:\n  Database()\n  {\n    // connect to Database\n  }\n\n  ~Database()\n  {\n    // disconnect from database\n  }\n\n  Column getColumn(uint32_t index)\n  {\n     return Column(*this, index);\n  }\n\n  std::string lookupName(uint32_t index)\n  {\n    return some_name;\n  }\n};\n\nclass Column\n{\npublic:\n  Column(Database&amp; database, uint32_t index): database_(database), index_(index)\n  {\n  }\n\n  Column getName()\n  {\n    return this-&gt;database_.lookupName(this-&gt;index_);\n  }\n\nprivate:\n  Database&amp; database_;\n  uint32_t index_;\n};\n</code></pre> <p>Assuming these classes are wrapped with Rice, then the following Ruby code will crash:</p> <pre><code>def get_column(column_index)\n  database = Database.new(...)\n  column = database.get_column(column_index)\nend\n\ncolumn = get_column(0)\nputs column.name\n</code></pre> <p>The problem is that the instance of the Database class created in <code>get_column</code> will likely be garbage collected when the method returns. As a result, when <code>Column#name</code> is called it will have a dangling reference to the no longer valid database object.</p> <p>Obviously this code could be rewritten to make sure the database object remains alive throughout the program. Alternatively, you can tell Rice that to tie the lifetime of the Database object to the Column object so that it will not be freed until the Column is freed:</p> <pre><code>define_class&lt;Database&gt;(\"Database\")\n  .define_method(\"get_column\", &amp;Database::getColumn, Return().keepAlive())\n</code></pre> <p>Note that <code>Return().keepAlive()</code> will work with external types only. An attempt to use it with builtin type will result in a runtime exception.</p>"},{"location":"bindings/memory_management/#c-referencing-ruby-objects","title":"C++ Referencing Ruby Objects","text":"<p>When referencing Ruby objects from C++, you need to let Ruby know about them so they are not prematurely garbage collected.</p> <p>There are several ways this can happen:</p>"},{"location":"bindings/memory_management/#stack","title":"Stack","text":"<p>If you are working with VALUEs or Objects stored on the stack, the Ruby garbage collector will try to find them automatically. However, optimizing compilers may prevent them from doing so. Thus you may need to use Ruby's RB_GC_GUARD macro</p>"},{"location":"bindings/memory_management/#heap","title":"Heap","text":"<p>If a C++ object holds a Ruby VALUE and that C++ object is not wrapped by Ruby (i.e., it's allocated on the heap or is a standalone object), use <code>Rice::Pin</code> to prevent the garbage collector from collecting the Ruby object.</p> <pre><code>class Container\n{\npublic:\n  Container(VALUE value) : pin_(value) {}\n  VALUE getValue() const { return pin_.get(); }\n  void setValue(VALUE value) { pin_.set(value); }\n\nprivate:\n  Rice::Pin pin_;\n};\n</code></pre>"},{"location":"bindings/memory_management/#pin-api","title":"Pin API","text":"<ul> <li><code>Pin(VALUE value)</code> - Construct a Pin that protects the given VALUE from garbage collection</li> <li><code>VALUE get() const</code> - Retrieve the pinned VALUE</li> <li><code>void set(VALUE value)</code> - Replace the pinned VALUE</li> </ul>"},{"location":"bindings/memory_management/#copy-semantics","title":"Copy Semantics","text":"<p><code>Pin</code> uses shared ownership internally. When you copy a <code>Pin</code>, both copies share the same underlying GC anchor:</p> <pre><code>Pin pin1(some_value);\nPin pin2 = pin1;       // pin1 and pin2 share the same anchor\n\npin1.set(other_value); // Both pin1.get() and pin2.get() now return other_value\n</code></pre> <p>This is useful when multiple C++ objects need to reference the same Ruby object - only one GC registration is needed.</p>"},{"location":"bindings/memory_management/#when-to-use-pin-vs-ruby_mark","title":"When to Use Pin vs ruby_mark","text":"<p>Use <code>Pin</code> when: * The C++ object is not wrapped by Ruby (e.g., created with <code>new</code> in C++, stored in a global, or part of a C++ library's internal data structures) * You want self-contained protection without manual GC registration</p> <p>Use <code>ruby_mark</code> (see below) when: * The C++ object is wrapped by Ruby via <code>Data_Type</code> * Ruby owns the C++ object and will call the mark function during garbage collection</p>"},{"location":"bindings/memory_management/#member-variables","title":"Member Variables","text":"<p>If you create classes or structures that reference Ruby objects, you need to implement a custom <code>ruby_mark</code> function:</p> <pre><code>class MyClass\n{\n  VALUE value_;\n}\n\nnamespace Rice\n{\n  template&lt;&gt;\n  ruby_mark(const MyClass* myClass)\n  {\n    rb_gc_mark(myClass-&gt;value_);\n  }\n}\n\nData_Type&lt;MyClass&gt; class = define_class&lt;MyClass&gt;(\"MyClass\")\n          .define_constructor(Constructor&lt;MyClass&gt;());\n</code></pre>"},{"location":"bindings/methods/","title":"Functions and Methods","text":"<p>In the tutorial we touched upon how to wrap C++ functions, static member functions and member functions. Now let's go into more depth.</p>"},{"location":"bindings/methods/#default-arguments","title":"Default Arguments","text":"<p>Going back to our initial C++ class example, lets add additional arguments to the <code>hello()</code> method, one of which has a default value:</p> <pre><code>class Test\n{\npublic:\n  Test();\n  std::string hello(std::string first, std::string second = \"world\");\n};\n</code></pre> <p>Since default parameter values are not available through templates, it is necessary to tell Rice about it using <code>Rice::Arg</code>:</p> <pre><code>#include &lt;rice/rice.hpp&gt;\n\nusing namespace Rice;\n\nextern \"C\"\nvoid Init_test()\n{\n  Data_Type&lt;Test&gt; rb_cTest =\n    define_class&lt;Test&gt;(\"Test\").\n    define_constructor(Constructor&lt;Test&gt;()).\n    define_method(\"hello\", &amp;Test::hello,\n       Arg(\"first\"), Arg(\"second\") = \"world\"\n    );\n}\n</code></pre> <p>The syntax is <code>Arg(nameOfParameter)[ = defaultValue]</code>. If using keyword arguments, then the name of the parameter must match the name of the Ruby parameter. Otherwise it is not important. In either case, the value set by the <code>operator=</code> must match the type of the parameter. As such it may be necessary to explicitly cast the default value.</p> <pre><code>.define_method(\"hello\",\n   &amp;Test::hello,\n   Arg(\"first\"), Arg(\"second\") = (std::string)\"world\"\n);\n</code></pre> <p>These <code>Rice::Arg</code> objects must be in the correct positional order. Thus if the second argument has a default value, then there must be two Arg objects.</p> <p>Note that Rice stores a copy of default values internally, so the type must be copyable. Types with deleted or private copy constructors cannot be used as default arguments. This includes types that inherit from non-copyable base classes. If you need to wrap a function with a non-copyable default parameter, you'll need to omit the default value and require Ruby callers to always provide that argument explicitly.</p> <p>Now, Ruby will now know about the default arguments, and this wrapper can be used as expected:</p> <pre><code>t = Test.new\nt.hello(\"hello\")\nt.hello(\"goodnight\", \"moon\")\n</code></pre> <p>This also works with Constructors:</p> <pre><code>.define_constructor(Constructor&lt;SomeClass, int, int&gt;(),\n    Arg(\"arg1\") = 1, Arg(\"otherArg\") = 12);\n</code></pre>"},{"location":"bindings/methods/#output-parameters","title":"Output Parameters","text":"<p>Some C/C++ APIs use output parameter to return multiple values from a functiom. To wrap these functions you can use either Buffers or Tuples.</p>"},{"location":"bindings/methods/#return","title":"Return","text":"<p>Similarly to the <code>Arg</code> class, Rice also supports a <code>Return</code> class that let's you tell Rice how to handle returned values from C++. This is particularly important in correctly managing memory (see C++ to Ruby).</p> <p>It is also helpful in dealing with Ruby's VALUE type which represent Ruby objects. Most of the time Rice will automatically handle VALUE instances, but if a native method takes a VALUE argument or returns a VALUE instance then you have tell Rice.</p> <p>This is because VALUE is a typedef for <code>unsigned long long</code> - but under the hood it is really a pointer to a Ruby object. However, to Rice it is just an integer that needs to be converted to a Ruby numeric value. As a result, if a method takes a VALUE parameter then Rice will convert it to a C++ unsigned long long value instead of  passing it through. Similarly, if a method returns a VALUE then Rice will also convert it to a numeric Ruby object as opposed to simply returning it.</p> <p>To avoid this incorrect conversion, use the <code>setValue()</code> method on the <code>Arg</code> and <code>Return</code> classes. For example:</p> <pre><code>VALUE some_function(VALUE ary)\n{\n  VALUE new_ary = rb_ary_dup(ary);\n  rb_ary_push(new_ary, Qtrue);\n  return new_ary;\n}\n\ndefine_global_function(\"some_function\", &amp;some_function, Arg(\"ary\").setValue(), Return().setValue());\n</code></pre> <p>Note that you can mix <code>Arg</code> and <code>Return</code> objects in any order. For example this also works:</p> <pre><code>define_global_function(\"some_function\", &amp;some_function, Return().setValue(), Arg(\"ary\").setValue());\n</code></pre>"},{"location":"bindings/methods/#keyword-arguments","title":"Keyword Arguments","text":"<p>Starting with version 4.5, Rice supports using Ruby keyword parameters to call C++ functions. The names of the keyword arguments must match the names specified in the <code>Arg</code> parameters used to define the method. The actual underlying names of the C++ parameters are irrelevant because C++ templates have no access to them.</p> <p>For example, reusing the example above:</p> <pre><code>.define_method(\"hello\",\n   &amp;Test::hello,\n   Arg(\"hello\"), Arg(\"second\") = (std::string)\"world\"\n);\n</code></pre> <p>The <code>hello</code> function can be called from Ruby like this:</p> <pre><code>test = Test.new\ntest.hello(first: \"Hello\", second: \"World\")\ntest.hello(first: \"Hello\") # This is ok because the second parameter has a default value\n</code></pre> <p>And it can also be called in the traditional manner like this:</p> <pre><code>test = Test.new\ntest.hello(\"Hello\", \"World\")\ntest.hello(\"Hello\")\n</code></pre> <p>The ability to call the function in two different ways (position and keyword) could cause problems in your extensions if you change its API in the future. Imagine that you decide to move some code from C++ to Ruby - you will need to chose one of the two forms. That could result in breaking code that uses your extension because some users may have used positional arguments and others keyword arguments. However, this seems quite low risk though so Rice only supports defining arguments using the <code>Arg</code> class. In the future Rice may introduce a <code>KeyArg</code> class to avoid this issue.</p>"},{"location":"bindings/methods/#return-self","title":"Return Self","text":"<p>In the case of methods that return <code>self</code> - meaning they return back the same C++ object that was the receiver of the function call - Rice ensures that the same Ruby object is returned. Returning self is a common pattern in Ruby.</p> <p>For example:</p> <pre><code>a = Array.new\na &lt;&lt; 1 &lt;&lt; 2 &lt;&lt; 3 &lt;&lt; 4\n</code></pre> <p>The above code works because the <code>&lt;&lt;</code> method returns the Array <code>a</code>. You can mimic this behavior by the use of lambdas when wrapping C++ classes. For example, Rice wraps <code>std::vector</code> like this:</p> <pre><code>define_vector&lt;int32_t&gt;().\ndefine_method(\"&lt;&lt;\", [](std::vector&lt;int32_t&gt;&amp; self, int32_t value) -&gt; std::vector&lt;int32_t&gt;&amp;  // &lt;----- DON'T MISS THIS\n{\n  self.push_back(value);\n  return self;  // &lt;------  Allows chaining on calls\n});\n</code></pre> <p>Pay careful attention to the lambda return type of <code>std::vector&lt;int32_t&gt;&amp;</code>. If the return type is not specified, then by default the lambda will return by value. That will invoke <code>std::vector</code>'s copy constructor, resulting in two <code>std::vector&lt;int32_t&gt;</code> instance and two Ruby objects. Not at all what you want.</p>"},{"location":"bindings/methods/#lambda-functions","title":"Lambda Functions","text":"<p>Ruby classes are expected to define a <code>to_s</code> method that provides a string representation of an object. A good way of adding addition methods to a class is to use lambda functions:</p> <pre><code>Data_Type&lt;Test&gt; rb_cTest =\n  define_class&lt;Test&gt;(\"Test\").\n  define_method(\"to_s\", [](Test&amp; self)\n  {\n     return \"&lt;Test&gt;\";\n  });\n</code></pre> <p>We define the <code>to_s</code> method to take a single parameter, self, which is an C++ instance of <code>Test</code>. Note that <code>self</code> is passed by reference - we do not want to create a copy of the Test object!</p> <p>The lambda function can take any number of additional parameters. It can be either a stateless or stateful lambda.</p>"},{"location":"bindings/methods/#global-vm-lock-gvl","title":"Global VM Lock (GVL)","text":"<p>Refer to the GVL section to learn how to call C++ code without holding Ruby's GVL.</p>"},{"location":"bindings/operators/","title":"C++ Operators","text":"<p>C++ supports a lot of operators! These include operators that easily come to mind such as arithmetic and logical operators, as well as conversion operators. It also includes obscure operators you probably do not use much (comma operator?).</p> <p>Both C++ and Ruby support operator overriding, although C++ supports more of them. The sections below describe how to map C++ operators to Ruby operators.</p> <p>C++ operators that are not supported by Ruby can be mapped to Ruby methods instead. By convention these methods are named based on the C++ operator name. Thus the C++ assign operator, <code>=</code>, is mapped to a Ruby method called assign.</p> <pre><code>my_object1 = SomeClass.new\nmy_object2 = SomeClass.new\nmy_object1.assign(my_object2)\n</code></pre>"},{"location":"bindings/operators/#arithmetic-operators","title":"Arithmetic Operators","text":"<p>C++ and Ruby support overriding the same arithmetic operators.</p> C++ Ruby + + - - * * / / % %"},{"location":"bindings/operators/#unary-operators","title":"Unary Operators","text":"<p>C++ supports unary versions of <code>+</code>, <code>-</code>, <code>~</code>, and <code>!</code>. Ruby uses special method names for unary <code>+</code> and <code>-</code> to distinguish them from their binary counterparts.</p> C++ Ruby Notes +a +@ Unary plus -a -@ Unary minus (negation) ~a ~ Bitwise NOT !a ! Logical NOT <p>Example:</p> <pre><code>class Vector\n{\npublic:\n    Vector operator-() const;  // Unary minus\n    Vector operator+() const;  // Unary plus\n};\n</code></pre> <pre><code>define_method(\"-@\", &amp;Vector::operator-);\ndefine_method(\"+@\", &amp;Vector::operator+);\n</code></pre> <p>In Ruby:</p> <pre><code>v = Vector.new(1, 2, 3)\nnegated = -v  # Calls -@\n</code></pre>"},{"location":"bindings/operators/#assignment-operators","title":"Assignment Operators","text":"<p>C++ supports overriding assignment operators while Ruby does not. Thus these operators must be mapped to Ruby methods.</p> C++ Ruby Ruby Method = Not overridable assign += Not overridable assign_plus -= Not overridable assign_minus *= Not overridable assign_multiply /= Not overridable assign_divide %= Not overridable assign_modulus"},{"location":"bindings/operators/#bitwise-operators","title":"Bitwise Operators","text":"<p>C++ and Ruby support overriding the same bitwise operators.</p> C++ Ruby &amp; &amp; | | ~ ~ &lt;&lt; &lt;&lt; &gt;&gt; &gt;&gt;"},{"location":"bindings/operators/#comparison-relational-operators","title":"Comparison (Relational) Operators","text":"<p>C++ and Ruby support overriding the same comparison operators.</p> C++ Ruby == == != != &gt; &gt; &lt; &lt; &gt;= &gt;= &lt;= &lt;="},{"location":"bindings/operators/#logical-operators","title":"Logical Operators","text":"<p>Ruby allows the <code>!</code> operator to be overridden but not <code>&amp;&amp;</code> or <code>||</code>.</p> C++ Ruby Ruby Method &amp;&amp; Not overridable logical_and || Not overridable logical_or ! !"},{"location":"bindings/operators/#increment-decrement-operators","title":"Increment / Decrement Operators","text":"<p>C++ supports increment and decrement operators while Ruby does not. Thus these operators must be mapped to Ruby methods.</p> C++ Ruby Ruby Method ++a Not overridable increment a++ Not overridable increment_post --a Not overridable decrement a-- Not overridable decrement_post"},{"location":"bindings/operators/#other-operators","title":"Other Operators","text":"<p>C++ and Ruby support overriding an additional set of operators. The comma operator is not overridable in Ruby nor does it make sense to map it to a Ruby method.</p> C++ Ruby Ruby Method [] [] []= (if reference) () Not Overridable call * Not Overridable dereference &lt;&lt; &lt;&lt; &gt;&gt; &gt;&gt; , Not overridable <p>If a C++ class defines an <code>[]</code> operator that returns a reference, then in it should be mapped to two Ruby operators: <code>[]</code> and <code>[]=</code>.</p> <p>C++ classes that support the <code>()</code> operator are known as functors. Ruby supports overriding the <code>.()</code> operator by defining a <code>call</code> function. Note this isn't quite the same as C++ because it is invoked via <code>.()</code> and not <code>()</code> -- notice the <code>.</code> before the <code>()</code>.</p>"},{"location":"bindings/operators/#conversion-operators","title":"Conversion Operators","text":"<p>C++ allows users to define explicit and implicit conversion operators or functions. These are used to convert a class to a different types. For example:</p> <pre><code>class Money\n{\npublic:\n    Money(float amount);\n    operator float() const;\n};\n</code></pre> <p>The <code>operator double() const;</code> is a user defined conversion function that converts a <code>Money</code> instance to a double. Following Ruby conventions, these conversion functions should be exposed as <code>to_</code> method, in this case <code>to_f</code>.</p>"},{"location":"bindings/overloaded_methods/","title":"Overloaded Methods","text":"<p>C++ supports overloading constructors, methods and functions. Starting with version 4.5, Rice supports C++ method overloading.</p> <p>When you try to wrap an overloaded function the C++ compiler will throw an error message that says something like \"no matching overloaded function found.\"</p>"},{"location":"bindings/overloaded_methods/#getters-and-setters","title":"Getters and Setters","text":"<p>For example, consider this C++ class with a getter and setter that have the same name:</p> <pre><code>class Container\n{\npublic:\n  size_t capacity()\n  {\n    return this-&gt;capacity_;\n  }\n\n  void capacity(size_t value)\n  {\n    this-&gt;capacity_ = value;\n  }\n\nprivate:\n  size_t capacity_;\n};\n</code></pre> <p>If you try and wrap the class like this you will get a compiler error:</p> <pre><code> Class c = define_class&lt;Container&gt;(\"Container\")\n  .define_constructor(Constructor&lt;Container&gt;())\n  .define_method(\"capacity\", &amp;Container::capacity)\n  .define_method(\"capacity=\", &amp;Container::capacity);\n</code></pre> <p>You need to tell the C++ compiler which overloaded method to use. There are several ways to do this as explained below.</p>"},{"location":"bindings/overloaded_methods/#template-parameter","title":"Template Parameter","text":"<p><code>define_method</code> is a template function, therefore one solution is to specify which method you are trying to call like this:</p> <pre><code> Class c = define_class&lt;Container&gt;(\"Container\")\n  .define_constructor(Constructor&lt;Container&gt;())\n  .define_method&lt;size_t(Container::*)()&gt;(\"capacity\", &amp;Container::capacity)\n  .define_method&lt;void(Container::*)(size_t)&gt;(\"capacity=\", &amp;Container::capacity);\n</code></pre> <p>Notice the addition of the template specializations in side the <code>&lt;</code> and '&gt;' brackets. In this case, <code>&lt;size_t(Container::*)()&gt;</code> and <code>&lt;void(Container::*)(size_t)&gt;</code> are C++ pointers to member functions.</p>"},{"location":"bindings/overloaded_methods/#using","title":"Using","text":"<p>Another solution is provided by the C++ keyword <code>using</code>, like this:</p> <pre><code>using Getter_T = size_t(Container::*)();\nusing Setter_T = void(Container::*)(size_t);\n\nClass c = define_class&lt;Container&gt;(\"Container\")\n  .define_constructor(Constructor&lt;Container&gt;())\n  .define_method&lt;Getter_T&gt;(\"capacity\", &amp;Container::capacity)\n  .define_method&lt;Setter_T&gt;(\"capacity=\", &amp;Container::capacity);\n</code></pre> <p>Or even like this:</p> <pre><code>using Getter_T = size_t(Container::*)();\nusing Setter_T = void(Container::*)(size_t);\n\nClass c = define_class&lt;Container&gt;(\"Container\")\n  .define_constructor(Constructor&lt;Container&gt;())\n  .define_method(\"capacity\", (Getter_T)&amp;Container::capacity)\n  .define_method(\"capacity=\", (Setter_T)&amp;Container::capacity);\n</code></pre>"},{"location":"bindings/overloaded_methods/#typedef","title":"Typedef","text":"<p>If you like old school, obtuse C syntax, then use <code>typedef</code> like this:</p> <pre><code>extern \"C\"\nvoid Init_Container()\n{\n    typedef size_t(Container::* Getter_T)();\n    typedef void (Container::* Setter_T)(size_t);\n\n    Class c = define_class&lt;Container&gt;(\"Container\")\n      .define_constructor(Constructor&lt;Container&gt;())\n      .define_method(\"capacity\", (Getter_T)&amp;Container::capacity)\n      .define_method(\"capacity=\", (Setter_T)&amp;Container::capacity);\n}\n</code></pre>"},{"location":"bindings/overloaded_methods/#method-resolution","title":"Method Resolution","text":"<p>Ruby does not natively support method overloading. Thus Rice implements overloading support itself. It does this by maintaining a global registry (see NativeRegistry) of methods keyed on class and method name. For the example above, the key would be <code>Container::capacity</code> and the value is an array of two NativeFunction instances, where each <code>NativeFunction</code> instance maps to one C++ member function.</p> <p>At runtime, Rice evaluates the method parameters sent from Ruby and determines which overloaded C++ method is the best match. It does this by looping over the native <code>NativeFunction</code> instances and calls their <code>matches</code> method. The matches method, in turn, loops over the passed-in parameters and evaluates each one (for more information see the type conversion section).</p> <p>Matches are scored on a scale of 0.0 to 1.0:</p> <ul> <li>1.0 (Exact) - The types match exactly</li> <li>0.99 (ConstMismatch) - Passing a non-const value to a const parameter</li> <li>0.9 (IntToFloat) - Domain change penalty when converting integer to float</li> <li>0.5 (SignedToUnsigned) - Penalty when converting signed Ruby Integer to unsigned C++ type</li> <li>0.5 (FloatToInt) - Domain change penalty when converting float to integer (lossy)</li> <li>0.0 (None) - The types do not match and cannot be converted</li> </ul> <p>For numeric types, Rice uses precision-based scoring. The score is calculated as <code>targetBits / sourceBits</code> when narrowing (e.g., Ruby Integer with 63 bits to C++ <code>int</code> with 31 bits scores 31/63 \u2248 0.49). Cross-domain conversions (int\u2194float) multiply the precision score by the domain penalty.</p> <p>The final score for each overload is: <code>min(all parameter scores) \u00d7 0.99^(number of defaults used)</code>.</p> <p>Based on these scores, each overloaded C++ method is sorted from best match to worst match. The best matching function is then called.</p> <p>For more in-depth information about the resolution algorithm, see the Overload Resolution Architecture documentation.</p>"},{"location":"bindings/overloaded_methods/#type-mapping","title":"Type Mapping","text":"<p>The following table shows how Ruby types are mapped to C++ types. Ruby Integer has 63 bits precision (like <code>long long</code>), and Ruby Float has 53 bits (like <code>double</code> mantissa).</p> C++ Type True False Nil String Integer Float bool 1.0 1.0 1.0 char 1.0 0.11 0.07 signed char 1.0 0.11 0.07 unsigned char 1.0 0.06 0.08 short 0.24 0.14 unsigned short 0.13 0.15 int 0.49 0.29 unsigned int 0.25 0.30 long* 0.49 0.29 unsigned long* 0.25 0.30 long long 1.0 0.50 unsigned long long 0.50 0.50 float 0.34 0.45 double 0.76 1.0 <p>* <code>long</code> is platform-dependent. On 64-bit systems: <code>long</code> = 63 bits (score 1.0), <code>unsigned long</code> = 64 bits (score 0.50).</p> <p>See the Type Mapping Reference for the underlying calculations.</p> <p>If multiple overloads have equal scores, the first one defined wins.</p>"},{"location":"bindings/overview/","title":"Overview","text":"<p>This section explains how to wrap C++ code for use in Ruby. Rice provides a simple, intuitive API that lets you expose C++ classes, methods, functions, and data to Ruby with minimal boilerplate.</p>"},{"location":"bindings/overview/#core-concepts","title":"Core Concepts","text":"<p>Wrapping C++ code involves several key concepts:</p> <p>Classes and Modules</p> <p>Use <code>define_class&lt;T&gt;()</code> to wrap a C++ class as a Ruby class, or <code>define_module()</code> to create a Ruby module for organizing functions. See Constructors for details on defining classes.</p> <p>Methods and Functions</p> <p>Use <code>define_method()</code> to wrap C++ member functions as Ruby instance methods, and <code>define_function()</code> or <code>define_singleton_function()</code> for static/class methods. See Methods for details.</p> <p>Attributes</p> <p>Use <code>define_attr()</code> to expose C++ member variables as Ruby attributes with getter/setter methods. See Attributes for details.</p> <p>Type Conversion</p> <p>Rice automatically converts between C++ and Ruby types. For fundamental types (int, float, string, etc.), values are copied. For wrapped C++ classes, objects are shared between the two languages. See Type Conversion for details.</p>"},{"location":"bindings/overview/#quick-reference","title":"Quick Reference","text":"Task Rice API Wrap a C++ class <code>define_class&lt;MyClass&gt;(\"MyClass\")</code> Add a constructor <code>.define_constructor(Constructor&lt;MyClass, Args...&gt;())</code> Wrap a member function <code>.define_method(\"name\", &amp;MyClass::method)</code> Wrap a static function <code>.define_singleton_function(\"name\", &amp;MyClass::static_method)</code> Expose a member variable <code>.define_attr(\"name\", &amp;MyClass::member)</code> Wrap an enum <code>define_enum&lt;MyEnum&gt;(\"MyEnum\")</code> Add a constant <code>.define_constant(\"NAME\", value)</code>"},{"location":"bindings/overview/#topics","title":"Topics","text":"<ul> <li>Constructors - Defining how Ruby creates C++ objects</li> <li>Methods - Wrapping C++ functions and member functions</li> <li>Overloaded Methods - Handling C++ function overloading</li> <li>Attributes - Exposing C++ member variables</li> <li>Enums - Wrapping C++ enumerations</li> <li>Constants - Defining Ruby constants</li> <li>Inheritance - Mapping C++ class hierarchies to Ruby</li> <li>Operators - Wrapping C++ operators</li> <li>Iterators - Exposing C++ iterators to Ruby</li> <li>Pointers - Working with C++ pointers</li> <li>Buffers - Managing memory buffers</li> <li>Exceptions - Exception handling between C++ and Ruby</li> <li>Memory Management - Controlling object lifetimes</li> <li>Callbacks - Calling Ruby from C++</li> <li>GVL - Managing Ruby's Global VM Lock</li> </ul>"},{"location":"bindings/pointers/","title":"Pointers","text":"<p>C++ makes heavy use of pointers. In general, C++ pointers point to objects which Rice wraps as Ruby objects.</p> <p>However, this is not always the case. As described in the type mapping section, pointers may also point to:</p> <ul> <li>Fundamental types (example, <code>int*</code>)</li> <li>Array of objects (example, <code>int[]</code> or <code>MyClass[]</code>)</li> <li>Array of pointers (example <code>int**</code> or <code>MyClass**</code>)</li> </ul> <p>In these case, Rice uses <code>Pointer&lt;T&gt;</code> and Buffer\\&lt;T&gt; Ruby classes to enable Ruby code to manipulate them. In some cases these classes can be auto generated by Rice and in others you must tell Rice to generate them. These cases are explained below.</p> <p>The <code>Pointer&lt;T&gt;</code> classes have very little functionality - they simply wrap C++ pointers. This allows them to be passed to C++ APIs that take pointers. They also define a single method, <code>buffer</code>, which returns the appropriate Ruby <code>Buffer&lt;T&gt;</code> class.</p> <p><code>Buffer&lt;T&gt;</code> classes enable Ruby to manipulate the memory pointed to by a pointer. They can also create new C++ pointers from Ruby objects.</p>"},{"location":"bindings/pointers/#fundamental-types","title":"Fundamental Types","text":"<p>It is common for C and C++ APIs to take pointers to blocks of memory consisting of fundamental types such as unsigned chars. For example, the OpenCV library includes an API to create a <code>Mat</code> instance like this:</p> <pre><code>Matrix(int rows, int columns, void uint8_t* data)\n</code></pre> <p><code>data</code> is a pointer to a buffer consisting of uint_8 values.</p> <p>Rice automatically detects these types of pointers and generates Pointer and Buffer Ruby classes. For example, for a pointer to an int, <code>int*</code>, Rice will create the Ruby classes  <code>Rice::Pointer\u227aint\u227b</code> and <code>Rice::Buffer\u227aint\u227b</code>.</p>"},{"location":"bindings/pointers/#array-of-objects","title":"Array of Objects","text":"<p>C++ APIs can also take a pointer to an array of objects. For example:</p> <pre><code>Matrix Matrix::operator()(const Range* ranges) const\n</code></pre> <p>This code creates a view onto an existing Matrix based on an array of <code>Range</code> objects. The length of the array is equal to the Matrix's number of dimensions.</p> <p>Rice cannot distinguish this case from a normal pointer, thus you must tell it that ranges is a pointer to an array of objects. This is done using the <code>ArgBuffer</code> class:</p> <pre><code>Data_Type&lt;Matrix&gt; rb_cMatrix =\n  .define_method(\"call\", &amp;Matrix::operator(), ArgBuffer(\"ranges\"));\n</code></pre> <p>If a C++ method or function returns a buffer then you must tell Rice that by using the <code>ReturnBuffer</code> class:</p> <pre><code>Range* Matrix::ranges(const int row)\n\nData_Type&lt;Matrix&gt; rb_cMatrix =\n  .define_method(\"call\", &amp;Matrix::operator(), ReturnBuffer());\n</code></pre>"},{"location":"bindings/pointers/#array-of-pointers","title":"Array of Pointers","text":"<p>The above example also works with an array of pointers. In that case:</p> <pre><code>Matrix Matrix::operator()(const Range** ranges) const\n</code></pre> <p>Notice the <code>ranges</code> parameter is now a <code>**</code> - or an array of pointers.</p> <p>Rice automatically detects these types of pointers and generates Pointer and Buffer Ruby classes. For example, for a pointer to an int, <code>int**</code>, Rice will create the Ruby classes  <code>Rice::Pointer\u227aint\u2217\u227b</code> and <code>Rice::Buffer\u227aint\u2217\u227b</code>.</p>"},{"location":"bindings/references/","title":"References","text":"<p>C++ uses references (<code>T&amp;</code>) extensively. References allow functions to modify the caller's data. Rice handles references to objects automatically, but references to fundamental types require special handling.</p>"},{"location":"bindings/references/#object-types","title":"Object Types","text":"<p>For object types (classes wrapped with <code>define_class</code>), Rice automatically handles references. When a C++ method takes a reference to an object:</p> <pre><code>void process(MyClass&amp; obj);\n</code></pre> <p>Rice will automatically unwrap the Ruby object and pass the underlying C++ object by reference. No special handling is required.</p>"},{"location":"bindings/references/#fundamental-types","title":"Fundamental Types","text":"<p>References to fundamental types (<code>int&amp;</code>, <code>double&amp;</code>, <code>bool&amp;</code>, etc.) require the <code>Reference&lt;T&gt;</code> Ruby class. This is because Ruby's fundamental types (Integer, Float, etc.) are immutable and cannot be passed by reference directly.</p> <p>Consider a C++ API that modifies a value through a reference:</p> <pre><code>void increment(int&amp; value);\n</code></pre> <p>To call this from Ruby, you must use a <code>Reference&lt;T&gt;</code> object:</p> <pre><code>ref = Rice::Reference\u227aint\u227b.new(5)\nincrement(ref)\nref.value  #=&gt; 6\n</code></pre> <p>Rice automatically detects methods that take references to fundamental types and generates the corresponding <code>Reference&lt;T&gt;</code> Ruby classes.</p>"},{"location":"bindings/references/#disambiguating-overloads","title":"Disambiguating Overloads","text":"<p>References are particularly useful for disambiguating overloaded C++ methods. When C++ has both pointer and reference overloads:</p> <pre><code>void process(int* ptr);   // pointer overload\nvoid process(int&amp; ref);   // reference overload\n</code></pre> <p>Ruby code can explicitly choose which overload to call:</p> <pre><code># Call the pointer overload (int*)\nbuffer = Rice::Buffer\u227aint\u227b.new([42])\nobj.process(buffer.ptr)\n\n# Call the reference overload (int&amp;)\nref = Rice::Reference\u227aint\u227b.new(42)\nobj.process(ref)\n</code></pre> <p>Without <code>Reference&lt;T&gt;</code>, Rice would not be able to distinguish between these overloads.</p>"},{"location":"bindings/references/#return-values","title":"Return Values","text":"<p>When a C++ method returns a reference to a fundamental type, Rice always converts it to the corresponding Ruby type. For example:</p> <pre><code>int&amp; get_value();\n</code></pre> <p>This will return a Ruby <code>Integer</code>, not a <code>Reference&lt;int&gt;</code>. This is because Ruby's fundamental types are immutable, so there is no way to maintain a reference back to the C++ value.</p>"},{"location":"bindings/references/#supported-types","title":"Supported Types","text":"<p>Rice supports references to all fundamental types:</p> <ul> <li><code>int&amp;</code>, <code>unsigned int&amp;</code></li> <li><code>long&amp;</code>, <code>unsigned long&amp;</code></li> <li><code>long long&amp;</code>, <code>unsigned long long&amp;</code></li> <li><code>short&amp;</code>, <code>unsigned short&amp;</code></li> <li><code>char&amp;</code>, <code>unsigned char&amp;</code>, <code>signed char&amp;</code></li> <li><code>float&amp;</code>, <code>double&amp;</code></li> <li><code>bool&amp;</code></li> </ul> <p>Rice also supports references to <code>std::string</code>.</p>"},{"location":"bindings/references/#see-also","title":"See Also","text":"<ul> <li>Pointers - For working with <code>T*</code> parameters</li> <li>Buffers - For working with arrays and memory blocks</li> <li>Overloaded Methods - For more on overload resolution</li> </ul>"},{"location":"cpp_api/array/","title":"Array","text":"<pre><code>#include &lt;rice/rice.hpp&gt;\n</code></pre> <p><code>Rice::Array</code> wraps Ruby's Array class and provides a C++-style interface with STL-compatible iterators.</p>"},{"location":"cpp_api/array/#constructors","title":"Constructors","text":""},{"location":"cpp_api/array/#array_1","title":"Array()","text":"<p>Construct a new empty array.</p> <pre><code>Array a;  // []\n</code></pre>"},{"location":"cpp_api/array/#arraylong-capacity","title":"Array(long capacity)","text":"<p>Construct a new array with pre-allocated capacity.</p> <p>Parameters:</p> <ul> <li><code>capacity</code> - The initial capacity.</li> </ul> <pre><code>Array a(100);  // Empty array with space for 100 elements\n</code></pre>"},{"location":"cpp_api/array/#arrayvalue-v","title":"Array(VALUE v)","text":"<p>Wrap an existing Ruby array VALUE.</p> <p>Parameters:</p> <ul> <li><code>v</code> - A Ruby VALUE of type <code>T_ARRAY</code>.</li> </ul> <pre><code>VALUE ruby_arr = rb_ary_new();\nArray a(ruby_arr);\n</code></pre>"},{"location":"cpp_api/array/#arrayobject-v","title":"Array(Object v)","text":"<p>Wrap an existing Ruby Object that is an array.</p> <p>Parameters:</p> <ul> <li><code>v</code> - An Object wrapping an array VALUE.</li> </ul>"},{"location":"cpp_api/array/#arrayiter_t-begin-iter_t-end","title":"Array(Iter_T begin, Iter_T end)","text":"<p>Construct an array from an iterator range.</p> <p>Template Parameters:</p> <ul> <li><code>Iter_T</code> - The iterator type.</li> </ul> <p>Parameters:</p> <ul> <li><code>begin</code> - Iterator to the start of the range.</li> <li><code>end</code> - Iterator to the end of the range.</li> </ul> <pre><code>std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};\nArray a(vec.begin(), vec.end());\n</code></pre>"},{"location":"cpp_api/array/#arrayt-an","title":"Array(T (&amp;a)[n])","text":"<p>Construct an array from a C array.</p> <p>Template Parameters:</p> <ul> <li><code>T</code> - The element type.</li> <li><code>n</code> - The array size.</li> </ul> <p>Parameters:</p> <ul> <li><code>a</code> - A C array.</li> </ul> <pre><code>int values[] = {1, 2, 3, 4, 5};\nArray a(values);\n</code></pre>"},{"location":"cpp_api/array/#public-methods","title":"Public Methods","text":""},{"location":"cpp_api/array/#size-const-long","title":"size() const \u2192 long","text":"<p>Get the number of elements in the array.</p> <p>Returns:</p> <p>The array size.</p> <pre><code>Array a;\na.push(1, false);\na.push(2, false);\nlong sz = a.size();  // 2\n</code></pre>"},{"location":"cpp_api/array/#operatorlong-index-const-object","title":"<code>operator[](long index) const</code> \u2192 Object","text":"<p>Get the element at the given index (read-only).</p> <p>Parameters:</p> <ul> <li><code>index</code> - The index (may be negative to count from end).</li> </ul> <p>Returns:</p> <p>The element as an Object.</p> <pre><code>Array a;\na.push(\"hello\", false);\nObject elem = a[0];   // \"hello\"\nObject last = a[-1];  // \"hello\"\n</code></pre>"},{"location":"cpp_api/array/#operatorlong-index-proxy","title":"<code>operator[](long index)</code> \u2192 Proxy","text":"<p>Get a proxy for the element at the given index (read-write).</p> <p>Parameters:</p> <ul> <li><code>index</code> - The index (may be negative).</li> </ul> <p>Returns:</p> <p>A Proxy that allows assignment.</p> <pre><code>Array a;\na.push(1, false);\na[0] = 42;  // Replace first element\n</code></pre>"},{"location":"cpp_api/array/#pusht-obj-bool-takeownership-false-object","title":"push(T&amp;&amp; obj, bool takeOwnership = false) \u2192 Object","text":"<p>Append an element to the end of the array.</p> <p>Parameters:</p> <ul> <li><code>obj</code> - The object to append (automatically converted to Ruby).</li> <li><code>takeOwnership</code> - If true, Ruby takes ownership of wrapped C++ objects.</li> </ul> <p>Returns:</p> <p>The appended object.</p> <pre><code>Array a;\na.push(1, false);\na.push(\"hello\", false);\na.push(3.14, false);\n</code></pre>"},{"location":"cpp_api/array/#pop-object","title":"pop() \u2192 Object","text":"<p>Remove and return the last element.</p> <p>Returns:</p> <p>The removed element, or <code>Qnil</code> if empty.</p> <pre><code>Array a;\na.push(1, false);\na.push(2, false);\nObject last = a.pop();  // 2\n</code></pre>"},{"location":"cpp_api/array/#unshiftt-const-obj-object","title":"unshift(T const&amp; obj) \u2192 Object","text":"<p>Prepend an element to the beginning of the array.</p> <p>Parameters:</p> <ul> <li><code>obj</code> - The object to prepend.</li> </ul> <p>Returns:</p> <p>The prepended object.</p> <pre><code>Array a;\na.push(2, false);\na.unshift(1);  // [1, 2]\n</code></pre>"},{"location":"cpp_api/array/#shift-object","title":"shift() \u2192 Object","text":"<p>Remove and return the first element.</p> <p>Returns:</p> <p>The removed element.</p> <pre><code>Array a;\na.push(1, false);\na.push(2, false);\nObject first = a.shift();  // 1\n</code></pre>"},{"location":"cpp_api/array/#joinconst-char-separator-string","title":"join(const char* separator) \u2192 String","text":"<p>Join array elements into a string.</p> <p>Parameters:</p> <ul> <li><code>separator</code> - The separator between elements.</li> </ul> <p>Returns:</p> <p>A String with joined elements.</p> <pre><code>Array a;\na.push(\"a\", false);\na.push(\"b\", false);\na.push(\"c\", false);\nString s = a.join(\", \");  // \"a, b, c\"\n</code></pre>"},{"location":"cpp_api/array/#pack-string","title":"pack() \u2192 String <p>Pack array elements into a binary string.</p> <p>Template Parameters:</p> <ul> <li><code>T</code> - The type to pack as.</li> </ul> <p>Returns:</p> <p>A String containing packed binary data.</p> <pre><code>Array a;\na.push(1, false);\na.push(2, false);\nString binary = a.pack&lt;int&gt;();\n</code></pre>","text":""},{"location":"cpp_api/array/#to_vector-stdvector","title":"to_vector() \u2192 std::vector <p>Convert the array to a C++ vector.</p> <p>Template Parameters:</p> <ul> <li><code>T</code> - The element type.</li> </ul> <p>Returns:</p> <p>A std::vector containing converted elements.</p> <pre><code>Array a;\na.push(1, false);\na.push(2, false);\na.push(3, false);\nstd::vector&lt;int&gt; vec = a.to_vector&lt;int&gt;();\n</code></pre>","text":""},{"location":"cpp_api/array/#iterators","title":"Iterators","text":"<p>Array provides STL-compatible random-access iterators.</p>"},{"location":"cpp_api/array/#types","title":"Types <ul> <li><code>Array::iterator</code> - Mutable iterator</li> <li><code>Array::const_iterator</code> - Const iterator</li> </ul>","text":""},{"location":"cpp_api/array/#methods","title":"Methods","text":""},{"location":"cpp_api/array/#begin-iterator","title":"begin() \u2192 iterator","text":"<p>Return an iterator to the first element.</p>"},{"location":"cpp_api/array/#end-iterator","title":"end() \u2192 iterator","text":"<p>Return an iterator past the last element.</p>"},{"location":"cpp_api/array/#begin-const-const_iterator","title":"begin() const \u2192 const_iterator","text":"<p>Return a const iterator to the first element.</p>"},{"location":"cpp_api/array/#end-const-const_iterator","title":"end() const \u2192 const_iterator","text":"<p>Return a const iterator past the last element.</p>"},{"location":"cpp_api/array/#example","title":"Example <pre><code>Array a;\na.push(1, false);\na.push(2, false);\na.push(3, false);\n\n// Range-based for loop\nfor (auto elem : a) {\n  std::cout &lt;&lt; elem &lt;&lt; std::endl;\n}\n\n// Iterator-based loop\nfor (auto it = a.begin(); it != a.end(); ++it) {\n  std::cout &lt;&lt; *it &lt;&lt; std::endl;\n}\n\n// Random access\nauto it = a.begin();\nit += 2;  // Jump to third element\nstd::cout &lt;&lt; *it &lt;&lt; std::endl;  // 3\n\n// STL algorithms work with const_iterators\nauto dist = std::distance(a.begin(), a.end());  // 3\n</code></pre>","text":""},{"location":"cpp_api/array/#inherited-methods","title":"Inherited Methods","text":"<p>Array inherits all methods from Object, including:</p> <ul> <li><code>value()</code> - Get the underlying VALUE</li> <li><code>call()</code> - Call Ruby methods like <code>sort</code>, <code>map</code>, etc.</li> <li><code>is_nil()</code> - Check if nil</li> </ul>"},{"location":"cpp_api/array/#example_1","title":"Example","text":"<pre><code>#include &lt;rice/rice.hpp&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n\nusing namespace Rice;\n\nvoid example()\n{\n  // Create and populate array\n  Array a;\n  a.push(3, false);\n  a.push(1, false);\n  a.push(4, false);\n  a.push(1, false);\n  a.push(5, false);\n\n  // Size\n  std::cout &lt;&lt; \"Size: \" &lt;&lt; a.size() &lt;&lt; std::endl;  // 5\n\n  // Access elements\n  std::cout &lt;&lt; \"First: \" &lt;&lt; a[0] &lt;&lt; std::endl;   // 3\n  std::cout &lt;&lt; \"Last: \" &lt;&lt; a[-1] &lt;&lt; std::endl;   // 5\n\n  // Modify element\n  a[0] = 10;\n\n  // Iterate\n  std::cout &lt;&lt; \"Elements: \";\n  for (auto elem : a) {\n    std::cout &lt;&lt; elem &lt;&lt; \" \";\n  }\n  std::cout &lt;&lt; std::endl;\n\n  // Use Ruby methods\n  Object sorted = a.call(\"sort\");\n  Object sum = a.call(\"sum\");\n\n  // Convert to C++\n  std::vector&lt;int&gt; vec = a.to_vector&lt;int&gt;();\n\n  // Push/pop\n  a.push(9, false);\n  Object popped = a.pop();  // 9\n\n  // Join\n  Array strings;\n  strings.push(\"a\", false);\n  strings.push(\"b\", false);\n  String joined = strings.join(\"-\");  // \"a-b\"\n}\n</code></pre>"},{"location":"cpp_api/class/","title":"Class","text":"<pre><code>#include &lt;rice/rice.hpp&gt;\n</code></pre> <p><code>Rice::Class</code> wraps Ruby's Class and provides methods for defining classes. It inherits from Module and therefore Object.</p>"},{"location":"cpp_api/class/#constructors","title":"Constructors","text":""},{"location":"cpp_api/class/#class_1","title":"Class()","text":"<p>Construct a Class wrapping <code>rb_cObject</code>.</p> <pre><code>Class c;  // wraps Object class\n</code></pre>"},{"location":"cpp_api/class/#classvalue-v","title":"Class(VALUE v)","text":"<p>Wrap an existing Ruby class VALUE.</p> <p>Parameters:</p> <ul> <li><code>v</code> - A Ruby VALUE of type <code>T_CLASS</code>.</li> </ul> <pre><code>Class string_class(rb_cString);\n</code></pre>"},{"location":"cpp_api/class/#free-functions","title":"Free Functions","text":""},{"location":"cpp_api/class/#define_classchar-const-name-const-class-superclass-rb_cobject-class","title":"define_class(char const* name, const Class&amp; superclass = rb_cObject) \u2192 Class","text":"<p>Define a new class in the global namespace.</p> <p>Parameters:</p> <ul> <li><code>name</code> - The class name.</li> <li><code>superclass</code> - The parent class (default: Object).</li> </ul> <p>Returns:</p> <p>The new or existing Class.</p> <pre><code>Class rb_cAnimal = define_class(\"Animal\");\nClass rb_cDog = define_class(\"Dog\", rb_cAnimal);\n</code></pre>"},{"location":"cpp_api/class/#define_class_underobject-parent-char-const-name-const-class-superclass-rb_cobject-class","title":"define_class_under(Object parent, char const* name, const Class&amp; superclass = rb_cObject) \u2192 Class","text":"<p>Define a new class under a parent module or class.</p> <p>Parameters:</p> <ul> <li><code>parent</code> - The parent module or class.</li> <li><code>name</code> - The class name.</li> <li><code>superclass</code> - The parent class (default: Object).</li> </ul> <p>Returns:</p> <p>The new or existing Class.</p> <pre><code>Module rb_mMyModule = define_module(\"MyModule\");\nClass rb_cMyClass = define_class_under(rb_mMyModule, \"MyClass\");\n// Creates MyModule::MyClass\n</code></pre>"},{"location":"cpp_api/class/#anonymous_class-class","title":"anonymous_class() \u2192 Class","text":"<p>Create a new anonymous class.</p> <p>Returns:</p> <p>A new anonymous Class.</p> <pre><code>Class anon = anonymous_class();\n</code></pre>"},{"location":"cpp_api/class/#public-methods","title":"Public Methods","text":""},{"location":"cpp_api/class/#name-const-stdstring","title":"name() const \u2192 std::string","text":"<p>Get the fully-qualified class name.</p> <p>Returns:</p> <p>The class name including parent modules.</p> <pre><code>Module m = define_module(\"MyModule\");\nClass c = define_class_under(m, \"MyClass\");\nstd::string name = c.name();  // \"MyModule::MyClass\"\n</code></pre>"},{"location":"cpp_api/class/#base_name-const-stdstring","title":"base_name() const \u2192 std::string","text":"<p>Get the class name without parent modules.</p> <p>Returns:</p> <p>Just the class name.</p> <pre><code>Module m = define_module(\"MyModule\");\nClass c = define_class_under(m, \"MyClass\");\nstd::string name = c.base_name();  // \"MyClass\"\n</code></pre>"},{"location":"cpp_api/class/#createargs-object","title":"create(args...) \u2192 Object","text":"<p>Create a new instance of the class.</p> <p>Parameters:</p> <ul> <li><code>args...</code> - Arguments to pass to the constructor.</li> </ul> <p>Returns:</p> <p>A new instance of the class.</p> <pre><code>Class rb_cString(rb_cString);\nObject str = rb_cString.create(\"hello\");\n</code></pre>"},{"location":"cpp_api/class/#undef_creation_funcs-class","title":"undef_creation_funcs() \u2192 Class&amp;","text":"<p>Prevent instances from being created from Ruby.</p> <p>Returns:</p> <p>Reference to self for method chaining.</p> <p>Description:</p> <p>Undefines <code>allocate</code> and <code>initialize</code>, preventing <code>new</code> from working.</p> <pre><code>Class c = define_class(\"Singleton\")\n  .undef_creation_funcs();\n\n// Ruby: Singleton.new  #=&gt; raises NoMethodError\n</code></pre>"},{"location":"cpp_api/class/#inherited-methods","title":"Inherited Methods","text":"<p>Class inherits all methods from Module, including:</p> <ul> <li><code>define_method</code></li> <li><code>define_function</code></li> <li><code>define_singleton_method</code></li> <li><code>define_singleton_function</code></li> <li><code>define_constant</code></li> <li><code>include_module</code></li> </ul> <p>See Module for documentation of these methods.</p>"},{"location":"cpp_api/class/#example","title":"Example","text":"<pre><code>#include &lt;rice/rice.hpp&gt;\n\nusing namespace Rice;\n\nclass Rectangle {\npublic:\n  Rectangle(int w, int h) : width_(w), height_(h) {}\n  int area() const { return width_ * height_; }\n  int width() const { return width_; }\n  int height() const { return height_; }\nprivate:\n  int width_, height_;\n};\n\nextern \"C\"\nvoid Init_shapes()\n{\n  Class rb_cRectangle = define_class&lt;Rectangle&gt;(\"Rectangle\")\n    .define_constructor(Constructor&lt;Rectangle, int, int&gt;())\n    .define_method(\"area\", &amp;Rectangle::area)\n    .define_method(\"width\", &amp;Rectangle::width)\n    .define_method(\"height\", &amp;Rectangle::height);\n}\n\n// Ruby usage:\n// rect = Rectangle.new(3, 4)\n// rect.area    #=&gt; 12\n// rect.width   #=&gt; 3\n// rect.height  #=&gt; 4\n</code></pre>"},{"location":"cpp_api/class/#see-also","title":"See Also","text":"<ul> <li>Module - Parent class with method definition helpers</li> <li><code>Data_Type&lt;T&gt;</code> - For wrapping C++ classes with full type support</li> </ul>"},{"location":"cpp_api/hash/","title":"Hash","text":"<pre><code>#include &lt;rice/rice.hpp&gt;\n</code></pre> <p><code>Rice::Hash</code> wraps Ruby's Hash class and provides a C++-style interface with STL-compatible iterators.</p>"},{"location":"cpp_api/hash/#constructors","title":"Constructors","text":""},{"location":"cpp_api/hash/#hash_1","title":"Hash()","text":"<p>Construct a new empty hash.</p> <pre><code>Hash h;  // {}\n</code></pre>"},{"location":"cpp_api/hash/#hashobject-v","title":"Hash(Object v)","text":"<p>Wrap an existing Ruby hash VALUE.</p> <p>Parameters:</p> <ul> <li><code>v</code> - An Object wrapping a <code>T_HASH</code> VALUE.</li> </ul> <pre><code>VALUE ruby_hash = rb_hash_new();\nHash h(ruby_hash);\n</code></pre>"},{"location":"cpp_api/hash/#public-methods","title":"Public Methods","text":""},{"location":"cpp_api/hash/#size-const-size_t","title":"size() const -&gt; size_t","text":"<p>Get the number of key-value pairs in the hash.</p> <p>Returns:</p> <p>The hash size.</p> <pre><code>Hash h;\nh[\"a\"] = 1;\nh[\"b\"] = 2;\nsize_t sz = h.size();  // 2\n</code></pre>"},{"location":"cpp_api/hash/#operatorkey_t-const-key-const-proxy-const","title":"<code>operator[](Key_T const&amp; key) const</code> -&gt; Proxy const","text":"<p>Get the value for the given key (read-only).</p> <p>Template Parameters:</p> <ul> <li><code>Key_T</code> - The key type (automatically converted to Ruby).</li> </ul> <p>Parameters:</p> <ul> <li><code>key</code> - The key whose value should be retrieved.</li> </ul> <p>Returns:</p> <p>A const Proxy that can be implicitly converted to Object.</p> <pre><code>Hash h;\nh[\"name\"] = \"Alice\";\nObject value = h[\"name\"];  // \"Alice\"\n</code></pre>"},{"location":"cpp_api/hash/#operatorkey_t-const-key-proxy","title":"<code>operator[](Key_T const&amp; key)</code> -&gt; Proxy","text":"<p>Get a proxy for the value at the given key (read-write).</p> <p>Template Parameters:</p> <ul> <li><code>Key_T</code> - The key type (automatically converted to Ruby).</li> </ul> <p>Parameters:</p> <ul> <li><code>key</code> - The key whose value should be retrieved or set.</li> </ul> <p>Returns:</p> <p>A Proxy that allows assignment.</p> <pre><code>Hash h;\nh[\"count\"] = 42;       // Set value\nh[\"count\"] = 100;      // Update value\nh[1] = \"one\";          // Integer key\nh[Symbol(\"sym\")] = 3;  // Symbol key\n</code></pre>"},{"location":"cpp_api/hash/#getkey_t-const-key-value_t","title":"get(Key_T const&amp; key) -&gt; Value_T <p>Get the value for the given key, converted to a specific C++ type.</p> <p>Template Parameters:</p> <ul> <li><code>Value_T</code> - The C++ type to convert the value to.</li> <li><code>Key_T</code> - The key type (automatically converted to Ruby).</li> </ul> <p>Parameters:</p> <ul> <li><code>key</code> - The key whose value should be retrieved.</li> </ul> <p>Returns:</p> <p>The value converted to type <code>Value_T</code>.</p> <p>Throws:</p> <p><code>Exception</code> if the value cannot be converted to <code>Value_T</code>.</p> <pre><code>Hash h;\nh[\"count\"] = 42;\nh[\"name\"] = \"test\";\n\nint count = h.get&lt;int&gt;(\"count\");           // 42\nstd::string name = h.get&lt;std::string&gt;(\"name\");  // \"test\"\n</code></pre>","text":""},{"location":"cpp_api/hash/#proxy-class","title":"Proxy Class","text":"<p><code>Hash::Proxy</code> is a helper class that enables the <code>hash[key] = value</code> syntax.</p>"},{"location":"cpp_api/hash/#operator-object-const","title":"operator Object() const <p>Implicitly convert the proxy to an Object (retrieves the value).</p> <pre><code>Hash h;\nh[\"key\"] = \"value\";\nObject obj = h[\"key\"];  // Implicit conversion\n</code></pre>","text":""},{"location":"cpp_api/hash/#value-const-value","title":"value() const -&gt; VALUE <p>Explicitly get the underlying VALUE.</p> <p>Returns:</p> <p>The Ruby VALUE associated with the key.</p> <pre><code>Hash h;\nh[\"key\"] = 42;\nVALUE v = h[\"key\"].value();\n</code></pre>","text":""},{"location":"cpp_api/hash/#operatort-const-value-object","title":"operator=(T const&amp; value) -&gt; Object <p>Assign a value to the key.</p> <p>Template Parameters:</p> <ul> <li><code>T</code> - The value type (automatically converted to Ruby).</li> </ul> <p>Parameters:</p> <ul> <li><code>value</code> - The value to assign.</li> </ul> <p>Returns:</p> <p>The assigned value as an Object.</p> <pre><code>Hash h;\nh[\"int\"] = 42;\nh[\"string\"] = \"hello\";\nh[\"float\"] = 3.14;\n</code></pre>","text":""},{"location":"cpp_api/hash/#entry-class","title":"Entry Class","text":"<p><code>Hash::Entry</code> is a helper class for dereferencing iterators, similar to <code>std::pair</code>.</p>"},{"location":"cpp_api/hash/#members","title":"Members <ul> <li><code>Object const key</code> - The key (also accessible as <code>first</code>)</li> <li><code>Object const&amp; first</code> - Alias for <code>key</code></li> <li><code>Proxy value</code> - The value (also accessible as <code>second</code>)</li> <li><code>Proxy&amp; second</code> - Alias for <code>value</code></li> </ul> <pre><code>Hash h;\nh[\"a\"] = 1;\nh[\"b\"] = 2;\n\nfor (auto entry : h) {\n  std::cout &lt;&lt; entry.first &lt;&lt; \" =&gt; \" &lt;&lt; entry.second &lt;&lt; std::endl;\n}\n</code></pre>","text":""},{"location":"cpp_api/hash/#iterators","title":"Iterators","text":"<p>Hash provides STL-compatible input iterators for traversing key-value pairs.</p>"},{"location":"cpp_api/hash/#types","title":"Types <ul> <li><code>Hash::iterator</code> - Mutable iterator</li> <li><code>Hash::const_iterator</code> - Const iterator</li> </ul>","text":""},{"location":"cpp_api/hash/#methods","title":"Methods","text":""},{"location":"cpp_api/hash/#begin-iterator","title":"begin() -&gt; iterator","text":"<p>Return an iterator to the first entry.</p>"},{"location":"cpp_api/hash/#end-iterator","title":"end() -&gt; iterator","text":"<p>Return an iterator past the last entry.</p>"},{"location":"cpp_api/hash/#begin-const-const_iterator","title":"begin() const -&gt; const_iterator","text":"<p>Return a const iterator to the first entry.</p>"},{"location":"cpp_api/hash/#end-const-const_iterator","title":"end() const -&gt; const_iterator","text":"<p>Return a const iterator past the last entry.</p>"},{"location":"cpp_api/hash/#example","title":"Example <pre><code>Hash h;\nh[\"a\"] = 1;\nh[\"b\"] = 2;\nh[\"c\"] = 3;\n\n// Range-based for loop\nfor (auto entry : h) {\n  std::cout &lt;&lt; entry.key &lt;&lt; \" =&gt; \" &lt;&lt; Object(entry.value) &lt;&lt; std::endl;\n}\n\n// Iterator-based loop\nfor (auto it = h.begin(); it != h.end(); ++it) {\n  std::cout &lt;&lt; it-&gt;first &lt;&lt; \" =&gt; \" &lt;&lt; it-&gt;second &lt;&lt; std::endl;\n}\n</code></pre>","text":""},{"location":"cpp_api/hash/#inherited-methods","title":"Inherited Methods","text":"<p>Hash inherits all methods from Object, including:</p> <ul> <li><code>value()</code> - Get the underlying VALUE</li> <li><code>call()</code> - Call Ruby methods like <code>keys</code>, <code>values</code>, <code>merge</code>, etc.</li> <li><code>is_nil()</code> - Check if nil</li> </ul>"},{"location":"cpp_api/hash/#example_1","title":"Example","text":"<pre><code>#include &lt;rice/rice.hpp&gt;\n#include &lt;iostream&gt;\n\nusing namespace Rice;\n\nvoid example()\n{\n  // Create and populate hash\n  Hash h;\n  h[\"name\"] = \"Alice\";\n  h[\"age\"] = 30;\n  h[\"active\"] = true;\n\n  // Size\n  std::cout &lt;&lt; \"Size: \" &lt;&lt; h.size() &lt;&lt; std::endl;  // 3\n\n  // Access values\n  std::string name = h.get&lt;std::string&gt;(\"name\");\n  int age = h.get&lt;int&gt;(\"age\");\n\n  // Modify values\n  h[\"age\"] = 31;\n\n  // Use various key types\n  Hash h2;\n  h2[1] = \"one\";\n  h2[2] = \"two\";\n  h2[Symbol(\"sym\")] = \"symbol key\";\n\n  // Iterate\n  std::cout &lt;&lt; \"Contents:\" &lt;&lt; std::endl;\n  for (auto entry : h) {\n    std::cout &lt;&lt; \"  \" &lt;&lt; entry.key &lt;&lt; \": \" &lt;&lt; Object(entry.value) &lt;&lt; std::endl;\n  }\n\n  // Call Ruby methods\n  Object keys = h.call(\"keys\");     // [\"name\", \"age\", \"active\"]\n  Object values = h.call(\"values\"); // [\"Alice\", 31, true]\n\n  // Merge hashes\n  Hash other;\n  other[\"city\"] = \"NYC\";\n  Object merged = h.call(\"merge\", other);\n}\n</code></pre>"},{"location":"cpp_api/hash/#see-also","title":"See Also","text":"<ul> <li>Object - Base class</li> <li>Array - Array wrapper class</li> <li>Symbol - Symbol wrapper class</li> </ul>"},{"location":"cpp_api/identifier/","title":"Identifier","text":"<pre><code>#include &lt;rice/rice.hpp&gt;\n</code></pre> <p><code>Rice::Identifier</code> is a wrapper for Ruby's internal <code>ID</code> type. An ID is Ruby's internal representation of a Symbol - it's an integer that uniquely identifies a symbol name. Unlike Symbol, an Identifier is not a Ruby Object; it's a lightweight handle used internally by Ruby.</p> <p>Identifiers are commonly used for:</p> <ul> <li>Method names when calling methods</li> <li>Instance variable names (<code>@foo</code>)</li> <li>Constant names</li> <li>Hash keys in internal operations</li> </ul>"},{"location":"cpp_api/identifier/#constructors","title":"Constructors","text":""},{"location":"cpp_api/identifier/#identifierid-id","title":"Identifier(ID id)","text":"<p>Construct an Identifier from a Ruby ID.</p> <p>Parameters:</p> <ul> <li><code>id</code> - A Ruby ID value.</li> </ul> <pre><code>ID ruby_id = rb_intern(\"my_method\");\nIdentifier id(ruby_id);\n</code></pre>"},{"location":"cpp_api/identifier/#identifiersymbol-const-symbol","title":"Identifier(Symbol const&amp; symbol)","text":"<p>Construct an Identifier from a Symbol.</p> <p>Parameters:</p> <ul> <li><code>symbol</code> - A Symbol to convert.</li> </ul> <pre><code>Symbol sym(\"my_method\");\nIdentifier id(sym);\n</code></pre>"},{"location":"cpp_api/identifier/#identifierchar-const-s-encoding-encoding-encodingutf8","title":"Identifier(char const* s, Encoding encoding = Encoding::utf8())","text":"<p>Construct an Identifier from a C string.</p> <p>Parameters:</p> <ul> <li><code>s</code> - A null-terminated C string.</li> <li><code>encoding</code> - The string encoding (default: UTF-8).</li> </ul> <pre><code>Identifier id(\"my_method\");\nIdentifier id2(\"to_s\");\nIdentifier ivar(\"@name\");\n</code></pre>"},{"location":"cpp_api/identifier/#identifierstdstring-const-string-encoding-encoding-encodingutf8","title":"Identifier(std::string const&amp; string, Encoding encoding = Encoding::utf8())","text":"<p>Construct an Identifier from a C++ string.</p> <p>Parameters:</p> <ul> <li><code>string</code> - A C++ std::string.</li> <li><code>encoding</code> - The string encoding (default: UTF-8).</li> </ul> <pre><code>std::string method_name = \"calculate\";\nIdentifier id(method_name);\n</code></pre>"},{"location":"cpp_api/identifier/#public-methods","title":"Public Methods","text":""},{"location":"cpp_api/identifier/#c_str-const-char-const","title":"c_str() const -&gt; char const*","text":"<p>Get a pointer to the identifier's string representation.</p> <p>Returns:</p> <p>A pointer to the null-terminated string.</p> <pre><code>Identifier id(\"my_method\");\nconst char* name = id.c_str();\nprintf(\"Method: %s\\n\", name);  // \"Method: my_method\"\n</code></pre>"},{"location":"cpp_api/identifier/#str-const-stdstring","title":"str() const -&gt; std::string","text":"<p>Get the identifier as a C++ string.</p> <p>Returns:</p> <p>A std::string copy of the identifier name.</p> <pre><code>Identifier id(\"calculate\");\nstd::string name = id.str();  // \"calculate\"\n</code></pre>"},{"location":"cpp_api/identifier/#id-const-id","title":"id() const -&gt; ID","text":"<p>Get the underlying Ruby ID value.</p> <p>Returns:</p> <p>The raw ID.</p> <pre><code>Identifier id(\"my_method\");\nID raw_id = id.id();\n</code></pre>"},{"location":"cpp_api/identifier/#operator-id-const","title":"operator ID() const","text":"<p>Implicit conversion to Ruby ID.</p> <p>Returns:</p> <p>The raw ID.</p> <pre><code>Identifier id(\"my_method\");\nID raw_id = id;  // Implicit conversion\n\n// Can use directly with Ruby C API\nrb_funcall(obj, id, 0);\n</code></pre>"},{"location":"cpp_api/identifier/#to_sym-const-value","title":"to_sym() const -&gt; VALUE","text":"<p>Convert the Identifier to a Ruby Symbol VALUE.</p> <p>Returns:</p> <p>A Ruby Symbol VALUE.</p> <pre><code>Identifier id(\"my_method\");\nVALUE sym = id.to_sym();  // :my_method as VALUE\n</code></pre>"},{"location":"cpp_api/identifier/#example","title":"Example","text":"<pre><code>#include &lt;rice/rice.hpp&gt;\n#include &lt;iostream&gt;\n\nusing namespace Rice;\n\nvoid example()\n{\n  // Create identifiers\n  Identifier method_id(\"to_s\");\n  Identifier ivar_id(\"@value\");\n  Identifier const_id(\"VERSION\");\n\n  // Get string representations\n  std::cout &lt;&lt; method_id.str() &lt;&lt; std::endl;  // \"to_s\"\n  std::cout &lt;&lt; ivar_id.c_str() &lt;&lt; std::endl;  // \"@value\"\n\n  // Use with Object::call()\n  Object str(rb_str_new_cstr(\"hello\"));\n  Object result = str.call(method_id);  // Calls to_s\n\n  // Use with instance variables\n  Object obj(/* some object */);\n  obj.iv_set(ivar_id, 42);\n  Object val = obj.iv_get(ivar_id);\n\n  // Convert to Symbol\n  VALUE sym = method_id.to_sym();\n  Symbol s(sym);\n\n  // Use directly with Ruby C API (implicit conversion)\n  ID raw = method_id;  // Implicit conversion to ID\n  VALUE result2 = rb_funcall(str.value(), raw, 0);\n}\n\n// Common use case: defining methods\nextern \"C\"\nvoid Init_my_extension()\n{\n  define_class(\"MyClass\")\n    .define_method(Identifier(\"calculate\"), [](Object self, int x) {\n      return x * 2;\n    })\n    .define_method(\"process\", [](Object self) {\n      // Use identifier for method calls\n      return self.call(Identifier(\"calculate\"), 21);\n    });\n}\n</code></pre>"},{"location":"cpp_api/identifier/#identifier-vs-symbol","title":"Identifier vs Symbol","text":"<p>While <code>Identifier</code> and <code>Symbol</code> both represent the same underlying concept (an interned string), they serve different purposes:</p> Feature Identifier Symbol Ruby Type ID (C integer) VALUE (Ruby Object) Inherits from Nothing Object Memory Lightweight (just an int) Full Ruby object Use case Internal operations Ruby-visible values GC tracked No Yes <pre><code>// Use Identifier for internal operations\nIdentifier method_name(\"calculate\");\nobj.call(method_name, args);\n\n// Use Symbol when you need a Ruby Object\nSymbol sym(\"key\");\nhash[sym] = value;\n</code></pre>"},{"location":"cpp_api/identifier/#see-also","title":"See Also","text":"<ul> <li>Symbol - Ruby Symbol wrapper (a Ruby Object)</li> <li>Object - For using identifiers in method calls</li> </ul>"},{"location":"cpp_api/module/","title":"Module","text":"<pre><code>#include &lt;rice/rice.hpp&gt;\n</code></pre> <p><code>Rice::Module</code> wraps Ruby's Module class and provides methods for defining modules and their methods. It inherits from Object.</p>"},{"location":"cpp_api/module/#constructors","title":"Constructors","text":""},{"location":"cpp_api/module/#module_1","title":"Module()","text":"<p>Construct a Module wrapping <code>rb_cObject</code>.</p> <pre><code>Module m;  // wraps Object\n</code></pre>"},{"location":"cpp_api/module/#modulevalue-v","title":"Module(VALUE v)","text":"<p>Wrap an existing Ruby module VALUE.</p> <p>Parameters:</p> <ul> <li><code>v</code> - A Ruby VALUE of type <code>T_MODULE</code>.</li> </ul> <pre><code>Module kernel(rb_mKernel);\n</code></pre>"},{"location":"cpp_api/module/#modulestdstring-name-object-under-rb_cobject","title":"Module(std::string name, Object under = rb_cObject)","text":"<p>Get or create a module by name.</p> <p>Parameters:</p> <ul> <li><code>name</code> - The module name.</li> <li><code>under</code> - The parent module (default: Object).</li> </ul> <pre><code>Module my_mod(\"MyModule\");\nModule nested(\"Nested\", my_mod);  // MyModule::Nested\n</code></pre>"},{"location":"cpp_api/module/#free-functions","title":"Free Functions","text":""},{"location":"cpp_api/module/#define_modulechar-const-name-module","title":"define_module(char const* name) \u2192 Module","text":"<p>Define a new module in the global namespace.</p> <p>Parameters:</p> <ul> <li><code>name</code> - The module name.</li> </ul> <p>Returns:</p> <p>The new or existing Module.</p> <pre><code>Module rb_mMyModule = define_module(\"MyModule\");\n</code></pre>"},{"location":"cpp_api/module/#define_module_underobject-parent-char-const-name-module","title":"define_module_under(Object parent, char const* name) \u2192 Module","text":"<p>Define a new module under a parent module or class.</p> <p>Parameters:</p> <ul> <li><code>parent</code> - The parent module or class.</li> <li><code>name</code> - The module name.</li> </ul> <p>Returns:</p> <p>The new or existing Module.</p> <pre><code>Module rb_mOuter = define_module(\"Outer\");\nModule rb_mInner = define_module_under(rb_mOuter, \"Inner\");\n// Creates Outer::Inner\n</code></pre>"},{"location":"cpp_api/module/#anonymous_module-module","title":"anonymous_module() \u2192 Module","text":"<p>Create a new anonymous module.</p> <p>Returns:</p> <p>A new anonymous Module.</p> <pre><code>Module anon = anonymous_module();\n</code></pre>"},{"location":"cpp_api/module/#public-methods","title":"Public Methods","text":""},{"location":"cpp_api/module/#name-const-string","title":"name() const \u2192 String","text":"<p>Get the module's name.</p> <p>Returns:</p> <p>The module name as a String.</p> <pre><code>Module m = define_module(\"MyModule\");\nstd::string name = m.name().str();  // \"MyModule\"\n</code></pre>"},{"location":"cpp_api/module/#ancestors-const-array","title":"ancestors() const \u2192 Array","text":"<p>Get the module's ancestors.</p> <p>Returns:</p> <p>An Array of ancestor modules/classes.</p> <pre><code>Module m = define_module(\"MyModule\");\nArray ancestors = m.ancestors();\n</code></pre>"},{"location":"cpp_api/module/#singleton_class-const-class","title":"singleton_class() const \u2192 Class","text":"<p>Get the module's singleton class.</p> <p>Returns:</p> <p>The singleton Class.</p>"},{"location":"cpp_api/module/#module_evalstring-const-s-object","title":"module_eval(String const&amp; s) \u2192 Object","text":"<p>Evaluate Ruby code in the context of the module.</p> <p>Parameters:</p> <ul> <li><code>s</code> - A string containing Ruby code.</li> </ul> <p>Returns:</p> <p>The result of the evaluation.</p> <pre><code>Module m = define_module(\"MyModule\");\nm.module_eval(\"def self.hello; 'world'; end\");\n</code></pre>"},{"location":"cpp_api/module/#include_modulemodule-const-inc-auto","title":"include_module(Module const&amp; inc) \u2192 auto&amp;","text":"<p>Include another module.</p> <p>Parameters:</p> <ul> <li><code>inc</code> - The module to include.</li> </ul> <p>Returns:</p> <p>Reference to self for method chaining.</p> <pre><code>Module enumerable(rb_mEnumerable);\nModule m = define_module(\"MyModule\")\n  .include_module(enumerable);\n</code></pre>"},{"location":"cpp_api/module/#defining-methods","title":"Defining Methods","text":""},{"location":"cpp_api/module/#define_methodname-method-args-auto","title":"define_method(name, method, args...) \u2192 auto&amp;","text":"<p>Define an instance method on the module.</p> <p>Parameters:</p> <ul> <li><code>name</code> - The method name.</li> <li><code>method</code> - A function pointer, member function pointer, or lambda.</li> <li><code>args...</code> - Optional <code>Arg</code> objects for default parameters.</li> </ul> <p>Returns:</p> <p>Reference to self for method chaining.</p> <p>Description:</p> <p>For plain functions or lambdas, the first parameter receives <code>self</code> (either as VALUE or as the C++ type).</p> <pre><code>Module m = define_module(\"MyModule\")\n  .define_method(\"greet\", [](Object self, std::string name) {\n    return \"Hello, \" + name + \"!\";\n  });\n</code></pre>"},{"location":"cpp_api/module/#define_functionname-func-args-auto","title":"define_function(name, func, args...) \u2192 auto&amp;","text":"<p>Define an instance method without a self parameter.</p> <p>Parameters:</p> <ul> <li><code>name</code> - The method name.</li> <li><code>func</code> - A function pointer or lambda (no self parameter).</li> <li><code>args...</code> - Optional <code>Arg</code> objects for default parameters.</li> </ul> <p>Returns:</p> <p>Reference to self for method chaining.</p> <pre><code>int add(int a, int b) { return a + b; }\n\nModule m = define_module(\"MyModule\")\n  .define_function(\"add\", &amp;add);\n</code></pre>"},{"location":"cpp_api/module/#define_singleton_methodname-method-args-auto","title":"define_singleton_method(name, method, args...) \u2192 auto&amp;","text":"<p>Define a singleton (class-level) method.</p> <p>Parameters:</p> <ul> <li><code>name</code> - The method name.</li> <li><code>method</code> - A function pointer or lambda (first parameter is self).</li> <li><code>args...</code> - Optional <code>Arg</code> objects.</li> </ul> <p>Returns:</p> <p>Reference to self for method chaining.</p> <pre><code>Module m = define_module(\"MyModule\")\n  .define_singleton_method(\"version\", [](Object self) {\n    return \"1.0.0\";\n  });\n\n// Ruby: MyModule.version  #=&gt; \"1.0.0\"\n</code></pre>"},{"location":"cpp_api/module/#define_singleton_functionname-func-args-auto","title":"define_singleton_function(name, func, args...) \u2192 auto&amp;","text":"<p>Define a singleton method without a self parameter.</p> <p>Parameters:</p> <ul> <li><code>name</code> - The method name.</li> <li><code>func</code> - A function pointer or lambda.</li> <li><code>args...</code> - Optional <code>Arg</code> objects.</li> </ul> <p>Returns:</p> <p>Reference to self for method chaining.</p> <pre><code>Module m = define_module(\"MyModule\")\n  .define_singleton_function(\"pi\", []() {\n    return 3.14159;\n  });\n\n// Ruby: MyModule.pi  #=&gt; 3.14159\n</code></pre>"},{"location":"cpp_api/module/#define_module_functionname-func-args-auto","title":"define_module_function(name, func, args...) \u2192 auto&amp;","text":"<p>Define a module function (accessible as both singleton and instance method).</p> <p>Parameters:</p> <ul> <li><code>name</code> - The method name.</li> <li><code>func</code> - A function pointer or lambda.</li> <li><code>args...</code> - Optional <code>Arg</code> objects.</li> </ul> <p>Returns:</p> <p>Reference to self for method chaining.</p> <p>Note:</p> <p>Only valid for modules (raises exception if called on a class).</p> <pre><code>Module m = define_module(\"MyModule\")\n  .define_module_function(\"helper\", []() {\n    return \"helping\";\n  });\n\n// Ruby:\n// MyModule.helper        #=&gt; \"helping\"\n// include MyModule\n// helper                 #=&gt; \"helping\"\n</code></pre>"},{"location":"cpp_api/module/#define_constantname-value-auto","title":"define_constant(name, value) \u2192 auto&amp;","text":"<p>Define a constant in the module.</p> <p>Parameters:</p> <ul> <li><code>name</code> - The constant name.</li> <li><code>value</code> - The constant value (automatically converted to Ruby).</li> </ul> <p>Returns:</p> <p>Reference to self for method chaining.</p> <pre><code>Module m = define_module(\"MyModule\")\n  .define_constant(\"VERSION\", \"1.0.0\")\n  .define_constant(\"MAX_SIZE\", 1024);\n\n// Ruby: MyModule::VERSION  #=&gt; \"1.0.0\"\n// Ruby: MyModule::MAX_SIZE #=&gt; 1024\n</code></pre>"},{"location":"cpp_api/module/#example","title":"Example","text":"<pre><code>#include &lt;rice/rice.hpp&gt;\n\nusing namespace Rice;\n\nint calculate(int x, int y) {\n  return x * y + 1;\n}\n\nextern \"C\"\nvoid Init_my_extension()\n{\n  Module rb_mMath = define_module(\"MyMath\")\n    .define_module_function(\"calculate\", &amp;calculate)\n    .define_constant(\"PI\", 3.14159)\n    .define_constant(\"E\", 2.71828);\n}\n\n// Ruby usage:\n// MyMath.calculate(3, 4)  #=&gt; 13\n// MyMath::PI              #=&gt; 3.14159\n</code></pre>"},{"location":"cpp_api/object/","title":"Object","text":"<pre><code>#include &lt;rice/rice.hpp&gt;\n</code></pre> <p><code>Rice::Object</code> is the base class for all Rice wrapper classes. It wraps a Ruby <code>VALUE</code> and provides a C++-style interface to Ruby's object system.</p>"},{"location":"cpp_api/object/#constructors","title":"Constructors","text":""},{"location":"cpp_api/object/#object_1","title":"Object()","text":"<p>Construct a new Object wrapping <code>Qnil</code>.</p> <pre><code>Object obj;  // wraps nil\n</code></pre>"},{"location":"cpp_api/object/#objectvalue-value","title":"Object(VALUE value)","text":"<p>Wrap an existing Ruby VALUE.</p> <p>Parameters:</p> <ul> <li><code>value</code> - A Ruby VALUE to wrap.</li> </ul> <pre><code>VALUE ruby_str = rb_str_new_cstr(\"hello\");\nObject obj(ruby_str);\n</code></pre>"},{"location":"cpp_api/object/#constants","title":"Constants","text":"<p>The following constants are provided for convenience:</p> <pre><code>Rice::Nil    // wraps Qnil\nRice::True   // wraps Qtrue\nRice::False  // wraps Qfalse\nRice::Undef  // wraps Qundef\n</code></pre>"},{"location":"cpp_api/object/#public-methods","title":"Public Methods","text":""},{"location":"cpp_api/object/#value-const-value","title":"value() const \u2192 VALUE","text":"<p>Get the underlying Ruby VALUE.</p> <p>Returns:</p> <p>The wrapped VALUE.</p> <pre><code>Object obj(some_value);\nVALUE v = obj.value();\n</code></pre>"},{"location":"cpp_api/object/#test-const-bool","title":"test() const \u2192 bool","text":"<p>Test if the object is truthy.</p> <p>Returns:</p> <p><code>false</code> if the object is <code>nil</code> or <code>false</code>; <code>true</code> otherwise.</p> <pre><code>Object obj(Qtrue);\nif (obj.test()) {\n  // ...\n}\n</code></pre>"},{"location":"cpp_api/object/#operator-bool-const","title":"operator bool() const","text":"<p>Implicit conversion to bool. Same as <code>test()</code>.</p> <pre><code>Object obj(some_value);\nif (obj) {\n  // object is truthy\n}\n</code></pre>"},{"location":"cpp_api/object/#is_nil-const-bool","title":"is_nil() const \u2192 bool","text":"<p>Check if the object is nil.</p> <p>Returns:</p> <p><code>true</code> if the object is nil, <code>false</code> otherwise.</p> <pre><code>Object obj;\nif (obj.is_nil()) {\n  // object is nil\n}\n</code></pre>"},{"location":"cpp_api/object/#class_of-const-class","title":"class_of() const \u2192 Class","text":"<p>Get the object's class.</p> <p>Returns:</p> <p>The object's class as a <code>Rice::Class</code>.</p> <pre><code>Object obj(rb_str_new_cstr(\"hello\"));\nClass klass = obj.class_of();  // String class\n</code></pre>"},{"location":"cpp_api/object/#class_name-const-string","title":"class_name() const \u2192 String","text":"<p>Get the name of the object's class.</p> <p>Returns:</p> <p>The class name as a <code>Rice::String</code>.</p> <pre><code>Object obj(rb_str_new_cstr(\"hello\"));\nstd::string name = obj.class_name().str();  // \"String\"\n</code></pre>"},{"location":"cpp_api/object/#to_s-const-string","title":"to_s() const \u2192 String","text":"<p>Get a string representation of the object.</p> <p>Returns:</p> <p>The result of calling <code>to_s</code> on the Ruby object.</p> <pre><code>Object obj(rb_fix_new(42));\nstd::string str = obj.to_s().str();  // \"42\"\n</code></pre>"},{"location":"cpp_api/object/#inspect-const-string","title":"inspect() const \u2192 String","text":"<p>Get a detailed string representation of the object.</p> <p>Returns:</p> <p>The result of calling <code>inspect</code> on the Ruby object.</p> <pre><code>Object obj(rb_str_new_cstr(\"hello\"));\nstd::string str = obj.inspect().str();  // \"\\\"hello\\\"\"\n</code></pre>"},{"location":"cpp_api/object/#rb_type-const-int","title":"rb_type() const \u2192 int","text":"<p>Get the Ruby type of the underlying VALUE.</p> <p>Returns:</p> <p>One of Ruby's type constants (e.g., <code>T_STRING</code>, <code>T_ARRAY</code>, <code>T_OBJECT</code>).</p> <pre><code>Object obj(rb_str_new_cstr(\"hello\"));\nif (obj.rb_type() == T_STRING) {\n  // it's a string\n}\n</code></pre>"},{"location":"cpp_api/object/#object_id-const-value","title":"object_id() const \u2192 VALUE","text":"<p>Get the object's unique identifier.</p> <p>Returns:</p> <p>The result of calling <code>object_id</code> on the Ruby object.</p> <pre><code>Object obj(some_value);\nVALUE id = obj.object_id();\n</code></pre>"},{"location":"cpp_api/object/#is_aobject-klass-const-bool","title":"is_a(Object klass) const \u2192 bool","text":"<p>Check if the object is an instance of a class or its descendants.</p> <p>Parameters:</p> <ul> <li><code>klass</code> - A class or module to check against.</li> </ul> <p>Returns:</p> <p><code>true</code> if the object is an instance of the class or any subclass.</p> <pre><code>Object obj(rb_str_new_cstr(\"hello\"));\nif (obj.is_a(rb_cString)) {\n  // obj is a String\n}\n</code></pre>"},{"location":"cpp_api/object/#is_instance_ofobject-klass-const-bool","title":"is_instance_of(Object klass) const \u2192 bool","text":"<p>Check if the object is a direct instance of a class.</p> <p>Parameters:</p> <ul> <li><code>klass</code> - A class to check against.</li> </ul> <p>Returns:</p> <p><code>true</code> if the object is a direct instance of the class (not a subclass).</p> <pre><code>Object obj(some_value);\nif (obj.is_instance_of(rb_cString)) {\n  // obj is exactly a String, not a subclass\n}\n</code></pre>"},{"location":"cpp_api/object/#respond_toidentifier-id-const-bool","title":"respond_to(Identifier id) const \u2192 bool","text":"<p>Check if the object responds to a method.</p> <p>Parameters:</p> <ul> <li><code>id</code> - The method name.</li> </ul> <p>Returns:</p> <p><code>true</code> if the object responds to the method.</p> <pre><code>Object obj(some_value);\nif (obj.respond_to(\"to_s\")) {\n  // obj can be converted to string\n}\n</code></pre>"},{"location":"cpp_api/object/#is_equalconst-object-other-const-bool","title":"is_equal(const Object&amp; other) const \u2192 bool","text":"<p>Check if two objects are the same object (<code>equal?</code>).</p> <p>Parameters:</p> <ul> <li><code>other</code> - Another object to compare.</li> </ul> <p>Returns:</p> <p><code>true</code> if the objects are the same object.</p>"},{"location":"cpp_api/object/#is_eqlconst-object-other-const-bool","title":"is_eql(const Object&amp; other) const \u2192 bool","text":"<p>Check if two objects are equivalent (<code>eql?</code>).</p> <p>Parameters:</p> <ul> <li><code>other</code> - Another object to compare.</li> </ul> <p>Returns:</p> <p><code>true</code> if the objects are equivalent.</p>"},{"location":"cpp_api/object/#compareobject-const-other-const-int","title":"compare(Object const&amp; other) const \u2192 int","text":"<p>Compare this object to another using <code>&lt;=&gt;</code>.</p> <p>Parameters:</p> <ul> <li><code>other</code> - Another object to compare.</li> </ul> <p>Returns:</p> <p>Negative if <code>self &lt; other</code>, zero if equal, positive if <code>self &gt; other</code>.</p> <pre><code>Object a(rb_fix_new(1));\nObject b(rb_fix_new(2));\nint result = a.compare(b);  // negative\n</code></pre>"},{"location":"cpp_api/object/#freeze","title":"freeze()","text":"<p>Freeze the object, preventing further modifications.</p> <pre><code>Object obj(rb_str_new_cstr(\"hello\"));\nobj.freeze();\n</code></pre>"},{"location":"cpp_api/object/#is_frozen-const-bool","title":"is_frozen() const \u2192 bool","text":"<p>Check if the object is frozen.</p> <p>Returns:</p> <p><code>true</code> if the object is frozen.</p>"},{"location":"cpp_api/object/#instance_evalstring-const-s-object","title":"instance_eval(String const&amp; s) \u2192 Object","text":"<p>Evaluate a string in the context of the object.</p> <p>Parameters:</p> <ul> <li><code>s</code> - A string containing Ruby code.</li> </ul> <p>Returns:</p> <p>The result of evaluating the code.</p> <pre><code>Object obj(some_value);\nObject result = obj.instance_eval(\"self.class.name\");\n</code></pre>"},{"location":"cpp_api/object/#callidentifier-id-args-const-object","title":"call(Identifier id, args...) const \u2192 Object","text":"<p>Call a method on the object.</p> <p>Parameters:</p> <ul> <li><code>id</code> - The method name.</li> <li><code>args...</code> - Arguments to pass to the method (automatically converted to Ruby).</li> </ul> <p>Returns:</p> <p>The return value of the method call.</p> <pre><code>Object str(rb_str_new_cstr(\"hello\"));\nObject result = str.call(\"upcase\");  // \"HELLO\"\n\nObject arr(rb_ary_new());\narr.call(\"push\", 1, 2, 3);\n</code></pre>"},{"location":"cpp_api/object/#call_kwidentifier-id-args-const-object","title":"call_kw(Identifier id, args...) const \u2192 Object","text":"<p>Call a method with keyword arguments.</p> <p>Parameters:</p> <ul> <li><code>id</code> - The method name.</li> <li><code>args...</code> - Arguments where the last argument is a Hash of keyword arguments.</li> </ul> <p>Returns:</p> <p>The return value of the method call.</p> <pre><code>Hash kw;\nkw[\"encoding\"] = String(\"UTF-8\");\nObject result = obj.call_kw(\"some_method\", kw);\n</code></pre>"},{"location":"cpp_api/object/#vcallidentifier-id-array-args-object","title":"vcall(Identifier id, Array args) \u2192 Object","text":"<p>Call a method with arguments from an Array.</p> <p>Parameters:</p> <ul> <li><code>id</code> - The method name.</li> <li><code>args</code> - An Array of arguments.</li> </ul> <p>Returns:</p> <p>The return value of the method call.</p>"},{"location":"cpp_api/object/#instance-variables","title":"Instance Variables","text":""},{"location":"cpp_api/object/#iv_setidentifier-name-t-const-value","title":"iv_set(Identifier name, T const&amp; value)","text":"<p>Set an instance variable.</p> <p>Parameters:</p> <ul> <li><code>name</code> - The variable name (including <code>@</code>).</li> <li><code>value</code> - The value to set (automatically converted to Ruby).</li> </ul> <pre><code>Object obj(some_value);\nobj.iv_set(\"@my_var\", 42);\n</code></pre>"},{"location":"cpp_api/object/#iv_getidentifier-name-const-object","title":"iv_get(Identifier name) const \u2192 Object","text":"<p>Get an instance variable.</p> <p>Parameters:</p> <ul> <li><code>name</code> - The variable name (including <code>@</code>).</li> </ul> <p>Returns:</p> <p>The value of the instance variable.</p> <pre><code>Object value = obj.iv_get(\"@my_var\");\n</code></pre>"},{"location":"cpp_api/object/#attr_getidentifier-name-const-object","title":"attr_get(Identifier name) const \u2192 Object","text":"<p>Get an instance variable without warning if unset.</p> <p>Parameters:</p> <ul> <li><code>name</code> - The variable name.</li> </ul> <p>Returns:</p> <p>The value of the instance variable, or nil if not set.</p>"},{"location":"cpp_api/object/#constants_1","title":"Constants","text":""},{"location":"cpp_api/object/#const_getidentifier-name-const-object","title":"const_get(Identifier name) const \u2192 Object","text":"<p>Get a constant.</p> <p>Parameters:</p> <ul> <li><code>name</code> - The constant name.</li> </ul> <p>Returns:</p> <p>The value of the constant.</p> <pre><code>Module kernel(rb_mKernel);\nObject version = kernel.const_get(\"RUBY_VERSION\");\n</code></pre>"},{"location":"cpp_api/object/#const_definedidentifier-name-const-bool","title":"const_defined(Identifier name) const \u2192 bool","text":"<p>Check if a constant is defined.</p> <p>Parameters:</p> <ul> <li><code>name</code> - The constant name.</li> </ul> <p>Returns:</p> <p><code>true</code> if the constant is defined.</p>"},{"location":"cpp_api/object/#const_setidentifier-name-object-value-object","title":"const_set(Identifier name, Object value) \u2192 Object","text":"<p>Set a constant.</p> <p>Parameters:</p> <ul> <li><code>name</code> - The constant name.</li> <li><code>value</code> - The value to set.</li> </ul> <p>Returns:</p> <p>The value.</p>"},{"location":"cpp_api/object/#const_set_maybeidentifier-name-object-value-object","title":"const_set_maybe(Identifier name, Object value) \u2192 Object","text":"<p>Set a constant only if not already defined.</p> <p>Parameters:</p> <ul> <li><code>name</code> - The constant name.</li> <li><code>value</code> - The value to set.</li> </ul> <p>Returns:</p> <p>The value.</p>"},{"location":"cpp_api/object/#remove_constidentifier-name","title":"remove_const(Identifier name)","text":"<p>Remove a constant.</p> <p>Parameters:</p> <ul> <li><code>name</code> - The constant name to remove.</li> </ul>"},{"location":"cpp_api/object/#operators","title":"Operators","text":""},{"location":"cpp_api/object/#operatorobject-const-lhs-object-const-rhs-bool","title":"operator==(Object const&amp; lhs, Object const&amp; rhs) \u2192 bool","text":"<p>Test equality using Ruby's <code>==</code> operator.</p> <pre><code>if (obj1 == obj2) {\n  // objects are equal\n}\n</code></pre>"},{"location":"cpp_api/object/#operatorobject-const-lhs-object-const-rhs-bool_1","title":"operator!=(Object const&amp; lhs, Object const&amp; rhs) \u2192 bool","text":"<p>Test inequality.</p>"},{"location":"cpp_api/object/#operatorobject-const-lhs-object-const-rhs-bool_2","title":"operator&lt;(Object const&amp; lhs, Object const&amp; rhs) \u2192 bool","text":"<p>Test if lhs is less than rhs using Ruby's <code>&lt;</code> operator.</p>"},{"location":"cpp_api/object/#operatorobject-const-lhs-object-const-rhs-bool_3","title":"operator&gt;(Object const&amp; lhs, Object const&amp; rhs) \u2192 bool","text":"<p>Test if lhs is greater than rhs using Ruby's <code>&gt;</code> operator.</p>"},{"location":"cpp_api/object/#operatorstdostream-out-object-const-obj-stdostream","title":"operator&lt;&lt;(std::ostream&amp; out, Object const&amp; obj) \u2192 std::ostream&amp;","text":"<p>Output the object to a stream (calls <code>to_s</code>).</p> <pre><code>Object obj(rb_fix_new(42));\nstd::cout &lt;&lt; obj &lt;&lt; std::endl;  // prints \"42\"\n</code></pre>"},{"location":"cpp_api/overview/","title":"Overview","text":"<p>Rice provides C++ wrapper classes for Ruby's built-in types, offering a natural C++ interface while preserving full access to Ruby's functionality.</p>"},{"location":"cpp_api/overview/#class-hierarchy","title":"Class Hierarchy","text":"<p>Rice mimics the Ruby class hierarchy:</p> <pre><code>Object\n\u251c\u2500\u2500 Module\n\u2502   \u2514\u2500\u2500 Class\n\u2502       \u2514\u2500\u2500 Struct\n\u251c\u2500\u2500 Array\n\u251c\u2500\u2500 Hash\n\u251c\u2500\u2500 Identifier\n\u251c\u2500\u2500 String\n\u2514\u2500\u2500 Symbol\n\nIdentifier (not an Object - wraps Ruby's internal ID type)\n</code></pre>"},{"location":"cpp_api/overview/#core-classes","title":"Core Classes","text":"<ul> <li>Object - Base class for all Ruby objects</li> <li>Module - Wraps Ruby modules with method definition support</li> <li>Class - Wraps Ruby classes (inherits from Module)</li> <li>Array - Array with STL-compatible random-access iterators</li> <li>Hash - Hash with STL-compatible iterators</li> <li>Identifier - Lightweight ID wrapper (not a Ruby Object)</li> <li>String - String wrapper with C++ string interop</li> <li>Symbol - Symbol wrapper (Ruby Object)</li> <li>Struct - Dynamic struct class creation</li> </ul>"},{"location":"cpp_api/overview/#quick-examples","title":"Quick Examples","text":"<p>Calling Ruby Methods</p> <pre><code>Object obj(some_value);\nObject result = obj.call(\"method_name\", arg1, arg2);\n\n// With keyword arguments\nHash kwargs;\nkwargs[\"encoding\"] = \"UTF-8\";\nObject result = obj.call_kw(\"method\", kwargs);\n</code></pre> <p>Working with Arrays</p> <pre><code>Array a;\na.push(1, false);\na.push(2, false);\na.push(3, false);\n\n// Range-based for loop (C++11)\nfor (auto elem : a) {\n  std::cout &lt;&lt; elem &lt;&lt; std::endl;\n}\n\n// STL algorithms work\nauto dist = std::distance(a.begin(), a.end());\n</code></pre> <p>Working with Hashes</p> <pre><code>Hash h;\nh[\"name\"] = \"Alice\";\nh[\"age\"] = 30;\n\n// Iterate over entries\nfor (auto entry : h) {\n  std::cout &lt;&lt; entry.key &lt;&lt; \": \" &lt;&lt; Object(entry.value) &lt;&lt; std::endl;\n}\n\n// Get typed values\nstd::string name = h.get&lt;std::string&gt;(\"name\");\nint age = h.get&lt;int&gt;(\"age\");\n</code></pre> <p>Defining Modules and Classes</p> <pre><code>Module m = define_module(\"MyModule\")\n  .define_module_function(\"helper\", []() { return 42; })\n  .define_constant(\"VERSION\", \"1.0.0\");\n\nClass c = define_class(\"MyClass\")\n  .define_method(\"process\", [](Object self, int x) {\n    return x * 2;\n  });\n</code></pre> <p>Type Conversions</p> <p>All wrapper classes automatically convert between C++ and Ruby types:</p> <pre><code>// C++ to Ruby\nString s(\"hello\");           // C string to Ruby String\nArray a({1, 2, 3});          // Initializer list to Ruby Array\nSymbol sym(\"my_symbol\");     // C string to Ruby Symbol\n\n// Ruby to C++\nstd::string cpp_str = s.str();\nstd::vector&lt;int&gt; vec = a.to_vector&lt;int&gt;();\nstd::string sym_str = sym.str();\n</code></pre>"},{"location":"cpp_api/string/","title":"String","text":"<pre><code>#include &lt;rice/rice.hpp&gt;\n</code></pre> <p><code>Rice::String</code> wraps Ruby's String class and provides a C++-style interface to Ruby strings.</p>"},{"location":"cpp_api/string/#constructors","title":"Constructors","text":""},{"location":"cpp_api/string/#string_1","title":"String()","text":"<p>Construct a new empty string.</p> <pre><code>String s;  // empty string \"\"\n</code></pre>"},{"location":"cpp_api/string/#stringvalue-v","title":"String(VALUE v)","text":"<p>Wrap an existing Ruby string VALUE.</p> <p>Parameters:</p> <ul> <li><code>v</code> - A Ruby VALUE of type <code>T_STRING</code>.</li> </ul> <pre><code>VALUE ruby_str = rb_str_new_cstr(\"hello\");\nString s(ruby_str);\n</code></pre>"},{"location":"cpp_api/string/#stringobject-v","title":"String(Object v)","text":"<p>Wrap an existing Ruby Object that is a string.</p> <p>Parameters:</p> <ul> <li><code>v</code> - An Object wrapping a string VALUE.</li> </ul>"},{"location":"cpp_api/string/#stringidentifier-id","title":"String(Identifier id)","text":"<p>Construct a String from an Identifier.</p> <p>Parameters:</p> <ul> <li><code>id</code> - An Identifier to convert to a string.</li> </ul> <pre><code>Identifier id(\"my_method\");\nString s(id);  // \"my_method\"\n</code></pre>"},{"location":"cpp_api/string/#stringchar-const-s","title":"String(char const* s)","text":"<p>Construct a String from a C string.</p> <p>Parameters:</p> <ul> <li><code>s</code> - A null-terminated C string.</li> </ul> <pre><code>String s(\"hello\");\n</code></pre>"},{"location":"cpp_api/string/#stringstdstring-const-s","title":"String(std::string const&amp; s)","text":"<p>Construct a String from a C++ string.</p> <p>Parameters:</p> <ul> <li><code>s</code> - A C++ std::string.</li> </ul> <pre><code>std::string cpp_str = \"hello\";\nString s(cpp_str);\n</code></pre>"},{"location":"cpp_api/string/#stringstdstring_view-const-s","title":"String(std::string_view const&amp; s)","text":"<p>Construct a String from a string_view.</p> <p>Parameters:</p> <ul> <li><code>s</code> - A C++ std::string_view.</li> </ul> <pre><code>std::string_view sv = \"hello\";\nString s(sv);\n</code></pre>"},{"location":"cpp_api/string/#static-methods","title":"Static Methods","text":""},{"location":"cpp_api/string/#formatchar-const-fmt-args-string","title":"format(char const* fmt, args...) \u2192 String","text":"<p>Create a formatted string using printf-style formatting.</p> <p>Parameters:</p> <ul> <li><code>fmt</code> - A printf-style format string.</li> <li><code>args...</code> - Arguments to format.</li> </ul> <p>Returns:</p> <p>A formatted String.</p> <pre><code>String s = String::format(\"Value: %d, Name: %s\", 42, \"test\");\n// \"Value: 42, Name: test\"\n</code></pre>"},{"location":"cpp_api/string/#public-methods","title":"Public Methods","text":""},{"location":"cpp_api/string/#length-const-size_t","title":"length() const \u2192 size_t","text":"<p>Get the length of the string in characters.</p> <p>Returns:</p> <p>The number of characters in the string.</p> <pre><code>String s(\"hello\");\nsize_t len = s.length();  // 5\n</code></pre>"},{"location":"cpp_api/string/#operatorptrdiff_t-index-const-char","title":"<code>operator[](ptrdiff_t index) const</code> \u2192 char","text":"<p>Get the character at the given index.</p> <p>Parameters:</p> <ul> <li><code>index</code> - The index (may be negative to count from end).</li> </ul> <p>Returns:</p> <p>The character at that position.</p> <pre><code>String s(\"hello\");\nchar c = s[0];   // 'h'\nchar d = s[-1];  // 'o'\n</code></pre>"},{"location":"cpp_api/string/#c_str-const-char-const","title":"c_str() const \u2192 char const*","text":"<p>Get a pointer to the underlying C string.</p> <p>Returns:</p> <p>A pointer to the null-terminated string data.</p> <p>Warning:</p> <p>The pointer is only valid while the String object exists and is not modified.</p> <pre><code>String s(\"hello\");\nconst char* cstr = s.c_str();\nprintf(\"%s\\n\", cstr);\n</code></pre>"},{"location":"cpp_api/string/#str-const-stdstring","title":"str() const \u2192 std::string","text":"<p>Get a copy of the string as a C++ std::string.</p> <p>Returns:</p> <p>A std::string copy of the Ruby string.</p> <pre><code>String s(\"hello\");\nstd::string cpp_str = s.str();\n</code></pre>"},{"location":"cpp_api/string/#intern-const-identifier","title":"intern() const \u2192 Identifier","text":"<p>Convert the string to an Identifier (intern it as a symbol).</p> <p>Returns:</p> <p>An Identifier representing the interned string.</p> <pre><code>String s(\"my_method\");\nIdentifier id = s.intern();\n</code></pre>"},{"location":"cpp_api/string/#unpack-const-array","title":"unpack() const \u2192 Array <p>Unpack the string into an Array of values.</p> <p>Template Parameters:</p> <ul> <li><code>T</code> - The type to unpack as (e.g., <code>int</code>, <code>float</code>).</li> </ul> <p>Returns:</p> <p>An Array of unpacked values.</p> <p>Description:</p> <p>This is equivalent to Ruby's <code>String#unpack</code> with the appropriate format for type T.</p> <pre><code>String binary(\"\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\", 8);\nArray values = binary.unpack&lt;int&gt;();  // [1, 2]\n</code></pre>","text":""},{"location":"cpp_api/string/#inherited-methods","title":"Inherited Methods","text":"<p>String inherits all methods from Object, including:</p> <ul> <li><code>value()</code> - Get the underlying VALUE</li> <li><code>to_s()</code> - Convert to string representation</li> <li><code>inspect()</code> - Get detailed representation</li> <li><code>call()</code> - Call Ruby methods</li> <li><code>is_nil()</code> - Check if nil</li> </ul>"},{"location":"cpp_api/string/#example","title":"Example","text":"<pre><code>#include &lt;rice/rice.hpp&gt;\n#include &lt;iostream&gt;\n\nusing namespace Rice;\n\nvoid example()\n{\n  // Create strings various ways\n  String s1(\"hello\");\n  String s2 = String::format(\"Count: %d\", 42);\n\n  // Get as C++ string\n  std::string cpp_str = s1.str();\n\n  // Access characters\n  char first = s1[0];   // 'h'\n  char last = s1[-1];   // 'o'\n\n  // Get length\n  size_t len = s1.length();  // 5\n\n  // Call Ruby methods\n  Object upper = s1.call(\"upcase\");  // \"HELLO\"\n  Object reversed = s1.call(\"reverse\");  // \"olleh\"\n\n  // Concatenation via Ruby\n  Object combined = s1.call(\"+\", String(\" world\"));  // \"hello world\"\n\n  // Output\n  std::cout &lt;&lt; s1 &lt;&lt; std::endl;  // \"hello\"\n}\n</code></pre>"},{"location":"cpp_api/struct/","title":"Struct","text":"<pre><code>#include &lt;rice/rice.hpp&gt;\n</code></pre> <p><code>Rice::Struct</code> is a wrapper for creating Ruby Struct classes from C++. A Struct provides a convenient way to bundle a number of attributes together.</p> <p>Note that the notation used here differs slightly from Ruby's notation:</p> <p>In Ruby:</p> <pre><code>MyStruct = Struct.new(:a, :b, :c)  # Creates a Class\ninstance = MyStruct.new(1, 2, 3)   # Creates an instance of that Class\n</code></pre> <p>In Rice C++:</p> <pre><code>Struct rb_cMyStruct = define_struct()\n  .define_member(\"a\")\n  .define_member(\"b\")\n  .define_member(\"c\")\n  .initialize(rb_mKernel, \"MyStruct\");\n\nStruct::Instance instance = rb_cMyStruct.new_instance(Array({1, 2, 3}));\n</code></pre>"},{"location":"cpp_api/struct/#free-functions","title":"Free Functions","text":""},{"location":"cpp_api/struct/#define_struct-struct","title":"define_struct() -&gt; Struct","text":"<p>Create a new Struct builder.</p> <p>Returns:</p> <p>A new Struct object ready for member definitions.</p> <pre><code>Struct s = define_struct();\n</code></pre>"},{"location":"cpp_api/struct/#public-methods","title":"Public Methods","text":""},{"location":"cpp_api/struct/#define_memberidentifier-name-struct","title":"define_member(Identifier name) -&gt; Struct&amp;","text":"<p>Define a new member of the Struct.</p> <p>Parameters:</p> <ul> <li><code>name</code> - The member name.</li> </ul> <p>Returns:</p> <p>Reference to self for method chaining.</p> <p>Throws:</p> <p><code>std::runtime_error</code> if called after the Struct is initialized.</p> <p>Note:</p> <p>Must be called before <code>initialize()</code>.</p> <pre><code>Struct s = define_struct()\n  .define_member(\"name\")\n  .define_member(\"age\")\n  .define_member(\"active\");\n</code></pre>"},{"location":"cpp_api/struct/#initializemodule-module-identifier-name-struct","title":"initialize(Module module, Identifier name) -&gt; Struct&amp;","text":"<p>Initialize the Struct class and register it under a module.</p> <p>Parameters:</p> <ul> <li><code>module</code> - The module under which to define the Struct class.</li> <li><code>name</code> - The name of the Struct class in Ruby.</li> </ul> <p>Returns:</p> <p>Reference to self for method chaining.</p> <p>Note:</p> <p>Must be called after all members have been defined.</p> <pre><code>Module rb_mMyModule = define_module(\"MyModule\");\n\nStruct s = define_struct()\n  .define_member(\"x\")\n  .define_member(\"y\")\n  .initialize(rb_mMyModule, \"Point\");\n\n// Ruby: MyModule::Point.new(10, 20)\n</code></pre>"},{"location":"cpp_api/struct/#members-const-array","title":"members() const -&gt; Array","text":"<p>Get the members defined in the Struct.</p> <p>Returns:</p> <p>An Array of member names as Symbols.</p> <pre><code>Struct s = define_struct()\n  .define_member(\"a\")\n  .define_member(\"b\")\n  .initialize(rb_mKernel, \"MyStruct\");\n\nArray m = s.members();  // [:a, :b]\n</code></pre>"},{"location":"cpp_api/struct/#new_instancearray-args-array-const-instance","title":"new_instance(Array args = Array()) const -&gt; Instance","text":"<p>Create a new instance of the Struct.</p> <p>Parameters:</p> <ul> <li><code>args</code> - An Array of initial values for the members (default: empty).</li> </ul> <p>Returns:</p> <p>A new <code>Struct::Instance</code>.</p> <pre><code>Struct s = define_struct()\n  .define_member(\"name\")\n  .define_member(\"age\")\n  .initialize(rb_mKernel, \"Person\");\n\n// Create with default (nil) values\nStruct::Instance p1 = s.new_instance();\n\n// Create with initial values\nArray args;\nargs.push(\"Alice\", false);\nargs.push(30, false);\nStruct::Instance p2 = s.new_instance(args);\n</code></pre>"},{"location":"cpp_api/struct/#structinstance","title":"Struct::Instance","text":"<p><code>Struct::Instance</code> represents an instance of a Struct class.</p>"},{"location":"cpp_api/struct/#constructors","title":"Constructors","text":""},{"location":"cpp_api/struct/#instancestruct-const-type-array-args-array","title":"Instance(Struct const&amp; type, Array args = Array())","text":"<p>Create a new instance of a Struct.</p> <p>Parameters:</p> <ul> <li><code>type</code> - The Struct type to create.</li> <li><code>args</code> - Initial values for the members.</li> </ul> <pre><code>Struct::Instance instance(myStruct, Array({1, 2, 3}));\n</code></pre>"},{"location":"cpp_api/struct/#instancestruct-const-type-object-s","title":"Instance(Struct const&amp; type, Object s)","text":"<p>Encapsulate an existing Struct instance.</p> <p>Parameters:</p> <ul> <li><code>type</code> - The Struct type.</li> <li><code>s</code> - An existing Struct instance Object.</li> </ul> <pre><code>Object existing_instance = /* ... */;\nStruct::Instance instance(myStruct, existing_instance);\n</code></pre>"},{"location":"cpp_api/struct/#operatort-index-object","title":"<code>operator[](T index)</code> -&gt; Object","text":"<p>Get a member by index or name.</p> <p>Template Parameters:</p> <ul> <li><code>T</code> - The index type (integral, <code>Identifier</code>, or <code>char const*</code>).</li> </ul> <p>Parameters:</p> <ul> <li><code>index</code> - The member index (0-based) or name.</li> </ul> <p>Returns:</p> <p>The member value as an Object.</p> <pre><code>Struct s = define_struct()\n  .define_member(\"name\")\n  .define_member(\"age\")\n  .initialize(rb_mKernel, \"Person\");\n\nArray args;\nargs.push(\"Alice\", false);\nargs.push(30, false);\nStruct::Instance p = s.new_instance(args);\n\n// Access by index\nObject name1 = p[0];  // \"Alice\"\nObject age1 = p[1];   // 30\n\n// Access by name (Identifier)\nObject name2 = p[Identifier(\"name\")];\n\n// Access by name (C string)\nObject age2 = p[\"age\"];\n</code></pre>"},{"location":"cpp_api/struct/#inherited-methods","title":"Inherited Methods","text":"<p>Struct inherits from Class, which means it has access to:</p> <ul> <li><code>define_method</code> - Add methods to the Struct class</li> <li><code>define_singleton_method</code> - Add class methods</li> <li><code>create</code> - Create instances</li> </ul> <p>Struct::Instance inherits from <code>Builtin_Object&lt;T_STRUCT&gt;</code>, providing access to Object methods.</p>"},{"location":"cpp_api/struct/#example","title":"Example","text":"<pre><code>#include &lt;rice/rice.hpp&gt;\n#include &lt;iostream&gt;\n\nusing namespace Rice;\n\nextern \"C\"\nvoid Init_my_extension()\n{\n  Module rb_mMyModule = define_module(\"MyModule\");\n\n  // Define a Point struct with x and y coordinates\n  Struct rb_cPoint = define_struct()\n    .define_member(\"x\")\n    .define_member(\"y\")\n    .initialize(rb_mMyModule, \"Point\");\n\n  // Add a custom method to the Struct\n  rb_cPoint.define_method(\"distance\", [](Object self) {\n    Object x = self.call(\"x\");\n    Object y = self.call(\"y\");\n    double dx = detail::From_Ruby&lt;double&gt;().convert(x);\n    double dy = detail::From_Ruby&lt;double&gt;().convert(y);\n    return std::sqrt(dx*dx + dy*dy);\n  });\n\n  // Create instances from C++\n  Array args;\n  args.push(3.0, false);\n  args.push(4.0, false);\n  Struct::Instance point = rb_cPoint.new_instance(args);\n\n  // Access members\n  Object x = point[\"x\"];  // 3.0\n  Object y = point[\"y\"];  // 4.0\n\n  // Call the custom method\n  Object distance = Object(point).call(\"distance\");  // 5.0\n}\n\n// Ruby usage:\n// p = MyModule::Point.new(3.0, 4.0)\n// p.x        #=&gt; 3.0\n// p.y        #=&gt; 4.0\n// p.distance #=&gt; 5.0\n</code></pre>"},{"location":"cpp_api/struct/#see-also","title":"See Also","text":"<ul> <li>Class - Parent class</li> <li>Object - Base object methods</li> <li>Array - For passing arguments</li> </ul>"},{"location":"cpp_api/symbol/","title":"Symbol","text":"<pre><code>#include &lt;rice/rice.hpp&gt;\n</code></pre> <p><code>Rice::Symbol</code> wraps Ruby's Symbol class. Symbols are internal identifiers in Ruby - they are singletons and can be thought of as frozen strings. They differ from an Identifier in that they are real Ruby Objects, but they can be converted back and forth between Identifier and Symbol.</p>"},{"location":"cpp_api/symbol/#constructors","title":"Constructors","text":""},{"location":"cpp_api/symbol/#symbolvalue-v","title":"Symbol(VALUE v)","text":"<p>Wrap an existing Ruby symbol VALUE.</p> <p>Parameters:</p> <ul> <li><code>v</code> - A Ruby VALUE of type <code>T_SYMBOL</code>.</li> </ul> <p>Throws:</p> <p><code>TypeError</code> if the value is not a symbol.</p> <pre><code>VALUE ruby_sym = rb_intern(\"my_symbol\");\nVALUE sym_value = rb_id2sym(ruby_sym);\nSymbol s(sym_value);\n</code></pre>"},{"location":"cpp_api/symbol/#symbolobject-v","title":"Symbol(Object v)","text":"<p>Wrap an existing Ruby Object that is a symbol.</p> <p>Parameters:</p> <ul> <li><code>v</code> - An Object wrapping a symbol VALUE.</li> </ul> <p>Throws:</p> <p><code>TypeError</code> if the value is not a symbol.</p>"},{"location":"cpp_api/symbol/#symbolidentifier-id","title":"Symbol(Identifier id)","text":"<p>Construct a Symbol from an Identifier.</p> <p>Parameters:</p> <ul> <li><code>id</code> - An Identifier to convert to a Symbol.</li> </ul> <pre><code>Identifier id(\"my_method\");\nSymbol s(id);  // :my_method\n</code></pre>"},{"location":"cpp_api/symbol/#symbolchar-const-s","title":"Symbol(char const* s = \"\")","text":"<p>Construct a Symbol from a null-terminated C string.</p> <p>Parameters:</p> <ul> <li><code>s</code> - A null-terminated C string (default: empty string).</li> </ul> <pre><code>Symbol s1(\"hello\");     // :hello\nSymbol s2(\"my_method\"); // :my_method\nSymbol s3;              // :\"\"\n</code></pre>"},{"location":"cpp_api/symbol/#symbolstdstring-const-s","title":"Symbol(std::string const&amp; s)","text":"<p>Construct a Symbol from a C++ string.</p> <p>Parameters:</p> <ul> <li><code>s</code> - A C++ std::string.</li> </ul> <pre><code>std::string name = \"calculate\";\nSymbol s(name);  // :calculate\n</code></pre>"},{"location":"cpp_api/symbol/#symbolstdstring_view-const-s","title":"Symbol(std::string_view const&amp; s)","text":"<p>Construct a Symbol from a string_view.</p> <p>Parameters:</p> <ul> <li><code>s</code> - A C++ std::string_view.</li> </ul> <pre><code>std::string_view sv = \"process\";\nSymbol s(sv);  // :process\n</code></pre>"},{"location":"cpp_api/symbol/#public-methods","title":"Public Methods","text":""},{"location":"cpp_api/symbol/#c_str-const-char-const","title":"c_str() const -&gt; char const*","text":"<p>Get a pointer to the symbol's string representation.</p> <p>Returns:</p> <p>A pointer to the null-terminated string.</p> <p>Warning:</p> <p>The pointer is only valid while the Symbol object exists.</p> <pre><code>Symbol s(\"hello\");\nconst char* cstr = s.c_str();\nprintf(\"%s\\n\", cstr);  // \"hello\"\n</code></pre>"},{"location":"cpp_api/symbol/#str-const-stdstring","title":"str() const -&gt; std::string","text":"<p>Get a copy of the symbol as a C++ string.</p> <p>Returns:</p> <p>A std::string copy of the symbol's string representation.</p> <pre><code>Symbol s(\"my_symbol\");\nstd::string cpp_str = s.str();  // \"my_symbol\"\n</code></pre>"},{"location":"cpp_api/symbol/#to_id-const-identifier","title":"to_id() const -&gt; Identifier","text":"<p>Convert the Symbol to an Identifier.</p> <p>Returns:</p> <p>An Identifier representing the same symbol.</p> <pre><code>Symbol s(\"my_method\");\nIdentifier id = s.to_id();\n</code></pre>"},{"location":"cpp_api/symbol/#inherited-methods","title":"Inherited Methods","text":"<p>Symbol inherits all methods from Object, including:</p> <ul> <li><code>value()</code> - Get the underlying VALUE</li> <li><code>to_s()</code> - Convert to string representation</li> <li><code>inspect()</code> - Get detailed representation (e.g., <code>:symbol</code>)</li> <li><code>call()</code> - Call Ruby methods</li> <li><code>is_nil()</code> - Check if nil</li> </ul>"},{"location":"cpp_api/symbol/#example","title":"Example","text":"<pre><code>#include &lt;rice/rice.hpp&gt;\n#include &lt;iostream&gt;\n\nusing namespace Rice;\n\nvoid example()\n{\n  // Create symbols from various sources\n  Symbol s1(\"name\");\n  Symbol s2(std::string(\"age\"));\n  Symbol s3(Identifier(\"active\"));\n\n  // Get string representations\n  std::cout &lt;&lt; s1.str() &lt;&lt; std::endl;  // \"name\"\n  std::cout &lt;&lt; s1.c_str() &lt;&lt; std::endl;  // \"name\"\n\n  // Convert to Identifier\n  Identifier id = s1.to_id();\n\n  // Use as hash keys (common use case)\n  Hash h;\n  h[Symbol(\"name\")] = \"Alice\";\n  h[Symbol(\"age\")] = 30;\n\n  // Compare symbols (they are singletons)\n  Symbol s4(\"name\");\n  if (s1.value() == s4.value()) {\n    std::cout &lt;&lt; \"Same symbol!\" &lt;&lt; std::endl;\n  }\n\n  // Call Ruby methods\n  Object upper = s1.call(\"to_s\").call(\"upcase\");  // \"NAME\"\n  Object inspected = s1.inspect();  // \":name\"\n}\n\n// Exposing a method that takes a Symbol parameter\nextern \"C\"\nvoid Init_my_extension()\n{\n  define_module(\"MyModule\")\n    .define_module_function(\"process\", [](Symbol action) {\n      std::string action_str = action.str();\n      if (action_str == \"start\") {\n        return \"Starting...\";\n      } else if (action_str == \"stop\") {\n        return \"Stopping...\";\n      }\n      return \"Unknown action\";\n    });\n\n  // Ruby usage:\n  // MyModule.process(:start)  #=&gt; \"Starting...\"\n  // MyModule.process(:stop)   #=&gt; \"Stopping...\"\n}\n</code></pre>"},{"location":"cpp_api/symbol/#see-also","title":"See Also","text":"<ul> <li>Object - Base class</li> <li>Identifier - Internal identifier (not a Ruby Object)</li> <li>String - String wrapper class</li> </ul>"},{"location":"packaging/build_settings/","title":"Build Settings","text":""},{"location":"packaging/build_settings/#compiler-settings","title":"Compiler Settings","text":"<p>Rice extensions requires several compiler settings to be set. These are captured in the CMakePresets.json file for all supported platforms.</p> <p>For Clang and GCC:</p> <pre><code>-std=c++17 -Wa,-mbig-obj -ftemplate-backtrace-limit=0\n</code></pre> <p>For MINGW:</p> <pre><code>-std=c++17, -Wa,-mbig-obj\n</code></pre> <p>For Microsoft Visual C++ and Windows Clang:</p> <pre><code>/std:c++17 /EHs /permissive- /bigobj /utf-8 -D_ALLOW_KEYWORD_MACROS -D_CRT_SECURE_NO_DEPRECATE -D_CRT_NONSTDC_NO_DEPRECATE\n</code></pre> <p>These options are described below:</p>"},{"location":"packaging/build_settings/#c17","title":"C++17","text":"<p>First, C++17 must be enabled since Rice makes heavy use of C++17 template and metaprogramming features.</p>"},{"location":"packaging/build_settings/#big-objects","title":"Big Objects","text":"<p>Second, bigobject support needs to enabled. This tells the compiler to increase the number of sections allowed in a .obj file.</p>"},{"location":"packaging/build_settings/#utf-8","title":"UTF-8","text":"<p>Rice uses UTF-8 characters when mapping instantiated STL templates to Ruby class names.</p>"},{"location":"packaging/build_settings/#exception-handling-model","title":"Exception Handling Model","text":"<p>For Visual C++, the default exception model setting of <code>/EHsc</code> crashes Ruby when calling longjmp with optimizations enabled (/O2). Therefore you must <code>/EHs</code> instead.</p>"},{"location":"packaging/build_settings/#template-backtrace","title":"Template Backtrace","text":"<p>For g++, you must set <code>-ftemplate-backtrace-limit=0</code> to avoid compilation errors.</p>"},{"location":"packaging/build_settings/#rtti","title":"RTTI","text":"<p>Rice requires RTTI (Run-Time Type Information) to be enabled. RTTI is enabled by default on all major compilers, but if you have explicitly disabled it, you must re-enable it:</p> <ul> <li>GCC/Clang: <code>-frtti</code> (default is enabled; do not use <code>-fno-rtti</code>)</li> <li>MSVC: <code>/GR</code> (default is enabled; do not use <code>/GR-</code>)</li> </ul> <p>RTTI is essential for Rice's polymorphism support. When a C++ method returns a base class pointer that actually points to a derived class, Rice uses <code>typeid</code> to determine the correct Ruby class to wrap it as. Without RTTI, all objects would be wrapped as their static (declared) type rather than their actual runtime type.</p>"},{"location":"packaging/build_settings/#linker-settings","title":"Linker Settings","text":"<p>Ruby extensions are shared libraries that the Ruby interpreter loads at runtime using <code>dlopen</code>. These extensions reference symbols from the Ruby C API (such as <code>rb_define_class</code>, <code>rb_funcall</code>, etc.) that are provided by the Ruby interpreter itself. Since these symbols are not available at link time, the linker must be told to allow unresolved symbols.</p>"},{"location":"packaging/build_settings/#macos","title":"macOS","text":"<p>On macOS, use the following linker flag:</p> <pre><code>-Wl,-undefined,dynamic_lookup\n</code></pre> <p>This tells the linker to allow undefined symbols and resolve them dynamically at load time. When Ruby loads the extension, the symbols are resolved against the Ruby interpreter's symbol table.</p>"},{"location":"packaging/build_settings/#linux","title":"Linux","text":"<p>On Linux, use the following linker flag:</p> <pre><code>-Wl,--unresolved-symbols=ignore-all\n</code></pre> <p>This instructs the linker to ignore all unresolved symbols during linking. The symbols will be resolved when the Ruby interpreter loads the shared library.</p>"},{"location":"packaging/build_settings/#windows","title":"Windows","text":"<p>On Windows, no special linker flags are required. The extension links directly against the Ruby library (e.g., <code>x64-vcruntime140-ruby320.lib</code>), which provides the necessary symbols at link time.</p>"},{"location":"packaging/build_settings/#link-time-optimization-lto","title":"Link Time Optimization (LTO)","text":"<p>Link Time Optimization is highly recommended for Rice extensions, especially for release builds. Rice makes extensive use of C++ templates, which can result in significant code duplication across translation units. LTO allows the linker to deduplicate template instantiations and perform whole-program optimizations.</p>"},{"location":"packaging/build_settings/#why-lto-matters-for-rice","title":"Why LTO Matters for Rice","text":"<p>Rice's template-heavy design means that each <code>.cpp</code> file that uses Rice generates its own copies of template instantiations. Without LTO, these duplicate instantiations remain in the final binary, dramatically increasing its size. LTO enables the linker to:</p> <ul> <li>Deduplicate identical template instantiations across object files</li> <li>Inline functions across translation unit boundaries</li> <li>Remove dead code more effectively</li> </ul>"},{"location":"packaging/build_settings/#build-size-comparison","title":"Build Size Comparison","text":"<p>The following table shows the impact of LTO on a real-world Rice extension (opencv-ruby bindings):</p> Platform Debug Release (with LTO) Size Reduction MSVC 140 MB 70 MB 50% macOS 324 MB 164 MB 50% MinGW 1.4 GB 200 MB 86% <p>As shown, LTO provides substantial size reductions across all platforms, with MinGW benefiting the most dramatically.</p> <p>Rice's <code>CMakePreset.json</code> automatically enables LTO by setting <code>CMAKE_INTERPROCEDURAL_OPTIMIZATION</code> to <code>ON</code>.</p> <p>If you are using <code>extconf.rb (Mkmf)</code> then:</p> <pre><code>$CXXFLAGS &lt;&lt; \" -flto\"\n$LDFLAGS &lt;&lt; \" -flto\"\n</code></pre> <p>For MSVC:</p> <pre><code>$CXXFLAGS &lt;&lt; \" /GL\"\n$LDFLAGS &lt;&lt; \" /LTCG\"\n</code></pre>"},{"location":"packaging/build_settings/#debug-symbol-splitting-gccclang","title":"Debug Symbol Splitting (GCC/Clang)","text":"<p>For debug builds with GCC or Clang, consider using <code>-gsplit-dwarf</code> to separate debug information into <code>.dwo</code> files. This keeps the main binary smaller while preserving full debug capability:</p> <pre><code>set(CMAKE_CXX_FLAGS_DEBUG \"-g -gsplit-dwarf\")\n</code></pre> <p>This is particularly useful for g++ where debug builds can exceed 1 GB without it.</p>"},{"location":"packaging/cmake/","title":"CMake","text":"<p>For more complex C++ extensions, you will likely want to use <code>CMake</code> to build your extension. <code>CMake</code> has a number of advantages over <code>extconf.rb</code>:</p> <ul> <li>It is probably the build system the library you are wrapping uses</li> <li>Provides built-in functionality for finding installed modules (like Ruby!)</li> <li>Provides much more control over the build process</li> <li>Parallelizes builds resulting in much faster compilation times compared to <code>make</code></li> </ul> <p>Getting up to speed with CMake can be daunting, so the bitmap-plus-plus gem includes a fully documented CMake based build system as well as GitHub actions to run tests.  The example shows how to:</p> <ul> <li>Fetch Rice headers via <code>FetchContent</code></li> <li>Using <code>Ruby::Module</code> for extension modules</li> <li>Using <code>Rice::Rice</code> for Rice headers</li> <li>Setting the correct extension suffix</li> <li>Configuring output directories</li> </ul>"},{"location":"packaging/cmake/#cmakeliststxt","title":"CMakeLists.txt","text":"<p>The first step in using CMake is to create a CMakeLists.txt file. Start by copying the one from the <code>bitmap-plus-plus</code> gem. It automatically downloads the latest version of <code>FindRuby.cmake</code> as well as the Rice header files (make sure to set the git tag setting to the version of Rice you want to use!).</p> <p>Next, tell Ruby gems to use CMake to build your gem by adding the following to your Gemspec (assuming the extension directory is <code>ext</code>):</p> <pre><code>Gem::Specification.new do |spec|\n  spec.extensions = [\"ext/CMakeLists.txt\"]\nend\n</code></pre> <p>RubyGems 4.0 and later include much improved CMake support, with improvements contributed by the Rice project.</p> <p>If you are using an older version of RubyGems (&lt; 4.0), Rice will automatically patch RubyGems to add improved CMake support. This is done via the rubygems_plugin.rb file which uses RubyGem's plugin system. To enable this, you must install the Rice gem. That is easy to accomplish by incluing it as a dependency in your gemspec:</p> <pre><code>Gem::Specification.new do |spec|\n  spec.add_runtime_dependency('rice')\nend\n</code></pre>"},{"location":"packaging/cmake/#cmakepresetsjson","title":"CMakePresets.json","text":"<p>Next, it is recommended to add a CMakePresets.json to your gem. A <code>CMakePresets.json</code> makes it easier to define all the compiler settings your gem will need to build with commonly used operating systems and compilers.</p> <p>Once again, the bitmap-plus-plus gem includes an example that you can copy. It includes the following presets:</p> <ul> <li><code>linux-debug</code> / <code>linux-release</code> - Linux with GCC</li> <li><code>macos-debug</code> / <code>macos-release</code> - macOS with Clang</li> <li><code>msvc-debug</code> / <code>msvc-release</code> - Windows with MSVC</li> <li><code>clang-windows-debug</code> / <code>clang-windows-release</code> - Windows with Clang</li> <li><code>mingw-debug</code> / <code>mingw-release</code> - Windows with MinGW</li> </ul> <p>To use a preset:</p> <pre><code># Configure using a preset\ncmake --preset macos-debug\n\n# Build using a preset\ncmake --build --preset macos-debug\n</code></pre>"},{"location":"packaging/cmake/#installation","title":"Installation","text":"<p>When users install your gem, make sure to document how to select a preset. For example, for bitmap-plus-plus</p> <pre><code>gem install bitmap-plus-plus --preset macos-release|linux-release|mingw-release\n</code></pre>"},{"location":"packaging/cmake/#findruby","title":"FindRuby","text":"<p><code>FindRuby.cmake</code> is what enables CMake to work with Ruby. Its job is to find all locally installed versions of Ruby, including:</p> <ul> <li>RVM virtual environments</li> <li>RbENV virtual environments</li> <li>Homewbrew installed Ruby (both Apple Silicon and Intel Macs)</li> <li>System Ruby</li> </ul> <p>It is invoked by adding the following code in your <code>CMakeLists.txt</code> file:</p> <pre><code>find_package(\"Ruby\")\n</code></pre> <p>CMake comes bundled with <code>FindRuby</code>. However, older versions do not include support for RbEnv, Homebrew or CMake targets (all of which have been contributed upstream to CMake by the Rice project).</p> <p>Therefore, the example <code>CMakeLists.txt</code> file automatically downloads the latest version of <code>FindRuby.cmake</code> from the Rice github repository. In addition, it also downloads the latest version of <code>Rice.make</code> which makes it easy to include the Rice header files in your project.</p>"},{"location":"packaging/cmake/#findruby-imported-targets","title":"FindRuby Imported Targets","text":"<p>Rice's <code>FindRuby.cmake</code> provides modern CMake targets, including:</p> Target Description <code>Ruby::Interpreter</code> Ruby interpreter executable <code>Ruby::Module</code> For building Ruby extensions <code>Ruby::Ruby</code> For embedding Ruby in C/C++ applications. <p>For building Ruby extensions, use <code>Ruby::Module</code>:</p> <p><pre><code>target_link_libraries(MyExtension PRIVATE Ruby::Module)\n</code></pre> Once again, refer to the example CMakeLists.txt for an example.</p>"},{"location":"packaging/cmake/#findruby-variables","title":"FindRuby Variables","text":"<p>The following CMake variables are set by FindRuby:</p> Variable Description Ruby_VERSION_MAJOR Ruby major version Ruby_VERSION_MINOR Ruby minor version Ruby_VERSION_PATCH Ruby patch version Ruby_ARCH_DIR Ruby arch dir Ruby_HDR_DIR Ruby header dir (1.9+) Ruby_ARCHHDR_DIR Ruby arch header dir (2.0+) Ruby_RUBY_LIB_DIR Ruby ruby-lib dir Ruby_SITEARCH_DIR Ruby site arch dir Ruby_SITELIB_DIR Ruby site lib dir Ruby_EXECUTABLE Ruby interpreter Ruby_LIBRARY Ruby shared library Ruby_INCLUDE_DIR Ruby include directory Ruby_CONFIG_INCLUDE_DIR Ruby config include directory Ruby_INCLUDE_DIRS Include and config directories"},{"location":"packaging/cmake/#ricecmake","title":"Rice.cmake","text":"<p>Rice provides the <code>Rice::Rice</code> imported target for including Rice headers:</p> <pre><code>target_link_libraries(MyExtension PRIVATE Rice::Rice)\n</code></pre> <p>This target:</p> <ul> <li>Adds Rice include directories</li> <li>Requires C++17 or higher</li> </ul>"},{"location":"packaging/documentation/","title":"Documentation","text":"<p>Rice provides a documentation generator that creates Markdown files suitable for use with MkDocs or similar static site generators. The generator uses Rice's Ruby API to extract information about your extension's classes, modules, methods, and attributes.</p> <p>A key feature of the documentation generator is its ability to link your Ruby API documentation to the original C++ documentation. This is done through configurable \"resolvers\" that know how to find documentation URLs for different types of C++ libraries.</p> <p>Resolvers are configured per namespace (ie, Ruby module).</p>"},{"location":"packaging/documentation/#requirements","title":"Requirements","text":"<p>The documentation generator requires the <code>libxml-ruby</code> gem:</p> <pre><code>gem install libxml-ruby\n</code></pre> <p>You must also enable the introspection API in your extension.</p>"},{"location":"packaging/documentation/#configuration-file","title":"Configuration File","text":"<p>The <code>rice-doc</code> tool uses a YAML configuration file to specify the extension to document and how to resolve documentation links. This approach is used because the configuration, particularly method name mappings, can be extensive.</p> <p>Here is a minimal configuration file:</p> <pre><code>extension: path/to/my_extension.so\noutput: ./docs/api\n\nnamespaces:\n  Std:\n    resolver: cppreference\n</code></pre> <p>Note: Ruby core types (<code>String</code>, <code>Array</code>, <code>Integer</code>, etc.) are automatically linked to https://docs.ruby-lang.org without any configuration.</p>"},{"location":"packaging/documentation/#configuration-options","title":"Configuration Options","text":"<p>extension   The path to your compiled Rice extension library. This will be a <code>.so</code> file on Linux, <code>.bundle</code> on macOS, or <code>.so</code> on Windows.</p> <p>output   The directory where generated Markdown files will be written. The directory will be created if it does not exist.</p> <p>namespaces   A mapping of namespace names to resolver configurations.</p>"},{"location":"packaging/documentation/#running-rice-doc","title":"Running rice-doc","text":"<p>To generate documentation:</p> <pre><code>rice-doc config.yaml\n</code></pre> <p>Use <code>rice-doc --help</code> to see all options.</p>"},{"location":"packaging/documentation/#resolvers","title":"Resolvers","text":"<p>Resolvers are responsible for generating URLs that link your Ruby API documentation to external documentation sources. Rice includes several built-in resolvers.</p>"},{"location":"packaging/documentation/#ruby-resolver-automatic","title":"Ruby Resolver (Automatic)","text":"<p>Ruby core classes are automatically linked to the official Ruby documentation at https://docs.ruby-lang.org. This resolver is always enabled and requires no configuration.</p> <p>Classes like <code>String</code>, <code>Array</code>, <code>Integer</code>, <code>Hash</code>, and other Ruby built-in types will automatically have links to their documentation.</p>"},{"location":"packaging/documentation/#cppreference-resolver","title":"CppReference Resolver","text":"<p>The CppReference resolver links C++ standard library classes to https://en.cppreference.com.</p> <pre><code>namespaces:\n  Std:\n    resolver: cppreference\n</code></pre> <p>This resolver requires no additional configuration. It automatically looks up classes in the <code>std</code> namespace and generates appropriate links.</p> <p>Use this resolver for the <code>Std</code> namespace if your extension wraps STL types like <code>std::vector</code>, <code>std::map</code>, or <code>std::string</code>.</p>"},{"location":"packaging/documentation/#doxygen-resolver","title":"Doxygen Resolver","text":"<p>The Doxygen resolver links classes and methods to documentation generated by Doxygen. This is useful when wrapping C++ libraries that provide Doxygen-generated documentation.</p> <pre><code>namespaces:\n  MyNamespace:\n    resolver: doxygen\n    root: https://example.com/docs\n    tagfile: https://example.com/docs/tagfile.xml\n    type_mappings:\n      - pattern: \"^enum\\\\s*\"\n        replacement: \"\"\n    method_mappings:\n      MyNamespace::MyClass:\n        ruby_method_name: cppMethodName\n</code></pre> <p>Configuration options:</p> <p>root   The base URL of the Doxygen documentation.</p> <p>tagfile   The URL or local path to the Doxygen tag file. Doxygen can generate this file with the <code>GENERATE_TAGFILE</code> option.</p> <p>type_mappings (optional)   A list of pattern/replacement pairs for transforming C++ type names. Each entry has:</p> <ul> <li><code>pattern</code> - A regular expression pattern (case-insensitive)</li> <li><code>replacement</code> - The replacement string (use empty string <code>\"\"</code> to remove matches)</li> </ul> <p>Common uses include stripping <code>enum</code> or <code>union</code> prefixes and removing template parameters.</p> <p>method_mappings (optional)   A mapping of class names to method name mappings. This is used when Ruby method names differ significantly from C++ method names due to naming convention differences.</p> <p>The outer key is the fully-qualified Ruby class name. The inner mapping is from Ruby method name to C++ method name.</p>"},{"location":"packaging/documentation/#rice-resolver","title":"Rice Resolver","text":"<p>The Rice resolver links Rice's own types (like <code>Buffer</code> and <code>Pointer</code>) to the Rice documentation.</p> <pre><code>namespaces:\n  Rice:\n    resolver: rice\n</code></pre>"},{"location":"packaging/documentation/#complete-example","title":"Complete Example","text":"<p>Here is a complete configuration file for documenting an OpenCV wrapper:</p> <pre><code>extension: opencv\noutput: ./docs/api\n\n# Note: Ruby core types are automatically linked\n\nnamespaces:\n  # C++ standard library\n  Std:\n    resolver: cppreference\n\n  # Rice types\n  Rice:\n    resolver: rice\n\n  # OpenCV\n  Cv:\n    resolver: doxygen\n    root: https://docs.opencv.org/4.x\n    tagfile: https://docs.opencv.org/4.x/opencv.tag\n\n    type_mappings:\n      - pattern: \"^enum\\\\s*\"\n        replacement: \"\"\n      - pattern: \"^union\\\\s*\"\n        replacement: \"\"\n      - pattern: \"&lt;.*&gt;\"\n        replacement: \"\"\n\n    method_mappings:\n      Cv:\n        gaussian_blur: GaussianBlur\n        hough_circles: HoughCircles\n        hough_lines: HoughLines\n\n      Cv::Mat:\n        locate_roi: locateROI\n\n      Cv::Cuda::GpuMat:\n        adjust_roi: adjustROI\n        locate_roi: locateROI\n</code></pre>"},{"location":"packaging/documentation/#method-name-mappings","title":"Method Name Mappings","text":"<p>When Rice wraps a C++ library, it often converts C++ method names to follow Ruby naming conventions. For example:</p> <ul> <li><code>GaussianBlur</code> becomes <code>gaussian_blur</code></li> <li><code>getCPUTickCount</code> becomes <code>get_cpu_tick_count</code></li> <li><code>isEmpty</code> becomes <code>empty?</code></li> </ul> <p>The Doxygen resolver attempts to automatically convert Ruby names back to C++ names using common patterns, but this does not always work. The <code>method_mappings</code> configuration allows you to specify explicit mappings for cases where automatic conversion fails.</p> <p>Common patterns that require explicit mappings:</p> <ul> <li>Acronyms: <code>get_cpu_tick_count</code> -&gt; <code>getCPUTickCount</code></li> <li>Capitalized names: <code>gaussian_blur</code> -&gt; <code>GaussianBlur</code></li> <li>Unconventional naming: <code>psnr</code> -&gt; <code>PSNR</code></li> </ul>"},{"location":"packaging/documentation/#output-structure","title":"Output Structure","text":"<p>The generator creates a directory structure that mirrors your Ruby namespace hierarchy:</p> <pre><code>docs/api/\n  MyNamespace/\n    index.md           # Module documentation\n    MyClass.md         # Class documentation\n    SubNamespace/\n      AnotherClass.md\n</code></pre> <p>Each generated Markdown file contains:</p> <ul> <li>Class or module name with link to C++ documentation</li> <li>Singleton methods</li> <li>Constructors</li> <li>Attributes (with read/write indicators)</li> <li>Instance methods</li> </ul> <p>Method signatures include parameter names, types, and return types, with links to documentation for each type where available.</p>"},{"location":"packaging/documentation/#mkdocs-setup","title":"MkDocs Setup","text":"<p>The generated documentation is designed to work with MkDocs and the mkdocs-awesome-pages-plugin. The generator creates <code>.pages</code> files in each directory that control navigation ordering.</p>"},{"location":"packaging/documentation/#installation","title":"Installation","text":"<p>Install MkDocs and the required plugins:</p> <pre><code>pip install mkdocs mkdocs-material mkdocs-awesome-pages-plugin\n</code></pre>"},{"location":"packaging/documentation/#configuration","title":"Configuration","text":"<p>Create or update your <code>mkdocs.yml</code> file:</p> <pre><code>site_name: My Extension Documentation\n\ntheme:\n  name: material\n\nplugins:\n  - search\n  - awesome-pages\n</code></pre> <p>The <code>awesome-pages</code> plugin reads the <code>.pages</code> files generated by <code>rice-doc</code> to automatically build the navigation. You do not need a <code>nav</code> section in <code>mkdocs.yml</code> when using this plugin.</p>"},{"location":"packaging/documentation/#how-pages-files-work","title":"How .pages Files Work","text":"<p>The <code>rice-doc</code> generator creates a <code>.pages</code> file in each output directory. These files specify the navigation order:</p> <pre><code>nav:\n  - index.md\n  - ClassA.md\n  - ClassB.md\n  - SubNamespace\n</code></pre> <p>Key behaviors:</p> <ul> <li><code>index.md</code> is always listed first (if present)</li> <li>All other entries are sorted alphabetically</li> <li>Subdirectories are included, allowing nested navigation</li> </ul>"},{"location":"packaging/documentation/#building-the-documentation","title":"Building the Documentation","text":"<p>Generate your API documentation and build the site:</p> <pre><code># Generate API docs from your extension\nrice-doc config.yaml\n\n# Build the MkDocs site\nmkdocs build\n\n# Or serve locally for development\nmkdocs serve\n</code></pre>"},{"location":"packaging/documentation/#integrating-with-existing-documentation","title":"Integrating with Existing Documentation","text":"<p>If you have existing documentation, place the generated API docs in a subdirectory:</p> <pre><code># config.yaml\nextension: my_extension.so\noutput: ./docs/api\n</code></pre> <p>The <code>rice-doc</code> tool generates <code>.pages</code> files in the output directory and all its subdirectories. However, you must manually create a <code>.pages</code> file in your <code>docs/</code> root directory to control the top-level navigation:</p> <pre><code># docs/.pages\nnav:\n  - index.md\n  - tutorial.md\n  - api\n</code></pre> <p>The <code>awesome-pages</code> plugin requires a <code>.pages</code> file in each folder to determine navigation order. Without a <code>.pages</code> file in the root <code>docs/</code> directory, the plugin won't know how to integrate your existing documentation with the generated API reference.</p>"},{"location":"packaging/extconf.rb/","title":"extconf.rb","text":"<p>The default way to build <code>RubyGem</code> extensions is to use <code>extconf.rb</code>. However, <code>extconf.rb</code> was designed for <code>C</code> and not <code>C++</code>. Thus, Rice provides a file called <code>mkmf-rice</code> that adds additional functionality to <code>mkmf</code> including:</p> <ul> <li>Uses a C++ compiler instead of a C compiler</li> <li>Includes Rice header files automatically</li> <li>Sets required compiler settings</li> <li>Links to the standard C++ library</li> </ul>"},{"location":"packaging/extconf.rb/#enabling","title":"Enabling","text":"<p>To build your extension using <code>extconf.rb</code>, add the following to your Gemspec (assuming the extension directory is <code>ext</code>):</p> <pre><code>Gem::Specification.new do |spec|\n  spec.extensions = [\"ext/extconf.rb\"]\nend\n</code></pre>"},{"location":"packaging/extconf.rb/#example","title":"Example","text":"<p>Below is an example <code>extconf.rb</code>:</p> <pre><code>require 'mkmf-rice'\n\ndir_config('...')\nhave_library('...')\ncreate_makefile('my_extension')\n</code></pre>"},{"location":"packaging/extconf.rb/#disadvantages","title":"Disadvantages","text":"<p>Although <code>extconf.rb</code> is widely used to build Ruby extensions, it is not designed for C++. This means it can be tricky to get it to work for C++ extensions.</p> <p>Another disadvantage is that <code>extconf.rb</code> creates a <code>Makefile</code> that is then built either by <code>make</code> or <code>nmake</code>. By default, <code>make</code> will only compile a single file at a time. For larger C++ extensions, such as <code>ruby-opencv</code> this results in very long compilation times.</p> <p>For larger projects, it is strongly recommended to use CMake.</p>"},{"location":"packaging/packaging/","title":"Overview","text":"<p>Once you have wrapped a C++ library, the next step is to package it as a RubyGem. As part of the RubyGem, you should either include a pre-built binary or enable the extension to be built upon installation.</p> <p>This is done via the <code>extensions</code> field in a Gemspec:</p> <pre><code>Gem::Specification.new do |spec|\n  spec.extensions = [\"ext/CMakeLists.txt\"]\nend\n</code></pre> <p>The name of the file determines what extension builder <code>RubyGems</code> invokes on installation. There are two built-in choices:</p> <ul> <li>extconf.rb - uses extconf.rb</li> <li>CMakeLists.txt - uses CMake</li> </ul> <p>Almost all <code>RubyGems</code> that build extensions use extconf.rb, so you will find extensive documentation on how to use it. In contrast, very few, if any, <code>RubyGems</code> use CMake. Thus you will not find any documentation outside of what Rice provides.</p> <p>In general, for simple extensions use <code>extconf.rb</code> but otherwise use <code>CMake</code>.</p> <p>It is also possible to use a custom build system, but in that case you will need to create a RubyGem plugin to tell <code>RubyGems</code> how to make the build.</p>"},{"location":"packaging/packaging/#header-files","title":"Header Files","text":"<p>Rice is packaged as header-only library. That means you do not have to worry about linking a shared Rice library with your extension.</p> <p>The two headers are:</p> <ul> <li>rice/rice.hpp</li> <li>rice/stl.hpp</li> </ul> <p>There are two ways to incorporate the headers into your build.</p> <p>The first option is to install them by installing Rice - thus make Rice a required dependency of your Gem like this:</p> <pre><code>Gem::Specification.new do |spec|\n  spec.add_runtime_dependency('rice')\nend\n</code></pre> <p>The second option is to simply copy them from github and copy them into your repo. Remember the provided link points to the master branch - you should pick a specific release tag and use those instead.</p> <p>For information about required compiler and linker settings, see Build Settings.</p>"},{"location":"packaging/rbs/","title":"RBS Signature Files","text":"<p>Ruby 3.0 added support for signature files, known as RBS files. RBS is a language that describes the structure of a Ruby program including its type information.</p> <p>Rice of course knows a lot about your extension's types! Starting with Rice 4.7, this information is available to Ruby via the Ruby API when it is enabled.</p>"},{"location":"packaging/rbs/#generating-rbs-files","title":"Generating RBS Files","text":"<p>Use the <code>rice-rbs</code> script in the bin folder to generate RBS files for your extension.</p> <p>To run it:</p> <pre><code>rice-rbs [options] &lt;rice_extension_library&gt;\n\nOptions:\n  -o, --output=path                Output directory\n  -v, --version                    Show version (1.1.0)\n  -h, --help                       Show help message\n</code></pre> <p>The <code>rice_extension_library</code> should be the path to a compiled version of your extension. This will be a <code>so</code> file on Windows and Linux and a <code>bundle</code> on MacOS.</p>"},{"location":"ruby_api/arg/","title":"Arg","text":"<pre><code>Rice::Arg\n</code></pre> <p><code>Rice::Arg</code> provides access to argument metadata that was passed to Rice's <code>define_function</code> and <code>define_method</code> calls. This includes the parameter name specified in the C++ binding code.</p>"},{"location":"ruby_api/arg/#instance-methods","title":"Instance Methods","text":""},{"location":"ruby_api/arg/#name-string","title":"name \u2192 String","text":"<p>Returns the name of the argument.</p> <p>Returns:</p> <p>The argument name as a String, or <code>nil</code> if no name was specified.</p> <p>Description:</p> <p>The name comes from the <code>Arg</code> objects passed to Rice's method definition functions:</p> <pre><code>// C++ binding code\ndefine_method(\"calculate\", &amp;MyClass::calculate,\n  Arg(\"x\"), Arg(\"y\"));  // Names \"x\" and \"y\" are accessible via introspection\n</code></pre> <pre><code># Ruby introspection\nnative = Rice::Registries.instance.natives.native_methods(MyClass).first\nnative.parameters.each do |param|\n  puts param.arg.name  #=&gt; \"x\", \"y\"\nend\n</code></pre>"},{"location":"ruby_api/arg/#example","title":"Example","text":"<pre><code># Generate method signatures with named parameters\ndef method_signature(native)\n  params = native.parameters.map do |param|\n    name = param.arg.name || \"_\"\n    type = param.klass.name\n    \"#{name}: #{type}\"\n  end.join(\", \")\n\n  ret = native.return_type&amp;.name || \"void\"\n  \"def #{native.name}(#{params}) -&gt; #{ret}\"\nend\n\nregistry = Rice::Registries.instance.natives\nregistry.native_methods(MyClass).each do |method|\n  puts method_signature(method)\nend\n\n# Output:\n#   def calculate(x: Integer, y: Integer) -&gt; Integer\n#   def process(data: String) -&gt; Array\n</code></pre>"},{"location":"ruby_api/arg/#see-also","title":"See Also","text":"<ul> <li>Parameter - Parameter that contains the Arg</li> <li>Native - Native wrapper for methods and functions</li> </ul>"},{"location":"ruby_api/buffer/","title":"Buffer","text":"<pre><code>Rice::Buffer&lt;T&gt;\n</code></pre> <p><code>Rice::Buffer&lt;T&gt;</code> manages contiguous blocks of memory containing C++ values. Buffers enable Ruby code to create, read, and manipulate memory that can be passed to C++ APIs expecting pointers or arrays.</p> <p>Rice automatically generates <code>Buffer&lt;T&gt;</code> classes for fundamental types (<code>int</code>, <code>double</code>, etc.) when it detects C++ APIs that use pointers. For wrapped types, you may need to use <code>ArgBuffer</code> to tell Rice to generate the appropriate Buffer class.</p> <p>See Buffers for usage examples.</p>"},{"location":"ruby_api/buffer/#public-class-methods","title":"Public Class Methods","text":""},{"location":"ruby_api/buffer/#newvalue-buffer","title":"new(value) \u2192 Buffer","text":"<p>Creates a new buffer from a Ruby value.</p> <p>Parameters:</p> <ul> <li><code>value</code> - A Ruby Array, String, or single value to convert to a buffer.</li> </ul> <p>Returns:</p> <p>A new Buffer instance that owns the allocated memory.</p> <p>Examples:</p> <pre><code># From an array of integers\nbuffer = Rice::Buffer&lt;int&gt;.new([1, 2, 3, 4, 5])\n\n# From a string (for char buffers)\nbuffer = Rice::Buffer&lt;char&gt;.new(\"hello\")\n\n# From a single value\nbuffer = Rice::Buffer&lt;double&gt;.new(3.14)\n</code></pre>"},{"location":"ruby_api/buffer/#newvalue-size-buffer","title":"new(value, size) \u2192 Buffer","text":"<p>Creates a new buffer from a Ruby value with an explicit size.</p> <p>Parameters:</p> <ul> <li><code>value</code> - A Ruby Array, String, Pointer, or single value.</li> <li><code>size</code> - The number of elements in the buffer.</li> </ul> <p>Returns:</p> <p>A new Buffer instance.</p> <p>Description:</p> <p>The <code>size</code> parameter is primarily used when creating a buffer from a <code>Pointer</code>, since pointers do not carry size information.</p> <p>Examples:</p> <pre><code># Create buffer from pointer with known size\nbuffer = Rice::Buffer&lt;int&gt;.new(pointer, 10)\n</code></pre>"},{"location":"ruby_api/buffer/#public-instance-methods","title":"Public Instance Methods","text":""},{"location":"ruby_api/buffer/#size-integer","title":"size \u2192 Integer","text":"<p>Returns the number of elements in the buffer.</p> <p>Returns:</p> <p>The number of elements (not bytes) in the buffer.</p> <p>Examples:</p> <pre><code>buffer = Rice::Buffer&lt;int&gt;.new([1, 2, 3, 4, 5])\nbuffer.size  #=&gt; 5\n</code></pre>"},{"location":"ruby_api/buffer/#to_s-string","title":"to_s \u2192 String","text":"<p>Returns a human-readable description of the buffer.</p> <p>Returns:</p> <p>A string describing the buffer's type and size.</p> <p>Examples:</p> <pre><code>buffer = Rice::Buffer&lt;int&gt;.new([1, 2, 3])\nbuffer.to_s  #=&gt; \"Buffer&lt;type: int*, size: 3&gt;\"\n</code></pre>"},{"location":"ruby_api/buffer/#bytes-string","title":"bytes \u2192 String","text":"<p>Returns the raw bytes of the buffer as a binary-encoded Ruby string.</p> <p>Returns:</p> <p>A String with binary encoding containing the buffer's raw memory. Returns <code>nil</code> if the buffer is empty.</p> <p>Description:</p> <p>The size of the returned string is <code>size * sizeof(T)</code> bytes. The buffer's <code>size</code> must be set for this method to work correctly.</p> <p>Examples:</p> <pre><code>buffer = Rice::Buffer&lt;int&gt;.new([1, 2, 3])\nbuffer.bytes  #=&gt; \"\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x03\\x00\\x00\\x00\"\n</code></pre>"},{"location":"ruby_api/buffer/#bytescount-string","title":"bytes(count) \u2192 String","text":"<p>Returns the raw bytes for the first <code>count</code> elements.</p> <p>Parameters:</p> <ul> <li><code>count</code> - The number of elements to include.</li> </ul> <p>Returns:</p> <p>A String with binary encoding containing <code>count * sizeof(T)</code> bytes.</p> <p>Examples:</p> <pre><code>buffer = Rice::Buffer&lt;int&gt;.new([1, 2, 3, 4, 5])\nbuffer.bytes(2)  #=&gt; \"\\x01\\x00\\x00\\x00\\x02\\x00\\x00\\x00\"\n</code></pre>"},{"location":"ruby_api/buffer/#to_ary-array","title":"to_ary \u2192 Array","text":"<p>Converts the buffer to a Ruby Array.</p> <p>Returns:</p> <p>An Array containing the buffer's elements converted to Ruby objects. Returns <code>nil</code> if the buffer is empty.</p> <p>Description:</p> <p>The buffer's <code>size</code> must be set for this method to work correctly.</p> <p>Examples:</p> <pre><code>buffer = Rice::Buffer&lt;int&gt;.new([1, 2, 3])\nbuffer.to_ary  #=&gt; [1, 2, 3]\n</code></pre>"},{"location":"ruby_api/buffer/#to_arycount-array","title":"to_ary(count) \u2192 Array","text":"<p>Converts the first <code>count</code> elements to a Ruby Array.</p> <p>Parameters:</p> <ul> <li><code>count</code> - The number of elements to include.</li> </ul> <p>Returns:</p> <p>An Array containing <code>count</code> elements.</p> <p>Examples:</p> <pre><code>buffer = Rice::Buffer&lt;int&gt;.new([1, 2, 3, 4, 5])\nbuffer.to_ary(3)  #=&gt; [1, 2, 3]\n</code></pre>"},{"location":"ruby_api/buffer/#index-object","title":"<code>[](index)</code> \u2192 Object","text":"<p>Returns the element at the specified index.</p> <p>Parameters:</p> <ul> <li><code>index</code> - The zero-based index of the element.</li> </ul> <p>Returns:</p> <p>The element at the given index.</p> <p>Raises:</p> <p><code>IndexError</code> if the index is out of bounds.</p> <p>Examples:</p> <pre><code>buffer = Rice::Buffer&lt;int&gt;.new([10, 20, 30])\nbuffer[0]  #=&gt; 10\nbuffer[2]  #=&gt; 30\n</code></pre>"},{"location":"ruby_api/buffer/#index-value-value","title":"<code>[]=(index, value)</code> \u2192 value","text":"<p>Sets the element at the specified index.</p> <p>Parameters:</p> <ul> <li><code>index</code> - The zero-based index of the element.</li> <li><code>value</code> - The new value.</li> </ul> <p>Returns:</p> <p>The assigned value.</p> <p>Raises:</p> <p><code>IndexError</code> if the index is out of bounds.</p> <p>Description:</p> <p>This method is only available for non-const, copy-assignable types.</p> <p>Examples:</p> <pre><code>buffer = Rice::Buffer&lt;int&gt;.new([10, 20, 30])\nbuffer[1] = 25\nbuffer[1]  #=&gt; 25\n</code></pre>"},{"location":"ruby_api/buffer/#data-pointer","title":"data \u2192 Pointer","text":"<p>Returns a <code>Pointer&lt;T&gt;</code> to the buffer's memory.</p> <p>Returns:</p> <p>A <code>Pointer&lt;T&gt;</code> instance pointing to the buffer's internal memory.</p> <p>Description:</p> <p>Use this method to pass the buffer to C++ APIs that expect pointers. The buffer retains ownership of the memory.</p> <p>Examples:</p> <pre><code>buffer = Rice::Buffer&lt;uint8_t&gt;.new([1, 2, 3, 4])\nmatrix = Matrix.new(2, 2, buffer.data)\n</code></pre>"},{"location":"ruby_api/buffer/#release-pointer","title":"release \u2192 Pointer","text":"<p>Returns a <code>Pointer&lt;T&gt;</code> and releases ownership of the memory.</p> <p>Returns:</p> <p>A <code>Pointer&lt;T&gt;</code> instance pointing to the buffer's internal memory.</p> <p>Description:</p> <p>After calling <code>release</code>, the buffer no longer owns the memory and will not free it when garbage collected. Use this when passing memory to C++ APIs that take ownership.</p> <p>Examples:</p> <pre><code>buffer = Rice::Buffer&lt;uint8_t&gt;.new([1, 2, 3, 4])\n# C++ API takes ownership of the memory\nmatrix = Matrix.new(2, 2, buffer.release)\n</code></pre>"},{"location":"ruby_api/buffer/#memory-management","title":"Memory Management","text":"<p>Buffers manage their own memory by default. When a Buffer is created from a Ruby Array or String, it allocates new memory and copies the data. When the Buffer is garbage collected, it frees this memory.</p> <p>When a Buffer is created from a <code>Pointer</code>, it does not own the memory and will not free it.</p> <p>Use <code>release</code> to transfer ownership of the memory to a C++ API. After calling <code>release</code>, the buffer will not free the memory when garbage collected.</p> <p>Important: Ensure that either the Buffer or the C++ code owns the memory, but not both. Double-free errors will occur if both attempt to free the same memory.</p>"},{"location":"ruby_api/buffer/#see-also","title":"See Also","text":"<ul> <li>Pointer - Lightweight pointer wrapper</li> <li>Buffers - Buffer usage guide</li> </ul>"},{"location":"ruby_api/native/","title":"Native","text":"<pre><code>Rice::Native\n</code></pre> <p><code>Rice::Native</code> wraps C++ functions, methods, attributes, and procedures. Each wrapped C++ callable has a corresponding Native instance that provides introspection capabilities.</p>"},{"location":"ruby_api/native/#nativekind-enum","title":"NativeKind Enum","text":"<p><code>Rice::NativeKind</code> distinguishes between different types of natives:</p> <ul> <li><code>Function</code> - A class/module-level function (<code>define_function</code>, <code>define_singleton_function</code>)</li> <li><code>Method</code> - An instance method (<code>define_method</code>)</li> <li><code>AttributeReader</code> - A getter attribute (<code>define_attr</code>)</li> <li><code>AttributeWriter</code> - A setter attribute (<code>define_attr</code>)</li> <li><code>Proc</code> - A Ruby proc or lambda</li> </ul>"},{"location":"ruby_api/native/#instance-methods","title":"Instance Methods","text":""},{"location":"ruby_api/native/#name-string","title":"name \u2192 String","text":"<p>Returns the Ruby name of the wrapped function, method, attribute, or proc.</p> <p>Returns:</p> <p>The method name as a String.</p> <pre><code>native = Rice::Registries.instance.natives.native_methods(MyClass).first\nputs native.name  #=&gt; \"calculate\"\n</code></pre>"},{"location":"ruby_api/native/#kind-nativekind","title":"kind \u2192 NativeKind","text":"<p>Returns the kind of the Native object.</p> <p>Returns:</p> <p>A <code>Rice::NativeKind</code> enum value.</p> <pre><code>native = Rice::Registries.instance.natives.lookup(MyClass).first\n\ncase native.kind\nwhen Rice::NativeKind::Function\n  puts \"#{native.name} is a class/module function\"\nwhen Rice::NativeKind::Method\n  puts \"#{native.name} is an instance method\"\nwhen Rice::NativeKind::AttributeReader\n  puts \"#{native.name} is a getter\"\nwhen Rice::NativeKind::AttributeWriter\n  puts \"#{native.name} is a setter\"\nend\n</code></pre>"},{"location":"ruby_api/native/#return_type-class","title":"return_type \u2192 Class","text":"<p>Returns the Ruby class representing the return type.</p> <p>Returns:</p> <p>The Ruby Class that the method returns, or <code>nil</code> for void methods.</p> <pre><code>native = Rice::Registries.instance.natives.native_methods(MyClass).first\nputs \"#{native.name} returns #{native.return_type}\"  #=&gt; \"calculate returns Integer\"\n</code></pre>"},{"location":"ruby_api/native/#parameters-array","title":"parameters \u2192 Array","text":"<p>Returns the parameters for the function or method.</p> <p>Returns:</p> <p>An Array of Parameter objects.</p> <pre><code>native = Rice::Registries.instance.natives.native_methods(MyClass).first\nnative.parameters.each do |param|\n  puts \"  #{param.arg.name}: #{param.klass}\"\nend\n</code></pre>"},{"location":"ruby_api/native/#to_s-string","title":"to_s \u2192 String","text":"<p>Returns a human-readable description of the Native instance.</p> <p>Returns:</p> <p>A String describing the native.</p> <pre><code>native = Rice::Registries.instance.natives.native_methods(MyClass).first\nputs native.to_s\n</code></pre>"},{"location":"ruby_api/native/#example","title":"Example","text":"<pre><code># Generate method signatures for a class\ndef print_method_signatures(klass)\n  registry = Rice::Registries.instance.natives\n\n  puts \"#{klass.name}\"\n  puts \"=\" * klass.name.length\n\n  # Instance methods\n  methods = registry.native_methods(klass).group_by(&amp;:name)\n  methods.each do |name, overloads|\n    overloads.each do |method|\n      params = method.parameters.map do |p|\n        \"#{p.arg.name}: #{p.klass.name}\"\n      end.join(\", \")\n      ret = method.return_type&amp;.name || \"void\"\n      puts \"  def #{name}(#{params}) -&gt; #{ret}\"\n    end\n  end\n\n  # Class functions\n  functions = registry.native_functions(klass).group_by(&amp;:name)\n  functions.each do |name, overloads|\n    overloads.each do |func|\n      params = func.parameters.map do |p|\n        \"#{p.arg.name}: #{p.klass.name}\"\n      end.join(\", \")\n      ret = func.return_type&amp;.name || \"void\"\n      puts \"  def self.#{name}(#{params}) -&gt; #{ret}\"\n    end\n  end\n\n  # Attributes\n  attrs = registry.native_attributes(klass)\n  readers = attrs.select { |a| a.kind == Rice::NativeKind::AttributeReader }\n  readers.each do |attr|\n    puts \"  attr_reader :#{attr.name}  # -&gt; #{attr.return_type&amp;.name}\"\n  end\nend\n\nprint_method_signatures(MyClass)\n</code></pre>"},{"location":"ruby_api/native/#see-also","title":"See Also","text":"<ul> <li>NativeRegistry - Registry that provides Native objects</li> <li>Parameter - Parameter information</li> <li>Arg - Argument metadata</li> </ul>"},{"location":"ruby_api/native_registry/","title":"NativeRegistry","text":"<pre><code>Rice::NativeRegistry\n</code></pre> <p><code>Rice::NativeRegistry</code> provides access to all C++ functions, methods, procs, and attributes wrapped by Ruby classes. It is accessed through Registries.</p>"},{"location":"ruby_api/native_registry/#instance-methods","title":"Instance Methods","text":""},{"location":"ruby_api/native_registry/#lookupklass-array","title":"lookup(klass) \u2192 Array","text":"<p>Returns an array of all natives for a class.</p> <p>Parameters:</p> <ul> <li><code>klass</code> - The Ruby class to look up.</li> </ul> <p>Returns:</p> <p>An Array of Native objects representing wrapped C++ functions, methods, attributes, and procs.</p> <p>Description:</p> <p>This is a low-level API implemented in C++. For most use cases, prefer the convenience methods below.</p> <pre><code>natives = Rice::Registries.instance.natives.lookup(MyClass)\nnatives.each { |native| puts native.name }\n</code></pre>"},{"location":"ruby_api/native_registry/#native_methodsklass-array","title":"native_methods(klass) \u2192 Array","text":"<p>Returns a list of native methods for a class.</p> <p>Parameters:</p> <ul> <li><code>klass</code> - The Ruby class to look up.</li> </ul> <p>Returns:</p> <p>An Array of Native objects where <code>kind</code> is <code>Method</code>.</p> <pre><code>methods = Rice::Registries.instance.natives.native_methods(MyClass)\nmethods.each do |method|\n  puts \"#{method.name} -&gt; #{method.return_type}\"\nend\n</code></pre>"},{"location":"ruby_api/native_registry/#native_functionsklass-array","title":"native_functions(klass) \u2192 Array","text":"<p>Returns a list of native functions (class/module methods) for a class.</p> <p>Parameters:</p> <ul> <li><code>klass</code> - The Ruby class or module to look up.</li> </ul> <p>Returns:</p> <p>An Array of Native objects where <code>kind</code> is <code>Function</code>.</p> <pre><code>functions = Rice::Registries.instance.natives.native_functions(MyModule)\nfunctions.each do |func|\n  puts \"#{func.name} -&gt; #{func.return_type}\"\nend\n</code></pre>"},{"location":"ruby_api/native_registry/#native_attributesklass-array","title":"native_attributes(klass) \u2192 Array","text":"<p>Returns a list of native attributes for a class.</p> <p>Parameters:</p> <ul> <li><code>klass</code> - The Ruby class to look up.</li> </ul> <p>Returns:</p> <p>An Array of Native objects where <code>kind</code> is <code>AttributeReader</code> or <code>AttributeWriter</code>.</p> <pre><code>attrs = Rice::Registries.instance.natives.native_attributes(MyClass)\nattrs.each do |attr|\n  puts \"#{attr.name} (#{attr.kind})\"\nend\n</code></pre>"},{"location":"ruby_api/native_registry/#example","title":"Example","text":"<pre><code>registry = Rice::Registries.instance.natives\n\n# Get all methods for a class, grouped by name\nmethods = registry.native_methods(MyClass).group_by(&amp;:name)\n\nmethods.each do |name, overloads|\n  puts \"#{name}:\"\n  overloads.each do |method|\n    params = method.parameters.map { |p| p.klass.name }.join(\", \")\n    puts \"  (#{params}) -&gt; #{method.return_type}\"\n  end\nend\n\n# Filter by kind manually\ndef native_by_kind(klass, kinds)\n  Rice::Registries.instance.natives.lookup(klass).find_all do |native|\n    kinds.include?(native.kind)\n  end\nend\n\nprocs = native_by_kind(MyClass, [Rice::NativeKind::Proc])\n</code></pre>"},{"location":"ruby_api/native_registry/#see-also","title":"See Also","text":"<ul> <li>Registries - Entry point for accessing registries</li> <li>Native - Individual native wrapper objects</li> <li>TypeRegistry - Registry of wrapped C++ types</li> </ul>"},{"location":"ruby_api/overview/","title":"Overview","text":"<p>Rice exposes several Ruby classes for working with C++ data and introspecting extension bindings.</p>"},{"location":"ruby_api/overview/#data-classes","title":"Data Classes","text":"<p>These classes help Ruby code work with C++ memory:</p> <ul> <li>Buffer - Manages contiguous blocks of C++ memory</li> <li>Pointer - Lightweight wrapper around C++ pointers</li> </ul>"},{"location":"ruby_api/overview/#introspection-classes","title":"Introspection Classes","text":"<p>These classes provide access to Rice's internal registries, enabling tools like <code>rice_rbs</code> to generate RBS type definitions:</p> <ul> <li>Registries - Entry point singleton for accessing registries</li> <li>TypeRegistry - Registry of C++ types mapped to Ruby classes</li> <li>NativeRegistry - Registry of wrapped C++ functions and methods</li> <li>Native - Wrapper around a C++ function, method, or attribute</li> <li>Parameter - Parameter information for functions and methods</li> <li>Arg - Argument metadata from Rice bindings</li> </ul>"},{"location":"ruby_api/overview/#enabling-the-introspection-api","title":"Enabling the Introspection API","text":"<p>The introspection API is opt-in. To enable it, include the <code>&lt;rice/api.hpp&gt;</code> header and call <code>Init_Rice_Api</code>:</p> <pre><code>#include &lt;rice/api.hpp&gt;\n\nextern \"C\"\nvoid Init_my_extension()\n{\n  // Enable Introspection API\n  Init_Rice_Api();\n\n  // Add Rice binding code here\n}\n</code></pre>"},{"location":"ruby_api/overview/#quick-example","title":"Quick Example","text":"<p>Working with Buffers and Pointers</p> <pre><code># Create a buffer from Ruby data\nbuffer = Rice::Buffer&lt;int&gt;.new([1, 2, 3, 4, 5])\n\n# Access elements\nbuffer[0]      #=&gt; 1\nbuffer.size    #=&gt; 5\nbuffer.to_ary  #=&gt; [1, 2, 3, 4, 5]\n\n# Get a pointer to pass to C++ APIs\npointer = buffer.data\nsome_cpp_method(pointer)\n</code></pre> <p>Introspecting an Extension</p> <pre><code># Get the registries singleton\nregistries = Rice::Registries.instance\n\n# List all wrapped classes\nregistries.types.klasses.each do |klass|\n  puts klass.name\nend\n\n# Get methods for a class\nmethods = registries.natives.native_methods(MyClass)\nmethods.each do |native|\n  puts \"#{native.name}: #{native.return_type}\"\nend\n</code></pre>"},{"location":"ruby_api/parameter/","title":"Parameter","text":"<pre><code>Rice::Parameter\n</code></pre> <p><code>Rice::Parameter</code> provides access to parameter information for C++ functions and methods. Each parameter has a type (Ruby class) and associated argument metadata.</p>"},{"location":"ruby_api/parameter/#instance-methods","title":"Instance Methods","text":""},{"location":"ruby_api/parameter/#klass-class","title":"klass \u2192 Class","text":"<p>Returns the Ruby class that represents the parameter's type.</p> <p>Returns:</p> <p>The Ruby Class for this parameter's type.</p> <pre><code>native = Rice::Registries.instance.natives.native_methods(MyClass).first\nnative.parameters.each do |param|\n  puts \"Type: #{param.klass.name}\"\nend\n</code></pre>"},{"location":"ruby_api/parameter/#arg-arg","title":"arg \u2192 Arg","text":"<p>Returns the Arg associated with this parameter.</p> <p>Returns:</p> <p>An <code>Arg</code> object containing metadata like the parameter name.</p> <pre><code>native = Rice::Registries.instance.natives.native_methods(MyClass).first\nnative.parameters.each do |param|\n  puts \"#{param.arg.name}: #{param.klass.name}\"\nend\n</code></pre>"},{"location":"ruby_api/parameter/#example","title":"Example","text":"<pre><code># Generate parameter documentation for all methods\ndef document_parameters(klass)\n  registry = Rice::Registries.instance.natives\n\n  registry.native_methods(klass).each do |method|\n    puts \"#{method.name}:\"\n\n    if method.parameters.empty?\n      puts \"  (no parameters)\"\n    else\n      method.parameters.each_with_index do |param, i|\n        name = param.arg.name || \"arg#{i}\"\n        type = param.klass.name\n        puts \"  #{name}: #{type}\"\n      end\n    end\n\n    puts \"  returns: #{method.return_type&amp;.name || 'void'}\"\n    puts\n  end\nend\n\ndocument_parameters(MyClass)\n</code></pre>"},{"location":"ruby_api/parameter/#see-also","title":"See Also","text":"<ul> <li>Native - Native wrapper that contains parameters</li> <li>Arg - Argument metadata</li> </ul>"},{"location":"ruby_api/pointer/","title":"Pointer","text":"<pre><code>Rice::Pointer&lt;T&gt;\n</code></pre> <p><code>Rice::Pointer&lt;T&gt;</code> wraps C++ pointers, allowing them to be passed between Ruby and C++ code. Pointers are lightweight wrappers that simply hold a memory address without size or ownership information.</p> <p>Rice automatically generates <code>Pointer&lt;T&gt;</code> classes when it detects C++ APIs that use pointers to fundamental types or arrays of objects. For a pointer to <code>int*</code>, Rice creates <code>Rice::Pointer&lt;int&gt;</code>.</p> <p>See Pointers for usage examples.</p>"},{"location":"ruby_api/pointer/#public-instance-methods","title":"Public Instance Methods","text":""},{"location":"ruby_api/pointer/#buffer-buffer","title":"buffer \u2192 Buffer","text":"<p>Returns a <code>Buffer&lt;T&gt;</code> that can be used to read or manipulate the pointed-to memory.</p> <p>Returns:</p> <p>A <code>Buffer&lt;T&gt;</code> instance wrapping the pointer's memory.</p> <p>Description:</p> <p>Since Pointers are lightweight and carry no size information, use the returned Buffer to access the memory. You may need to specify the size when reading data.</p> <pre><code># Assume we received a pointer from a C++ API\npointer = some_cpp_method_returning_pointer()\n\n# Get a buffer to read the data\nbuffer = pointer.buffer\n\n# Read 10 elements\ndata = buffer.to_ary(10)\n</code></pre>"},{"location":"ruby_api/pointer/#usage-examples","title":"Usage Examples","text":"<p>Passing buffers to C++ APIs</p> <pre><code># Create a buffer with data\ndata = Rice::Buffer&lt;uint8_t&gt;.new([255, 128, 64, 32])\n\n# Get a pointer to pass to C++ API\npointer = data.data\n\n# Pass to C++ method expecting uint8_t*\nimage = Image.new(2, 2, pointer)\n</code></pre> <p>Reading from returned pointers</p> <pre><code># C++ method returns a pointer\npointer = matrix.raw_data  # Returns Rice::Pointer&lt;float&gt;\n\n# Convert to buffer to read values\nbuffer = pointer.buffer\n\n# Read all 100 elements\nvalues = buffer.to_ary(100)\n</code></pre>"},{"location":"ruby_api/pointer/#memory-management","title":"Memory Management","text":"<p>Pointer objects do not own or manage memory. They simply hold an address. Memory management is the responsibility of either:</p> <ul> <li>The <code>Buffer</code> that created the pointer (via <code>data</code>)</li> <li>The C++ code that allocated the memory</li> <li>The Ruby <code>Buffer</code> that received ownership (via <code>release</code>)</li> </ul> <p>Important: Never use a Pointer after the memory it points to has been freed. This includes:</p> <ul> <li>After a Buffer goes out of scope and is garbage collected</li> <li>After C++ code frees the memory</li> <li>After passing the pointer to a C++ API that takes ownership</li> </ul>"},{"location":"ruby_api/pointer/#pointer-vs-buffer","title":"Pointer vs Buffer","text":"Pointer Buffer Lightweight Full-featured No size info Tracks size No ownership Can own memory Pass to C++ Create from Ruby, read/write elements <p>Use Pointer when:</p> <ul> <li>Passing memory addresses to C++ APIs</li> <li>Receiving pointers from C++ APIs (then convert to Buffer to read)</li> </ul> <p>Use Buffer when:</p> <ul> <li>Creating data in Ruby to pass to C++</li> <li>Reading or manipulating memory contents</li> <li>Managing memory lifetime</li> </ul>"},{"location":"ruby_api/pointer/#see-also","title":"See Also","text":"<ul> <li>Buffer - Full-featured buffer class</li> <li>Pointers - Pointer usage guide</li> </ul>"},{"location":"ruby_api/reference/","title":"Reference","text":"<pre><code>Rice::Reference&lt;T&gt;\n</code></pre> <p><code>Rice::Reference&lt;T&gt;</code> wraps C++ references to fundamental types, allowing them to be passed between Ruby and C++ code. References store a copy of the value internally and provide a C++ reference to it when passed to C++ methods expecting <code>T&amp;</code> parameters.</p> <p>Rice automatically generates <code>Reference&lt;T&gt;</code> classes when it detects C++ APIs that use references to fundamental types. For a method with an <code>int&amp;</code> parameter, Rice creates <code>Rice::Reference&lt;int&gt;</code>.</p>"},{"location":"ruby_api/reference/#purpose","title":"Purpose","text":"<p>References are needed, in addition to pointers, to disambiguate overloaded C++ methods. When C++ has overloaded methods like:</p> <pre><code>void process(int* ptr);   // pointer overload\nvoid process(int&amp; ref);   // reference overload\n</code></pre> <p>Ruby code can explicitly choose which overload to call:</p> <pre><code># Call the pointer overload (int*)\nbuffer = Rice::Buffer&lt;int&gt;.new([42])\nobj.process(buffer.ptr)\n\n# Call the reference overload (int&amp;)\nref = Rice::Reference&lt;int&gt;.new(42)\nobj.process(ref)\n</code></pre> <p>Without <code>Reference&lt;T&gt;</code>, both would potentially match the reference parameter, making overload selection ambiguous.</p>"},{"location":"ruby_api/reference/#creating-references","title":"Creating References","text":"<p>References are created directly using the constructor:</p> <pre><code># Create a reference holding the value 100\nref = Rice::Reference&lt;int&gt;.new(100)\n\n# Create a reference to a double\nref = Rice::Reference&lt;double&gt;.new(3.14159)\n</code></pre>"},{"location":"ruby_api/reference/#instance-methods","title":"Instance Methods","text":""},{"location":"ruby_api/reference/#value","title":"<code>value</code>","text":"<p>Returns the current value stored in the reference.</p> <pre><code>ref = Rice::Reference&lt;int&gt;.new(42)\nref.value  #=&gt; 42\n</code></pre> <p>After passing the reference to a C++ method that modifies it:</p> <pre><code>ref = Rice::Reference&lt;int&gt;.new(7)\ncpp_object.update_value(ref)  # C++ sets ref to 42\nref.value  #=&gt; 42\n</code></pre>"},{"location":"ruby_api/reference/#usage-examples","title":"Usage Examples","text":"<p>Passing values by reference</p> <pre><code># Create a reference with an initial value\nref = Rice::Reference&lt;int&gt;.new(7)\n\n# C++ method modifies the value through the reference\nupdater.set_to_42(ref)\n\n# Check the modified value\nref.value  #=&gt; 42\n</code></pre> <p>Disambiguating overloaded methods</p> <pre><code># These call different C++ overloads:\nbuffer = Rice::Buffer&lt;int&gt;.new([42])\napi.process(buffer.ptr)  # calls process(int*)\n\nref = Rice::Reference&lt;int&gt;.new(42)\napi.process(ref)         # calls process(int&amp;)\n</code></pre>"},{"location":"ruby_api/reference/#reference-vs-pointer","title":"Reference vs Pointer","text":"Reference Pointer Matches <code>T&amp;</code> parameters Matches <code>T*</code> parameters Stores a single value Points to external memory For reference overloads For pointer overloads <p>Use Reference when:</p> <ul> <li>Calling C++ methods that take <code>T&amp;</code> parameters</li> <li>Need to pass a value that C++ can modify</li> <li>Disambiguating between pointer and reference overloads</li> </ul> <p>Use Pointer when:</p> <ul> <li>Calling C++ methods that take <code>T*</code> parameters</li> <li>Passing arrays or buffers to C++ APIs</li> </ul>"},{"location":"ruby_api/reference/#see-also","title":"See Also","text":"<ul> <li>Buffer - Full-featured buffer class</li> <li>Pointer - Lightweight pointer wrapper for <code>T*</code></li> </ul>"},{"location":"ruby_api/registries/","title":"Registries","text":"<pre><code>Rice::Registries\n</code></pre> <p><code>Rice::Registries</code> is the entry point to the introspection API. It is a singleton class that provides access to Rice's internal registries for type and native method information.</p>"},{"location":"ruby_api/registries/#class-methods","title":"Class Methods","text":""},{"location":"ruby_api/registries/#instance-registries","title":"instance \u2192 Registries","text":"<p>Returns the singleton instance of <code>Rice::Registries</code>.</p> <p>Returns:</p> <p>The singleton <code>Registries</code> instance.</p> <pre><code>registries = Rice::Registries.instance\n</code></pre>"},{"location":"ruby_api/registries/#instance-methods","title":"Instance Methods","text":""},{"location":"ruby_api/registries/#natives-nativeregistry","title":"natives \u2192 NativeRegistry","text":"<p>Returns a reference to the native registry.</p> <p>Returns:</p> <p>A NativeRegistry instance containing all wrapped C++ functions, methods, and attributes.</p> <pre><code>native_registry = Rice::Registries.instance.natives\nnative_registry.native_methods(MyClass)\n</code></pre>"},{"location":"ruby_api/registries/#types-typeregistry","title":"types \u2192 TypeRegistry","text":"<p>Returns a reference to the type registry.</p> <p>Returns:</p> <p>A TypeRegistry instance containing all wrapped C++ types.</p> <pre><code>type_registry = Rice::Registries.instance.types\ntype_registry.klasses.each { |klass| puts klass.name }\n</code></pre>"},{"location":"ruby_api/registries/#example","title":"Example","text":"<pre><code># Get the registries singleton\nregistries = Rice::Registries.instance\n\n# List all wrapped classes\nputs \"Wrapped classes:\"\nregistries.types.klasses.each do |klass|\n  puts \"  #{klass.name}\"\nend\n\n# Get native methods for a specific class\nputs \"\\nMethods for MyClass:\"\nregistries.natives.native_methods(MyClass).each do |native|\n  params = native.parameters.map { |p| \"#{p.arg.name}: #{p.klass}\" }.join(\", \")\n  puts \"  #{native.name}(#{params}) -&gt; #{native.return_type}\"\nend\n</code></pre>"},{"location":"ruby_api/registries/#see-also","title":"See Also","text":"<ul> <li>TypeRegistry - Registry of wrapped C++ types</li> <li>NativeRegistry - Registry of wrapped C++ functions and methods</li> <li>Enabling the Introspection API - How to enable the introspection API</li> </ul>"},{"location":"ruby_api/type_registry/","title":"TypeRegistry","text":"<pre><code>Rice::TypeRegistry\n</code></pre> <p><code>Rice::TypeRegistry</code> provides access to all C++ types that have been wrapped by Rice and their mappings to Ruby classes. It is accessed through Registries.</p>"},{"location":"ruby_api/type_registry/#instance-methods","title":"Instance Methods","text":""},{"location":"ruby_api/type_registry/#klasses-array","title":"klasses \u2192 Array","text":"<p>Returns the list of Ruby classes defined by the extension.</p> <p>Returns:</p> <p>An Array of Ruby Class objects that wrap C++ types.</p> <pre><code>types = Rice::Registries.instance.types\ntypes.klasses.each do |klass|\n  puts klass.name\nend\n</code></pre>"},{"location":"ruby_api/type_registry/#example","title":"Example","text":"<pre><code># Get all wrapped classes\ntype_registry = Rice::Registries.instance.types\n\nputs \"Classes defined by extension:\"\ntype_registry.klasses.each do |klass|\n  puts \"  #{klass.name}\"\n\n  # Get ancestors to see inheritance\n  ancestors = klass.ancestors.take_while { |a| a != Object }\n  if ancestors.length &gt; 1\n    puts \"    inherits from: #{ancestors[1..-1].map(&amp;:name).join(' &lt; ')}\"\n  end\nend\n\n# Use with native registry\ntype_registry.klasses.each do |klass|\n  methods = Rice::Registries.instance.natives.native_methods(klass)\n  puts \"\\n#{klass.name} methods:\"\n  methods.each do |method|\n    puts \"  #{method.name}\"\n  end\nend\n</code></pre>"},{"location":"ruby_api/type_registry/#see-also","title":"See Also","text":"<ul> <li>Registries - Entry point for accessing registries</li> <li>NativeRegistry - Registry of wrapped C++ functions and methods</li> </ul>"},{"location":"stl/complex/","title":"std::complex","text":"<p>Similarly to <code>std::string</code>, Rice considers <code>std::complex</code> a Builtin type. That means that <code>std::complex</code> values are converted to Ruby <code>Complex</code> instances, and vice versa.</p>"},{"location":"stl/exception/","title":"std::exception","text":"<p>Most of the time you do not have to worry about C++ exceptions. Rice automatically handles C++ exceptions and converts them to the appropriate Ruby exception.</p> <p>However, although rare, some C++ APIs define methods that take exception parameters. For example, OpenCV's API includes:</p> <pre><code>class AsyncPromise\n{\npublic:\n    /** Stores exception.\n    @param[in] exception exception to be raised in AsyncArray */\n    void setException(const cv::Exception&amp; exception);\n};\n</code></pre> <p>Thus Rice provides access to creating new C++ exception instances:</p> <pre><code>exception = Std::Exception.new\n</code></pre> <p>Rice currently only supports creating instances of <code>std::exception</code> and not any of its subtypes.</p>"},{"location":"stl/exception/#ruby-api","title":"Ruby API","text":"<p>The Ruby API for <code>std::exception</code> is:</p> <ul> <li>Exception#new (see constructor)</li> <li>Exception#what (see what)</li> </ul>"},{"location":"stl/exception_ptr/","title":"std::exception_ptr","text":"<p>Introduced in C++11, <code>std::exception_ptr</code> enables C++ exceptions to be captured. They can then be moved between threads, handled in different parts of code base or rethrown. Generally you will not need to use them in Ruby, but some C++ APIs expose them.</p> <p>For example, OpenCV's API includes:</p> <pre><code>class AsyncPromise\n{\npublic:\n    /** Stores exception.\n    @param[in] exception exception to be raised in AsyncArray */\n    void setException(std::exception_ptr exception);\n};\n</code></pre>"},{"location":"stl/exception_ptr/#ruby-api","title":"Ruby API","text":"<p>Currently Rice simply wraps <code>std::exception_ptr</code> so that it can be passed between Ruby and C++. However, Rice does not expose any constructors or methods. If this functionality is needed it can be added in the future.</p>"},{"location":"stl/function/","title":"std::function","text":"<p>Rice supports <code>std::function</code>, allowing C++ code to accept and return callable objects that can interoperate with Ruby.</p>"},{"location":"stl/function/#automatic-registration","title":"Automatic Registration","text":"<p>Rice automatically defines Ruby wrapper classes for <code>std::function</code> types when it encounters them in a C++ API. You do not need to manually register them.</p> <p>For example, if you have a C++ function:</p> <pre><code>std::function&lt;int(int, int)&gt; getAdder()\n{\n  return [](int a, int b) { return a + b; };\n}\n</code></pre> <p>And bind it with Rice:</p> <pre><code>define_module(\"MyModule\")\n  .define_module_function(\"get_adder\", &amp;getAdder);\n</code></pre> <p>Rice will automatically create the <code>Std::Function\u227aint\u2768int\u201a int\u2769\u227b</code> class and wrap the returned function.</p>"},{"location":"stl/function/#using-stdfunction-in-ruby","title":"Using std::function in Ruby","text":""},{"location":"stl/function/#calling-a-function-returned-from-c","title":"Calling a Function Returned from C++","text":"<p>When C++ returns a <code>std::function</code>, you can call it directly in Ruby:</p> <pre><code>func = MyModule.get_adder\nresult = func.call(7, 6)  # =&gt; 13\n</code></pre>"},{"location":"stl/function/#creating-a-stdfunction-from-ruby","title":"Creating a std::function from Ruby","text":"<p>You can create a <code>std::function</code> wrapper from a Ruby proc, lambda, or block:</p> <pre><code># Using a proc\nproc = Proc.new { |a, b| a * b }\nfunc = Std::FunctionInt.new(proc)\nfunc.call(5, 4)  # =&gt; 20\n\n# Using a lambda\nlamb = -&gt;(a, b) { a + b }\nfunc = Std::FunctionInt.new(lamb)\nfunc.call(3, 8)  # =&gt; 11\n\n# Using a block\nfunc = Std::FunctionInt.new { |a, b| a - b }\nfunc.call(10, 3)  # =&gt; 7\n</code></pre>"},{"location":"stl/function/#passing-stdfunction-to-c","title":"Passing std::function to C++","text":"<p>When a C++ function accepts a <code>std::function</code> parameter, you must first wrap your Ruby callable in an <code>std::function</code> object:</p> <pre><code>// C++ side\nint invokeFunction(std::function&lt;int(int, int)&gt; func, int a, int b)\n{\n  return func(a, b);\n}\n</code></pre> <pre><code># Ruby side - correct approach\nfunc = Std::FunctionInt.new { |a, b| a * b }\nresult = invoke_function(func, 5, 3)  # =&gt; 15\n</code></pre> <p>Important: You cannot pass a raw Ruby proc, lambda, or block directly to a C++ function that expects a <code>std::function</code>. This design simplifies memory management by ensuring the Ruby callable's lifetime is properly tracked.</p> <pre><code># This will NOT work\nproc = Proc.new { |a, b| a * b }\ninvoke_function(proc, 5, 3)  # Raises an exception\n</code></pre>"},{"location":"stl/function/#manual-registration","title":"Manual Registration","text":"<p>If you prefer a custom class name, use <code>define_stl_function</code>:</p> <pre><code>define_stl_function&lt;int(int, int)&gt;(\"FunctionInt\");\n</code></pre> <p>This creates <code>Std::FunctionInt</code> instead of the auto-generated name <code>Std::Function\u227aint\u2768int\u201a int\u2769\u227b</code>.</p>"},{"location":"stl/function/#methods","title":"Methods","text":"<p>The wrapped <code>std::function</code> class provides:</p> Method Description <code>new(callable)</code> Creates a new std::function wrapping a Ruby proc, lambda, or block <code>call(...)</code> Invokes the function with the given arguments <code>callable?</code> Returns <code>true</code> if the function contains a valid callable target"},{"location":"stl/function/#void-return-type","title":"Void Return Type","text":"<p>Functions with void return type are supported. The <code>call</code> method returns <code>nil</code> in Ruby:</p> <pre><code>define_stl_function&lt;void(double)&gt;();\n</code></pre> <pre><code>func = Std::Function\u227avoid\u2768double\u2769\u227b.new { |x| puts x }\nfunc.call(3.14)  # prints 3.14, returns nil\n</code></pre>"},{"location":"stl/function/#exception-handling","title":"Exception Handling","text":"<p>Exceptions are properly propagated in both directions:</p> <ul> <li>C++ exceptions thrown during function creation or invocation are translated to Ruby exceptions</li> <li>Ruby exceptions raised inside the callable are propagated back through the C++ call stack</li> </ul>"},{"location":"stl/map/","title":"std::map","text":"<p>Outside of <code>std::vector</code>, <code>std::map</code> is perhaps the most commonly used container in C+. Although there is a direct conceptual mapping between a <code>std::map</code> and a Ruby <code>Hash</code>, Rice does not copy a map to an Hash. Instead, it wraps <code>std::map</code>.</p> <p>There are multiple reasons for this:</p> <ul> <li><code>std::map</code> instantiations can only contain one type of key and value, while Ruby Hashes can contain different types of keys and values</li> <li><code>std::map</code> instances can be quite large</li> <li><code>std::map</code> instances commonly contain C++ classes that have complex copy or move semantics</li> <li>having two disconnected copies of data, one in C++ and one in Ruby, is usually undesirable</li> </ul> <p>Rice will automatically define Ruby classes for each instantiation of <code>std::map</code> it finds. You may also manually define Ruby classes via the use of the <code>define_map</code> method. Map classes are added to the <code>Std</code> module.</p>"},{"location":"stl/map/#usage","title":"Usage","text":"<p>For C++ methods that take map arguments, you can instantiate a new map from Ruby (see STL Class Names).</p> <p>For example, assume this C++ code:</p> <pre><code>void passMap(std::map&lt;std::string, int&gt; map)\n{\n}\n\ndefine_global_function(\"pass_map\", &amp;passMap);\n</code></pre> <p>One way to call it from Ruby is like this:</p> <pre><code>map = Std::Map\u227astring\u201a int\u227b.new\nmap[\"thirty seven\"] = 37\npass_map(map)\n</code></pre> <p>In this case, Ruby is wrapping a C++ map. Therefore any changes made to the map in C++ will be visible to Ruby.</p> <p>A second way to call the method is to pass a Ruby Hash:</p> <pre><code>hash = {\"three\" =&gt; 3, \"five\" =&gt; 5, \"nine\" =&gt; 9}\npass_map(hash)\n</code></pre> <p>In this case, Rice will copy the Ruby hash instead of wrapping it. Thus any modifications made in C++ will not be visible to Ruby.</p>"},{"location":"stl/map/#ruby-api","title":"Ruby API","text":"<p>Rice tries to make <code>std::map</code> look like a Ruby Hash by giving it an API that is a subset of <code>Hash</code>. However, there are differences you need to keep in mind.</p> <p>First, the following methods only work if the map type is copyable (copying is done in C++):</p> <ul> <li>Map#copy(other)</li> </ul> <p>Second, the following methods only work if the map type implements C++'s equal operator, <code>operator==</code>:</p> <ul> <li>Map#value?</li> </ul> <p>Third, if the map type supports C++ streams, then the following method will work, otherwise it will return \"Not Printable\"</p> <ul> <li>Map#to_s</li> </ul>"},{"location":"stl/multimap/","title":"std::multimap","text":"<p>Ruby does not natively provide MultiMaps. Thus Rice wraps <code>std::multimap</code>.</p> <p>Rice will automatically define Ruby classes for each instantiation of <code>std::multimap</code> it finds. You may also manually define Ruby classes via the use of the <code>define_multimap</code> method. Multimap classes are added to the <code>Std</code> module.</p>"},{"location":"stl/multimap/#usage","title":"Usage","text":"<p>For C++ methods that take multimap arguments, you can instantiate a new multimap from Ruby (see STL Class Names).</p> <p>For example, assume this C++ code:</p> <pre><code>void passMultiMap(std::multimap&lt;std::string, int&gt; stringMultimap)\n{\n}\n\ndefine_global_function(\"pass_multimap\", &amp;passMultiMap);\n</code></pre> <p>One way to call it from Ruby is like this:</p> <pre><code>multimap = Std::Map\u227astring\u201a int\u227b.new\nmultimap[\"thrity seven\"] = \"thirty seven\"\npass_multimap(multimap)\n</code></pre> <p>In this case, Ruby is wrapping a C++ multimap. Therefore any changes made to the multimap in C++ will be visible to Ruby.</p> <p>A second alternative is to pass it a Ruby hash instead:</p> <pre><code>hash = {\"three\" =&gt; 3, \"five\" =&gt; 5, \"nine\" =&gt; 9}\npass_multimap(hash)\n</code></pre> <p>In this case, Rice will copy the Ruby hash instead of wrapping it. Thus any modifications made in C++ will not be visible to Ruby.</p>"},{"location":"stl/multimap/#ruby-api","title":"Ruby API","text":"<p>Rice tries to make <code>std::multimap</code> look like a Ruby Hash by giving it an API that is a subset of <code>Hash</code>. However, there are differences you need to keep in mind.</p> <p>First, the following methods only work if the multimap type is copyable (copying is done in C++):</p> <ul> <li>multimap#copy(other)</li> </ul> <p>Second, the following methods only work if the multimap type implements C++'s equal operator, <code>operator==</code>:</p> <ul> <li>multimap#value?</li> </ul> <p>Third, if the multimap type supports C++ streams, then the following method will work, otherwise it will return \"Not Printable\"</p> <ul> <li>multimap#to_s</li> </ul>"},{"location":"stl/optional/","title":"std::optional","text":"<p>Introduced in C++17, <code>std::optional</code> provides C++ code an additional way (besides pointers) to return values from functions that may not be set.</p> <p>Since Ruby does not have an equivalent type, Rice unwraps <code>std::optional</code> instances. If the optional is empty, thus has a value of <code>std::nullopt</code>, Rice converts it to <code>nil</code> in Ruby. If the optional has a value, and that value is a Builtin type, then it will be converted to the appropriate Ruby type. If it is not a Builtin type, then the value will be wrapped by Ruby.</p> <p>When passing a Ruby instance to <code>std::optional</code>, Rice will convert <code>nil</code> values to <code>std::nullopt</code> and non <code>nil</code> values to the appropriate C++ type.</p>"},{"location":"stl/ostream/","title":"std::ostream","text":"<p>Rice provides support for exposing C++ output streams to Ruby. This allows Ruby code to interact with C++ streams, including writing to them and passing them to C++ functions that expect stream arguments.</p>"},{"location":"stl/ostream/#supported-classes","title":"Supported Classes","text":"<p>Rice supports three output stream types:</p> <ul> <li><code>std::ostream</code> - The base output stream class</li> <li><code>std::ostringstream</code> - String-based output stream</li> <li><code>std::ofstream</code> - File-based output stream</li> </ul>"},{"location":"stl/ostream/#ruby-classes","title":"Ruby Classes","text":"<p>The stream classes are defined in the <code>Std</code> module:</p> <ul> <li><code>Std::OStream</code> - Base class for output streams</li> <li><code>Std::OStringStream</code> - Inherits from <code>Std::OStream</code></li> <li><code>Std::OFStream</code> - Inherits from <code>Std::OStream</code></li> </ul>"},{"location":"stl/ostream/#defining-stream-classes","title":"Defining Stream Classes","text":"<p>To explicitly define the stream classes:</p> <pre><code>#include &lt;rice/rice.hpp&gt;\n#include &lt;rice/stl.hpp&gt;\n\nRice::define_ostream();        // Defines Std::OStream\nRice::define_ostringstream();  // Defines Std::OStringStream\nRice::define_ofstream();       // Defines Std::OFStream\n</code></pre> <p>Stream classes are also automatically registered when C++ functions use them as parameters or return types.</p>"},{"location":"stl/ostream/#standard-stream-constants","title":"Standard Stream Constants","text":"<p>When <code>define_ostream()</code> is called, Rice also defines constants for the standard C++ streams:</p> <ul> <li><code>Std::COUT</code> - References <code>std::cout</code></li> <li><code>Std::CERR</code> - References <code>std::cerr</code></li> </ul>"},{"location":"stl/ostream/#ruby-api","title":"Ruby API","text":""},{"location":"stl/ostream/#ostream-methods","title":"OStream Methods","text":"<p>All output stream classes inherit these methods from <code>Std::OStream</code>:</p> Method Description <code>write(value)</code> Writes a value to the stream <code>&lt;&lt;</code> Alias for <code>write</code> <code>flush</code> Flushes the stream buffer <code>clear</code> Clears error state flags <code>good?</code> Returns true if no error flags are set <code>bad?</code> Returns true if a non-recoverable error occurred <code>fail?</code> Returns true if an operation failed <code>eof?</code> Returns true if end-of-file was reached"},{"location":"stl/ostream/#ostringstream-methods","title":"OStringStream Methods","text":"<p>In addition to inherited methods:</p> Method Description <code>new</code> Creates an empty string stream <code>new(str)</code> Creates a stream initialized with the given string <code>str</code> Returns the stream contents as a string <code>str=</code> Sets the stream contents <code>to_s</code> Alias for <code>str</code>"},{"location":"stl/ostream/#ofstream-methods","title":"OFStream Methods","text":"<p>In addition to inherited methods:</p> Method Description <code>new</code> Creates an unopened file stream <code>new(filename)</code> Creates and opens a file stream <code>open(filename)</code> Opens a file for writing <code>close</code> Closes the file <code>open?</code> Returns true if a file is open"},{"location":"stl/ostream/#examples","title":"Examples","text":""},{"location":"stl/ostream/#writing-to-a-string-stream","title":"Writing to a String Stream","text":"<pre><code>stream = Std::OStringStream.new\nstream.write(\"Hello\")\nstream &lt;&lt; \" \" &lt;&lt; \"World\" &lt;&lt; 123\nputs stream.str  # =&gt; \"Hello World123\"\n</code></pre>"},{"location":"stl/ostream/#writing-to-a-file","title":"Writing to a File","text":"<pre><code>stream = Std::OFStream.new(\"output.txt\")\nstream &lt;&lt; \"Line 1\\n\"\nstream &lt;&lt; \"Line 2\\n\"\nstream.flush\nstream.close\n</code></pre>"},{"location":"stl/ostream/#passing-streams-to-c-functions","title":"Passing Streams to C++ Functions","text":"<pre><code>// C++ code\nvoid logMessage(std::ostream&amp; os, const std::string&amp; msg) {\n    os &lt;&lt; \"[LOG] \" &lt;&lt; msg &lt;&lt; std::endl;\n}\n\n// Register with Rice\nm.define_module_function(\"log_message\", &amp;logMessage);\n</code></pre> <pre><code># Ruby code\nstream = Std::OStringStream.new\nlog_message(stream, \"Application started\")\nputs stream.str  # =&gt; \"[LOG] Application started\\n\"\n\n# Or write directly to stdout\nlog_message(Std::COUT, \"Hello from Ruby!\")\n</code></pre>"},{"location":"stl/pair/","title":"std::pair","text":"<p><code>std::pair</code> is a simple container that provides C++ code a way of associating two values. <code>std::map</code> and <code>std::unordered_map</code> use <code>std::pair</code> to hold keys and their associated values.</p> <p>Ruby does not have a concept of a pair. Therefore, Rice wraps <code>std::pair</code> which means that data is not copied between C++ and Ruby.</p> <p>Since <code>std::pair</code> is a template of two types, each <code>std::pair</code> instantiation is its own unique C++ class, and thus its own unique Ruby class. You may manually define pair classes or let Rice do it for you. To manually define a Ruby class, use either the <code>define_pair</code> method.</p> <p>Example:</p> <pre><code>std::pair&lt;std::string, uint32_t&gt; makeStringIntPair(std::string key, uint32_t value)\n{\n   return std::make_pair(key, value);\n}\n\ndefine_pair&lt;std::string, uint32_t&gt;(\"StringIntPair\");\ndefine_global_function(\"make_string_int_pair\", &amp;makeStringIntPair);\n</code></pre> <p>Once you have defined this Ruby class, you can create a new instance like this:</p> <pre><code>pair = StringIntPair.new(\"key 2\", 33)\n</code></pre>"},{"location":"stl/pair/#ruby-api","title":"Ruby API","text":"<p>The Ruby API exposed for <code>std::pair</code> should be fairly self-explanatory and consists of the following methods (assume we have created a Ruby class called Pair):</p> <ul> <li>Pair#new(value1, value2)</li> <li>Pair#first</li> <li>Pair#first=(value)</li> <li>Pair#second</li> <li>Pair#second=(value)</li> </ul> <p>If the underlying <code>std::pair</code> has copyable types (remember copying is done in C++), then the following method will work, otherwise it will raise an exception:</p> <ul> <li>PairClass#copy(other)</li> </ul> <p>If the underlying <code>std::pair</code> has types that are supported by C++ streams, then the following method will work, otherwise it will return \"Not Printable\"</p> <ul> <li>PairClass#to_s</li> </ul>"},{"location":"stl/reference_wrapper/","title":"std::reference_wrapper","text":"<p>Introduced in C++11, <code>std::reference_wrapper</code> wraps C++ references in a copyable, assignable object. This allows them to be stored in containers such as <code>std::vector</code> or other types such as <code>std::variant</code>.</p> <p>Since Ruby does not have an equivalent type, Rice unwraps <code>std::reference_wrapper</code> instances. If the <code>std::reference_wrapper</code> points to a Builtin type, then it will be converted to the appropriate Ruby type. It it points to a non Builtin type, then the value will be wrapped by Ruby.</p> <p>When passing a Ruby instance to <code>std::reference_wrapper</code>, Rice will convert a Ruby type into the appropriate C++ type and store it inside the wrapper. Note this can be dangerous because Rice must maintain the original memory location for the reference to remain valid. For wrapped types this means the reference will remain valid as long as the wrapping Ruby object is valid and not garbage collected. For BuiltIn types, Rice only guarantees the reference to be valid through the lifetime of a method call. Thus if called C++ code stores the reference, and later tries to use it, an exception will happen.</p>"},{"location":"stl/set/","title":"std::set","text":"<p>Although there is a direct conceptual mapping between a <code>std::set</code> and a Ruby <code>Set</code>, Rice does not copy a C++ set to an Ruby set. Instead, it wraps <code>std::set</code>.</p> <p>There are multiple reasons for this:</p> <ul> <li><code>std::set</code> instantiations can only contain one type, while Ruby Sets can contain different types</li> <li><code>std::set</code> instances can be quite large</li> <li><code>std::set</code> instances commonly contain C++ classes that have complex copy or move semantics</li> <li>having two disconnected copies of data, one in C++ and one in Ruby, is usually undesirable</li> </ul> <p>Rice will automatically define Ruby classes for each instantiation of <code>std::set</code> it finds. You may also manually define Ruby classes via the use of the <code>define_set</code> method. Set classes are added to the <code>Std</code> module.</p>"},{"location":"stl/set/#usage","title":"Usage","text":"<p>For C++ methods that take set arguments, you can instantiate a new set from Ruby (see STL Class Names).</p> <p>For example, assume this C++ code:</p> <pre><code>void passSet(std::set&lt;int&gt; ints)\n{\n}\n\ndefine_global_function(\"pass_set\", &amp;passSet);\n</code></pre> <p>One way to call it from Ruby is like this:</p> <pre><code>set = Std::Set\u227aint\u227b.new\nset.push(37)\npass_set(set)\n</code></pre> <p>In this case, Ruby is wrapping a C++ set. Therefore any changes made to the set in C++ will be visible to Ruby.</p> <p>A second way is to pass a Ruby Set like this:</p> <pre><code>set = Set.new([3, 5, 9])\npass_set(set)\n</code></pre> <p>In this case, Rice will copy the Ruby array instead of wrapping it. Thus any modifications made in C++ will not be visible to Ruby.</p>"},{"location":"stl/set/#ruby-api","title":"Ruby API","text":"<p>Rice tries to make a <code>std::set</code> look like a Ruby Set by defining an API that is a subset of <code>Set</code>. However, there are differences you need to keep in mind.</p> <p>If the set type supports C++ streams, then the following method will work, otherwise it will return \"Not Printable\"</p> <ul> <li>set#to_s</li> </ul>"},{"location":"stl/shared_ptr/","title":"std::shared_ptr","text":"<p>Rice provides full support for <code>std::shared_ptr</code>, allowing C++ shared pointers to be used seamlessly from Ruby.</p>"},{"location":"stl/shared_ptr/#ruby-api","title":"Ruby API","text":"<p>When Rice wraps a <code>std::shared_ptr&lt;T&gt;</code>, it creates a Ruby class under the <code>Std</code> module. The class exposes the following methods:</p> Method Description <code>empty?</code> Returns true if the shared pointer is null <code>get</code> Returns the managed object <code>swap</code> Swaps the managed object with another shared_ptr <code>use_count</code> Returns the number of shared_ptr instances managing the object <p>For non-void types, a constructor is also defined that takes ownership of a raw pointer.</p> <p>Additionally, for non-fundamental and non-void types, Rice sets up forwarding so that methods and attributes defined on <code>T</code> can be called directly on the shared pointer wrapper.</p> <p>Note: Methods or attributes that have the same name on both the smart pointer wrapper and the managed type (e.g., <code>swap</code>) are not forwarded. To call the managed object's version, use <code>ptr.get.method_name</code>.</p>"},{"location":"stl/shared_ptr/#example","title":"Example","text":"<pre><code>class MyClass\n{\npublic:\n  int flag = 0;\n\n  void setFlag(int value)\n  {\n    this-&gt;flag = value;\n  }\n\n  int getFlag()\n  {\n    return this-&gt;flag;\n  }\n};\n\nclass Factory\n{\npublic:\n  std::shared_ptr&lt;MyClass&gt; share()\n  {\n    if (!instance_)\n    {\n      instance_ = std::make_shared&lt;MyClass&gt;();\n    }\n    return instance_;\n  }\n\nprivate:\n  static inline std::shared_ptr&lt;MyClass&gt; instance_;\n};\n\nvoid setupRice()\n{\n  define_class&lt;MyClass&gt;(\"MyClass\").\n    define_method(\"flag=\", &amp;MyClass::setFlag).\n    define_method(\"flag\", &amp;MyClass::getFlag);\n\n  define_class&lt;Factory&gt;(\"Factory\").\n    define_constructor(Constructor&lt;Factory&gt;()).\n    define_method(\"share\", &amp;Factory::share);\n}\n</code></pre> <p>In Ruby:</p> <pre><code>factory = Factory.new\nmy_instance = factory.share\n\n# Check the shared pointer\nputs my_instance.empty?     # =&gt; false\nputs my_instance.use_count  # =&gt; 1\n\n# Methods are forwarded to the managed object\nmy_instance.flag = 5\nputs my_instance.flag       # =&gt; 5\n\n# Can also access via get\nputs my_instance.get.flag   # =&gt; 5\n</code></pre>"},{"location":"stl/shared_ptr/#ownership","title":"Ownership","text":"<p>When a native method returns a <code>std::shared_ptr</code> by value, Rice copies it to maintain standard shared pointer semantics. This increments the reference count, and Ruby then shares ownership with any other <code>std::shared_ptr</code> instances in C++ code.</p> <p>When the Ruby object is garbage collected, it releases its reference to the <code>std::shared_ptr</code>, decrementing the reference count. The underlying C++ object is freed only when all shared pointer instances are destroyed.</p> <p>If a method returns a <code>std::shared_ptr</code> by reference or pointer (which would be unusual), Rice's usual reference/pointer semantics apply instead.</p>"},{"location":"stl/shared_ptr/#passing-to-c-methods","title":"Passing to C++ Methods","text":"<p>Rice automatically determines whether to pass the <code>std::shared_ptr</code> itself or the underlying raw pointer based on what the C++ method expects. This happens efficiently in C++ without requiring a round-trip through Ruby.</p> <pre><code>// Method that takes a shared_ptr\nint processShared(std::shared_ptr&lt;MyClass&gt; ptr)\n{\n  return ptr-&gt;getFlag();\n}\n\n// Method that takes a raw pointer\nint processRaw(MyClass* ptr)\n{\n  return ptr-&gt;getFlag();\n}\n\nvoid setupRice()\n{\n  define_class&lt;MyClass&gt;(\"MyClass\").\n    define_method(\"flag\", &amp;MyClass::getFlag);\n\n  define_global_function(\"process_shared\", &amp;processShared);\n  define_global_function(\"process_raw\", &amp;processRaw);\n}\n</code></pre> <p>In Ruby, you simply pass the shared pointer wrapper to either method:</p> <pre><code>factory = Factory.new\nmy_instance = factory.share\n\n# Rice passes the std::shared_ptr to C++\nprocess_shared(my_instance)\n\n# Rice extracts the raw pointer and passes it to C++\nprocess_raw(my_instance)\n\n# This also works but is less efficient because it goes through Ruby\nprocess_raw(my_instance.get)\n</code></pre>"},{"location":"stl/shared_ptr/#type-registration","title":"Type Registration","text":"<p>Rice automatically registers <code>std::shared_ptr&lt;T&gt;</code> types when they are used. You can also explicitly register them:</p> <pre><code>Rice::define_shared_ptr&lt;MyClass&gt;();\n</code></pre>"},{"location":"stl/shared_ptr/#see-also","title":"See Also","text":"<p>To learn how to implement support for a custom smart pointer type, see Smart Pointer Architecture.</p>"},{"location":"stl/stl/","title":"Overview","text":"<p>Rice supports the C++ standard template library (STL). To enable STL support you MUST include the <code>rice/stl.hpp</code> header file after the <code>rice/rice.hpp</code> header file.</p>"},{"location":"stl/stl/#type-mapping","title":"Type Mapping","text":"<p>Rice converts some STL classes and wraps others.</p>"},{"location":"stl/stl/#converted","title":"Converted","text":"<p>Converted classes include:</p> <ul> <li>std::complex (to Complex)</li> <li>std::monostate (to nil)</li> <li>std::optional (to whatever the optional contains)</li> <li>std::string (to String)</li> <li>std::string_view (to String)</li> <li>std::variant (to whatever the variant contains)</li> </ul>"},{"location":"stl/stl/#wrapped","title":"Wrapped","text":"<p>Wrapped classes include:</p> <ul> <li>std::exception</li> <li>std::exception_ptr</li> <li>std::function</li> <li>std::map</li> <li>std::multimap</li> <li>std::ofstream</li> <li>std::ostream</li> <li>std::ostringstream</li> <li>std::pair</li> <li>std::set</li> <li>std::shared_ptr</li> <li>std::type_index</li> <li>std::type_info</li> <li>std::unordered_map</li> <li>std::vector</li> <li>std::unique_ptr</li> </ul> <p>In contrast, a builtin class means that Rice will copy data from a C++ object to an equivalent Ruby object. Changes in one object are not reflected in the other.</p> <p>For more information see the type conversion section.</p>"},{"location":"stl/stl/#automatically-generated-ruby-classes","title":"Automatically Generated Ruby Classes","text":"<p>Many STL classes are templates, and thus must be instantiated with concrete types to define actual C++ classes. A <code>std::vector&lt;int&gt;</code> is a different class than a <code>std::vector&lt;std::string&gt;</code>. This means there can be a large number of STL instantiated classes in a C++ code base.</p> <p>Rice makes it easy to manually create Ruby classes for instantiated STL templates. The way to do this varies per STL type, but follows a simple naming scheme - <code>define_pair</code>, <code>define_vector</code>, etc. Please refer to the documentation for each supported STL type.</p> <p>Rice can also automatically generate Ruby classes. These Ruby classes are added to the <code>Std</code> module. Automatic classes work well in cases where Ruby code is accessing, or modifying, wrapped objects created in C++.</p> <p>Sometimes Ruby also needs to create new instances of these classes. With manually defined class names, this is easy to do. With generated class names you need to understand how Rice creates class names.</p> <p>Starting in version 4.5, Rice makes use of unicode characters to create class names that \"look\" like their C++ counterparts. For example, the type <code>std::pair&lt;std::string, double&gt;</code> becomes <code>Std::Pair\u227astring\u201a double\u227b</code>.  Or assume there is a vector containing a custom class <code>MyNamespace::MyClass</code>. Then generated name would be <code>Std::Vector\u227aMyNamespace\ua789\ua789MyClass\u227b</code>.</p> <p>The unicode characters are:</p> Character Code Point Name \ua789 U+A789 Modified Letter Colon \u227a U+227A Precedes \u227b U+227B Succeeds \u201a U+066C Arabic Thousands Separator U+00A0 Non breaking Space \u2768 U+2768 Medium Left Parenthesis Ornament \u2769 U+2769 Medium Right Parenthesis Ornament <p>To use this class in Ruby:</p> <pre><code>pair = Std::Pair\u227astring\u201a double\u227b.new\n</code></pre> <p>Note manual class names can be defined after auto generated class names. Rice only registers one class with Ruby, but it has two constants pointing at it. For example if you call <code>define_pair&lt;std::string, double&gt;(StringDoublePair)</code> after the pair has been registered, in Ruby you will have two constants pointing to the class:</p> <pre><code>Std::Pair\u227astring\u201a double\u227b\nObject::StringDoublePair\n</code></pre> <p>However, the name of the class itself will be defined by however it was first defined. In the case above, the class name will be <code>Std::Pair\u227astring\u201a double\u227b</code>.</p> <p>In general, it is recommended to use auto-defined STL class names.</p>"},{"location":"stl/string/","title":"std::string","text":"<p>Perhaps <code>std::string</code> is the most commonly used class in the C++ standard template library. Rice treats <code>std::string</code>'s as  Builtin types, which means strings are copied between C++ and Ruby. Thus, if you pass a <code>std::string</code> to Ruby and modify it in Ruby, C++ will not see the changes (and vice versa).</p> <p>Unlike Ruby, C++ has very little support for encodings. Thus it is a guessing game to correctly translate strings between C++ and Ruby and its up to you to get it right.</p> <p>When Rice converts a <code>std::string</code> to Ruby it is assumed to have the encoding specified by <code>Encoding.default_external</code>. That is likely to be UTF-8 on Windows while on Linux and MacOS it is based on the operating system locale. If no external encoding is specified, the converted string will have an encoding ASCII-8BIT which is Ruby's way of saying it has no encoding at all. If the encoding is incorrect, then you need to fix it in Ruby by calling <code>String#force_encoding</code>.</p> <p>In contrast, when Rice converts a Ruby string to a <code>std::string</code> it simply passes the underlying <code>char</code> buffer to <code>std::string</code> for copying. Thus it is once again up to you to make sure the encoding is correctly set in Ruby before passing the string to C++.</p> <p>Note that Rice does not support <code>std::wstring</code>.</p>"},{"location":"stl/string_view/","title":"std::string_view","text":"<p><code>std::string_view</code> is a read-only reference to a sequence of <code>char</code>. It provides a way of passing strings without the overhead of copying <code>std::string</code>.</p> <p>On input, Rice treats <code>std::string_view</code> as a Builtin type which means it copies the portion of the <code>char</code> sequence that a <code>std::string_view</code> references in C++ to Ruby. Please refer to the std::string documentation to learn about how Rice handles encodings.</p> <p>On output, Rice creates a <code>std::string_view</code> that references a Ruby string's underlying <code>char</code> buffer. Note this is DANGEROUS. Sooner or later the Ruby string will be garbage collected or moved as part of compaction, thus invalidating the <code>char</code> buffer. So use this with caution.</p>"},{"location":"stl/tuple/","title":"std::tuple","text":"<p><code>std::tuple</code> is a fixed size container that may contain heterogeneous values.</p> <p>Ruby does not have the concept of a tuple, but it can be mapped to a fixed size array. Thus Rice unwraps <code>std::tuple</code> instances into an array that has the same size as the tuple.</p> <p>Rice also support passing a Ruby array to C++ api that takes tuples.</p>"},{"location":"stl/tuple/#out-parameters","title":"Out Parameters","text":"<p>Prior to the introduction of tuples, C++ did not have a good way of returning multiple values from a function. One workaround was to return values via function parameters that are pointers. These are known as <code>out</code> parameters.</p> <p>For example, the minMaxLoc function in OpenCV is defined as:</p> <pre><code>void cv::minMaxLoc(cv::InputArray src,\n    double *         minVal,\n    double *         maxVal = 0,\n    Point *         minLoc = 0,\n    Point *         maxLoc = 0,\n    cv::InputArray     mask = cv::noArray() )\n</code></pre> <p>All of <code>minVal</code>, <code>maxVal</code>, <code>minLoc</code> and <code>maxLoc</code> are out parameters designed to return values.</p> <p>One way to wrap this function is to use Buffers.</p> <p>An alternative approach is to use <code>std::tuple</code>.</p> <pre><code>define_module_function(\"min_max_loc\", [](cv::InputArray src, cv::InputArray mask = cv::noArray()) -&gt; std::tuple&lt;double, double, cv::Point, cv::Point&gt;\n{\n  double minVal = 0;\n  double maxVal = 0;\n  cv::Point minLoc = 0;\n  cv::Point maxLoc = 0;\n\n  cv::minMaxLoc(src, &amp;minVal, &amp;maxVal, &amp;minLoc, &amp;maxLoc, mask);\n  return std::forward_as_tuple(minVal, maxVal, minLoc, maxLoc);\n},\nArg(\"src\"), Arg(\"mask\") = static_cast&lt;cv::InputArray&gt;(cv::noArray()));\n</code></pre> <p>Then to call the method from Ruby:</p> <pre><code>mat = Cv::Mat.new(2, 2, CV_8UC4, cv::Scalar.new(10, 20, 30, 40))\nmin_val = 10\nmin_val, max_val, min_loc, max_loc = min_max_loc(mat.input_array, min_val)\n</code></pre>"},{"location":"stl/type_index/","title":"std::type_index","text":"<p>Introduced in C++11, <code>std::type_index</code> is a wrapper class around a <code>std::type_info</code> object, that can be used as index in associative and unordered associative containers.</p> <p>Ruby does not have a concept of a type_index. Therefore, Rice wraps <code>std::type_index</code> which means that data is not copied between C++ and Ruby.</p>"},{"location":"stl/type_index/#ruby-api","title":"Ruby API","text":"<p>The Ruby API for <code>std::type_index</code> is:</p> <ul> <li>TypeIndex#hash_code (see hash_code)</li> <li>TypeIndex#name (see name)</li> </ul>"},{"location":"stl/type_info/","title":"std::type_info","text":"<p>Instances of the class <code>std:::type_info</code> are returned by C++'s <code>typeid</code> operator and provides implementation-specific information about a type.</p>"},{"location":"stl/type_info/#ruby-api","title":"Ruby API","text":"<p>Rice wraps <code>std:::type_info</code>. The exposed API is:</p> <ul> <li>TypeInfo#hash_code (see hash_code)</li> <li>TypeInfo#name (see name)</li> </ul>"},{"location":"stl/unique_ptr/","title":"std::unique_ptr","text":"<p>Rice provides full support for <code>std::unique_ptr</code>, allowing C++ unique pointers to be used seamlessly from Ruby.</p>"},{"location":"stl/unique_ptr/#ruby-api","title":"Ruby API","text":"<p>When Rice wraps a <code>std::unique_ptr&lt;T&gt;</code>, it creates a Ruby class under the <code>Std</code> module. The class exposes the following methods:</p> Method Description <code>empty?</code> Returns true if the unique pointer is null <code>get</code> Returns the managed object <code>release</code> Releases ownership and returns the managed object <code>reset</code> Replaces the managed object <code>swap</code> Swaps the managed object with another unique_ptr <p>Additionally, for non-fundamental and non-void types, Rice sets up forwarding so that methods and attributes defined on <code>T</code> can be called directly on the unique pointer wrapper.</p> <p>Note: Methods or attributes that have the same name on both the smart pointer wrapper and the managed type (e.g., <code>swap</code>, <code>reset</code>) are not forwarded. To call the managed object's version, use <code>ptr.get.method_name</code>.</p>"},{"location":"stl/unique_ptr/#example","title":"Example","text":"<pre><code>class MyClass\n{\npublic:\n  int flag = 0;\n\n  void setFlag(int value)\n  {\n    this-&gt;flag = value;\n  }\n\n  int getFlag()\n  {\n    return this-&gt;flag;\n  }\n};\n\nclass Factory\n{\npublic:\n  std::unique_ptr&lt;MyClass&gt; transfer()\n  {\n    return std::make_unique&lt;MyClass&gt;();\n  }\n};\n\nvoid setupRice()\n{\n  define_class&lt;MyClass&gt;(\"MyClass\").\n    define_method(\"flag=\", &amp;MyClass::setFlag).\n    define_method(\"flag\", &amp;MyClass::getFlag);\n\n  define_class&lt;Factory&gt;(\"Factory\").\n    define_constructor(Constructor&lt;Factory&gt;()).\n    define_method(\"transfer\", &amp;Factory::transfer);\n}\n</code></pre> <p>In Ruby:</p> <pre><code>factory = Factory.new\nmy_instance = factory.transfer\n\n# Check the unique pointer\nputs my_instance.empty?  # =&gt; false\n\n# Methods are forwarded to the managed object\nmy_instance.flag = 5\nputs my_instance.flag    # =&gt; 5\n\n# Can also access via get\nputs my_instance.get.flag  # =&gt; 5\n\n# Release ownership (returns the raw pointer, unique_ptr becomes empty)\nraw = my_instance.release\nputs my_instance.empty?  # =&gt; true\n</code></pre>"},{"location":"stl/unique_ptr/#ownership","title":"Ownership","text":"<p>When a native method returns a <code>std::unique_ptr</code> by value, Rice moves it into Ruby's control. Ruby then owns the unique pointer and its underlying object.</p> <p>When the Ruby object is garbage collected, it destroys the <code>std::unique_ptr</code>, which in turn frees the managed C++ object.</p> <p>If a method returns a <code>std::unique_ptr</code> by reference or pointer (which would be unusual), Rice's usual reference/pointer semantics apply instead.</p> <p>Rice supports transferring ownership of a <code>std::unique_ptr</code> back to C++ by passing it by value to a C++ method:</p> <pre><code>class Sink\n{\npublic:\n  int takeOwnership(std::unique_ptr&lt;MyClass&gt; ptr)\n  {\n    return ptr-&gt;flag;\n  }\n};\n\nvoid setupRice()\n{\n  define_class&lt;Sink&gt;(\"Sink\").\n    define_constructor(Constructor&lt;Sink&gt;()).\n    define_method(\"take_ownership\", &amp;Sink::takeOwnership);\n}\n</code></pre> <p>In Ruby:</p> <pre><code>factory = Factory.new\nmy_class = factory.transfer\nmy_class.flag = 5\n\nsink = Sink.new\nsink.take_ownership(my_class)  # Ownership transferred to C++\n\nputs my_class.empty?  # =&gt; true (unique_ptr is now empty)\n</code></pre> <p>You can also pass a reference to allow C++ code to access the managed object without transferring ownership:</p> <pre><code>int extractFlag(std::unique_ptr&lt;MyClass&gt;&amp; myClass)\n{\n  return myClass-&gt;flag;\n}\n</code></pre> <p>Passing a reference does not transfer ownership.</p>"},{"location":"stl/unique_ptr/#type-registration","title":"Type Registration","text":"<p>Rice automatically registers <code>std::unique_ptr&lt;T&gt;</code> types when they are used. You can also explicitly register them:</p> <pre><code>Rice::define_unique_ptr&lt;MyClass&gt;();\n</code></pre>"},{"location":"stl/unique_ptr/#see-also","title":"See Also","text":"<p>To learn how to implement support for a custom smart pointer type, see Smart Pointer Architecture.</p>"},{"location":"stl/unordered_map/","title":"std::unordered_map","text":"<p><code>std::unordered_map</code> is the Hash table of C++. However, Rice does not copy unordered_maps to Hash tables and instead wraps them.</p> <p>There are multiple reasons for this:</p> <ul> <li><code>std::unordered_map</code> instantiations can only contain one type of key and value, while Ruby Hashes can contain different types of keys and values</li> <li><code>std::unordered_map</code> instances can be quite large</li> <li><code>std::unordered_map</code> instances commonly contain C++ classes that have complex copy or move semantics</li> <li>having two disconnected copies of data, one in C++ and one in Ruby, is usually undesirable</li> </ul> <p>Rice will automatically define Ruby classes for each instantiation of <code>std::unordered_map</code> it finds. You may also manually define Ruby classes via the use of the <code>define_unordered_map</code> method. Unordered Map classes are added to the <code>Std</code> module.</p>"},{"location":"stl/unordered_map/#usage","title":"Usage","text":"<p>For C++ methods that take map arguments, you can instantiate a new map from Ruby (see STL Class Names).</p> <p>For example, assume this C++ code:</p> <pre><code>void passMap(std::unordered_map&lt;std::string, int&gt; stringIntMap)\n{\n}\n\ndefine_unordered_map&lt;std::unordered_map&lt;std::string, std::int&gt;&gt;(\"StringIntMap\");\ndefine_global_function(\"pass_map\", &amp;passMap);\n</code></pre> <p>One way to call it from Ruby is like this:</p> <pre><code>map = Std::UnorderedMap\u227astring\u201a int\u227b.new\nmap[\"thrity seven\"] = 37\npass_map(map)\n</code></pre> <p>In this case, Ruby is wrapping a C++ map. Therefore any changes made to the map in C++ will be visible to Ruby.</p> <p>However, it is often more convenient to pass a Ruby hash instead. This is especially true if you are using Rice's automatic stl classes.</p> <p>Therefore Rice also supports this usage:</p> <pre><code>hash = {\"three\" =&gt; 3, \"five\" =&gt; 5, \"nine\" =&gt; 9}\npass_map(hash)\n</code></pre> <p>In this case, Rice will copy the Ruby hash instead of wrapping it. Thus any modifications made in C++ will not be visible to Ruby.</p>"},{"location":"stl/unordered_map/#ruby-api","title":"Ruby API","text":"<p>Rice tries to make <code>std::unordered_map</code> look like a Ruby Hash by giving it an API that is a subset of <code>Hash</code>. However, there are differences you need to keep in mind.</p> <p>First, the following methods only work if the map type is copyable (copying is done in C++):</p> <ul> <li>UnorderedMap#copy(other)</li> </ul> <p>Second, the following methods only work if the map type implements C++'s equal operator, <code>operator==</code>:</p> <ul> <li>UnorderedMap#value?</li> </ul> <p>Third, if the map type supports C++ streams, then the following method will work, otherwise it will return \"Not Printable\"</p> <ul> <li>UnorderedMap#to_s</li> </ul>"},{"location":"stl/variant/","title":"std::variant","text":"<p>Introduced in C++17, <code>std::variant</code> is a type safe Union. A variant can hold a single value of one of its supported types.</p> <p>Since a Ruby variable can point to a value of any type, Ruby does not need or have an equivalent type. Thus Rice unwraps <code>std::variant</code> instances and converts the stored value to the appropriate Ruby type.</p> <p>When passing a Ruby instance to <code>std::variant</code>, Rice will convert a Ruby type into the appropriate C++ type and store it inside the variant.</p>"},{"location":"stl/vector/","title":"std::vector","text":"<p>Along with <code>std::string</code>, <code>std::vector</code> is a workhorse of many C++ code bases. Although there is a direct conceptual mapping between a <code>std::vector</code> and a Ruby <code>Array</code>, Rice does not copy a vector to an Array. Instead, it wraps <code>std::vector</code>.</p> <p>There are multiple reasons for this:</p> <ul> <li><code>std::vector</code> instantiations can only contain one type, while Ruby Arrays can contain different types</li> <li><code>std::vector</code> instances can be quite large</li> <li><code>std::vector</code> instances commonly contain C++ classes that have complex copy or move semantics</li> <li>having two disconnected copies of data, one in C++ and one in Ruby, is usually undesirable</li> </ul> <p>Rice will automatically define Ruby classes for each instantiation of <code>std::vector</code> it finds. You may also manually define Ruby classes via the use of the <code>define_vector</code> method. Vector classes are added to the <code>Std</code> module.</p>"},{"location":"stl/vector/#usage","title":"Usage","text":"<p>For C++ methods that take vector arguments, you can instantiate a new vector from Ruby (see STL Class Names).</p> <p>For example, assume this C++ code:</p> <pre><code>void passVector(std::vector&lt;int&gt; ints)\n{\n}\n\ndefine_vector&lt;int&gt;(\"IntVector\");\ndefine_global_function(\"pass_vector\", &amp;passVector);\n</code></pre> <p>One way to call it from Ruby is like this:</p> <pre><code>vector = IntVector.new\nvector.push(37)\npass_vector(vector)\n</code></pre> <p>In this case, Ruby is wrapping a C++ vector. Therefore any changes made to the vector in C++ will be visible to Ruby.</p> <p>However, it is often more convenient to pass a Ruby array instead. This is especially true if you are using Rice's automatic stl classes.</p> <p>Therefore Rice also supports this usage:</p> <pre><code>array = [3, 5, 9]\npass_vector(array)\n</code></pre> <p>In this case, Rice will copy the Ruby array instead of wrapping it. Thus any modifications made in C++ will not be visible to Ruby.</p>"},{"location":"stl/vector/#ruby-api","title":"Ruby API","text":"<p>Rice tries to make <code>std::vector</code> look like a Ruby Array by giving it an API that is a subset of <code>Array</code>. However, there are differences you need to keep in mind.</p> <p>First, the following methods only work if the vector type is copyable (copying is done in C++):</p> <ul> <li>Vector#copy(other)</li> <li>Vector#resize</li> </ul> <p>Second, the following methods only work if the vector type implements C++'s equal operator, <code>operator==</code>:</p> <ul> <li>Vector#delete</li> <li>Vector#include?</li> <li>Vector#index</li> </ul> <p>Third, if the vector type supports C++ streams, then the following method will work, otherwise it will return \"Not Printable\"</p> <ul> <li>Vector#to_s</li> </ul>"},{"location":"types/conversion/","title":"Type Conversions","text":"<p>Rice converts fundamental types to their equivalent Ruby types. Fundamental types include nullptr, bool, numeric types (integer, float, double, complex) and char types.</p> <p>Type conversion is easy to understand because it is familiar to programmers. When you pass a boolean or integer into a method, you don't expect the method is going to change it - instead it just gets a copy.</p> <p>Since they are copied, instances of fundamental types are disconnected. If a Ruby string is converted to a <code>std::string</code> then the two strings are independent and changes in one will not be reflected in the other.</p>"},{"location":"types/conversion/#built-in-conversions","title":"Built In Conversions","text":"<p>Rice supports all fundamental types out of the box. It also includes special handling for <code>char*</code> which is converted to a Ruby String. In addition, various STL classes are also converted as described in the STL documentation.</p> C++ Type Other Name Ruby Type bool TrueClass / FalseClass int8_t / uint8_t char String (binary encoding) int8_t / uint8_t char[] String (binary encoding) int8_t / uint8_t char* String (binary encoding) int8_t signed char String (binary encoding) int8_t[] signed char[] String (binary encoding) int8_t unsigned char String (binary encoding) int8_t[] unsigned char[] String (binary encoding) int16_t short Integer int16_t[] short[] String (binary encoding) uint16_t unsigned short Integer uint16_t[] unsigned short[] String (binary encoding) int32_t int Integer int32_t[] int[] String (binary encoding) uint32_t unsigned int Integer uint32_t[] unsigned int[] String (binary encoding) int64_t long Integer int64_t[] long[] String (binary encoding) uint64_t unsigned long Integer int64_t[] unsigned long[] String (binary encoding) int64_t long long Integer int64_t[] long long[] String (binary encoding) uint64_t unsigned long long Integer int64_t[] unsigned long long[] String (binary encoding) float Float float[] String (binary encoding) double Float double[] String (binary encoding)"},{"location":"types/conversion/#memory-management","title":"Memory Management","text":"<p>Because data is copied, it is up to each language to manage its own memory. For example, the following code would cause a memory leak:</p> <pre><code>char* leakMemory()\n{\n  char* data = new char[BUFFER_SIZE];\n  return data;\n}\n\nClass rb_cTest =\n  define_class(\"Test\")\n  .define_function(\"leak_memory\", &amp;leakMemory);\n</code></pre> <pre><code>test = Test.new\ndata = test.data\n</code></pre> <p>The leak happens because Ruby does not take ownership of the <code>char*</code> and thus it is never freed. For more information refer to the memory management section.</p>"},{"location":"types/converters/","title":"Type Converters","text":"<p>Rice includes type converters for all fundamental C++ types, most STL classes and for user defined C++ classes. Therefore, it is unlikely you will need to create your own converters. However, you can add new converters to Rice if needed.</p> <p>For the sake of an example, let's say you want to convert <code>std::deque&lt;int&gt;</code> to Ruby and are not using Rice's STL (standard template library) support. Let's also assume you want to copy the data between the two languages, as opposed to providing wrappers.</p> <p>To do this requires requires the following steps:</p> <ol> <li>Specialize Type template</li> <li>Specialize To_Ruby template</li> <li>Specialize From_Ruby template</li> </ol>"},{"location":"types/converters/#step-1-specialize-type","title":"Step 1 - Specialize Type","text":"<p>First we have to tell Rice that <code>std::deque&lt;int&gt;</code> is a known type so that it passes type verification. This is done by specializing the Type template:</p> <pre><code>namespace Rice::detail\n{\n  template&lt;&gt;\n  struct Type&lt;std::deque&lt;int&gt;&gt;\n  {\n    static bool verify()\n    {\n      return true;\n    }\n  };\n}\n</code></pre> <p>The specialization must be in the <code>Rice::detail</code> namespace. If your type contains subtypes, then make sure to verify them also. For an example, here is the verify method for <code>std::optional</code>:</p> <pre><code>namespace Rice::detail\n{\n  template&lt;typename T&gt;\n  struct Type&lt;std::optional&lt;T&gt;&gt;\n  {\n    static bool verify()\n    {\n      return Type&lt;T&gt;::verify();\n    }\n  };\n}\n</code></pre> <p>Notice that std::optional is only valid if the type it stores is valid.</p>"},{"location":"types/converters/#step-2-specialize-to_ruby","title":"Step 2 - Specialize To_Ruby","text":"<p>Next, we need to write C++ code that converts the <code>std::deque&lt;int&gt;</code> to a Ruby object. The most obvious Ruby object to map it to is an array.</p> <pre><code>namespace Rice::detail\n{\n  template&lt;&gt;\n  class To_Ruby&lt;std::deque&lt;int&gt;&gt;\n  {\n  public:\n    To_Ruby() = default;\n\n    explicit To_Ruby(Arg* arg) : arg_(arg)\n    {\n    }\n\n    VALUE convert(const std::deque&lt;int&gt;&amp; deque)\n    {\n      Array result;\n\n      for (int element : deque)\n      {\n        result.push(element, true);\n      }\n      return result;\n    }\n  private:\n    Arg* arg_ = nullptr;\n  };\n}\n</code></pre> <p>Once again, the definition must be in the  <code>Rice::detail</code> namespace.</p> <p>Instead of using the raw Ruby C API as above, you may prefer to use <code>Rice::Array</code> which provides an nice C++ wrapper for Ruby arrays.</p> <p>The <code>arg</code> parameter includes information about the passed in argument, including:</p> <ul> <li>Whether Ruby should take ownership of the object</li> <li>Whether the argument is a VALUE</li> <li>Whether the argument is a C style Array</li> </ul> <p>Your code will need to take this information into account when converting C++ objects to Ruby.</p>"},{"location":"types/converters/#step-3-specialize-from_ruby","title":"Step 3 - Specialize From_Ruby","text":"<p>Last, we need to write C++ code that converts a Ruby Array to <code>std::deque&lt;int&gt;</code>.</p> <pre><code>namespace Rice::detail\n{\n  template&lt;&gt;\n  class From_Ruby&lt;std::deque&lt;int&gt;&gt;\n  {\n  public:\n    From_Ruby() = default;\n\n    explicit From_Ruby(Arg* arg) : arg_(arg)\n    {\n    }\n\n    Convertible is_convertible(VALUE value)\n    {\n      switch (rb_type(value))\n      {\n        case RUBY_T_ARRAY:\n          return Convertible::Cast;\n          break;\n        default:\n          return Convertible::None;\n      }\n    }\n\n    std::deque&lt;int&gt; convert(VALUE value)\n    {\n      Array array(value);\n      std::deque&lt;int&gt; result(array.size());\n\n      for (long i=0; i&lt;size; i++)\n      {\n        // Convert the Ruby int to a C++ int\n        int element = From_Ruby&lt;int&gt;::convert(array[i]);\n\n        // Add it to our deque\n        result[i] = element;\n      }\n\n      return result;\n    }\n  private:\n    Arg* arg_ = nullptr;\n  };\n}\n</code></pre> <p>The <code>arg</code> parameter includes information about the passed in argument, including:</p> <ul> <li>Whether Ruby should take ownership of the object</li> <li>Whether the argument is a VALUE</li> <li>Whether the argument is a C style Array</li> <li>Whether the argument has a default value</li> </ul> <p>And as usual, the definition must be in the <code>Rice::detail</code> namespace.</p>"},{"location":"types/converters/#supporting-default-arguments","title":"Supporting Default Arguments","text":"<p>Rice supports C++ default arguments. To enable this support for your custom type requires making updating the <code>convert</code> method to check if the passed in Ruby value is <code>nil</code> (ie, <code>Qnil</code>).</p> <p>Expanding on our example above:</p> <pre><code>namespace Rice::detail\n{\n  template&lt;&gt;\n  class From_Ruby&lt;std::deque&lt;int&gt;&gt;\n  {\n  public:\n    From_Ruby() = default;\n\n    explicit From_Ruby(Arg* arg) : arg_(arg)\n    {\n    }\n\n    std::deque&lt;int&gt; convert(VALUE ary)\n    {\n      if (value == Qnil &amp;&amp; this-&gt;arg_ &amp;&amp; this-&gt;arg_-&gt;hasDefaultValue())\n      {\n        return this-&gt;arg_-&gt;defaultValue&lt;std::deque&lt;int&gt;&gt;();\n      }\n      else\n      {\n        // .... Same as code from example above\n      }\n    }\n\n  private:\n    Arg* arg_ = nullptr;\n  };\n}\n</code></pre>"},{"location":"types/naming/","title":"Auto Generated Classes","text":"<p>A key feature of C++ is its robust template system. C++ templates are not classes, but instead are used to generate concrete classes in a process called specialization</p> <p>This is quite common in the STL library. For example, <code>std::vector&lt;int&gt;</code> is a different class than a <code>std::vector&lt;std::string&gt;</code> and thus requires two different Ruby wrapper classes. This means there can be a large number of instantiated classes in a C++ code base.</p> <p>You can use Rice to define each and every one of these classes, but it quickly becomes tedious to both find them in a C++ code base and to define them.</p> <p>Thus, Rice can auto generate Ruby classes them as needed. But to use these classes in Ruby, you need to understand how Rice creates class names.</p> <p>Starting in version 4.5, Rice makes use of unicode characters to create class names that \"look\" like their C++ counterparts. For example, the type <code>std::pair&lt;std::string, double&gt;</code> becomes <code>Std::Pair\u227astring\u201a double\u227b</code>.  Similarly, <code>std::vector&lt;MyNamespace::MyClass&gt;</code> becomes  <code>Std::Vector\u227aMyNamespace\ua789\ua789MyClass\u227b</code>.</p> <p>The unicode characters are:</p> Character Code Point Name \ua789 U+A789 Modified Letter Colon \u227a U+227A Precedes \u227b U+227B Succeeds \u201a U+066C Arabic Thousands Separator U+00A0 Non breaking Space \u2768 U+2768 Medium Left Parenthesis Ornament \u2769 U+2769 Medium Right Parenthesis Ornament <p>To use an auto generated class in Ruby:</p> <pre><code>pair = Std::Pair\u227astring\u201a double\u227b.new\n</code></pre> <p>Note manual class names can be defined after auto generated class names. Rice only registers one class with Ruby, but it has two constants pointing at it. For example if you call <code>define_pair&lt;std::string, double&gt;(StringDoublePair)</code> after the pair has been registered, in Ruby you will have two constants pointing to the class:</p> <pre><code>Std::Pair\u227astring\u201a double\u227b\nObject::StringDoublePair\n</code></pre> <p>However, the name of the class itself will be defined by however it was first defined. In the case above, the class name will be <code>Std::Pair\u227astring\u201a double\u227b</code>.</p> <p>In general, it is recommended to use auto-defined STL class names.</p>"},{"location":"types/overview/","title":"Overview","text":"<p>Rice enable native C++ code and Ruby code to work together. This requires translating types between the two languages.</p>"},{"location":"types/overview/#c-types","title":"C++ Types","text":"<p>C++ defines fundamental and compound types. Fundamental types consist of void, integers, float, double, etc. Compound types are everything else such as enums, arrays, classes, pointers, references, etc.</p>"},{"location":"types/overview/#type-mapping","title":"Type Mapping","text":"<p>Objects can either be converted or wrapped. Converted objects are copied between the two languages. For example, a C++ integer is copied to a Ruby Integer resulting in two disconnected objects. If you update the value of the Ruby integer the change is not reflected in the C++ integer. For more information refer to the Type Conversion section.</p> <p>Wrapped objects are C++ objects that are wrapped by Ruby objects, or alternatively, Ruby objects wrapped by C++ objects. Thus the two objects are connected. For example, if a C++ object is wrapped by a Ruby object then any modifications to the Ruby object will be reflected in the C++ object. For more information refer to the Type Wrapping section.</p> <p>The table below shows how fundamental and compound C++ types are mapped to Ruby types based on whether they are passed by value, reference or pointer.</p> C++ Type Fundamental Compound Value (T) Converted Wrapped Reference (T&amp;) Reference&lt;T&gt; Wrapped Pointer (T*) Pointer&lt;T&gt; Wrapped Array (T[]) Pointer&lt;T&gt; Pointer&lt;T&gt; Pointer (T**) Pointer&lt;T*&gt; Pointer&lt;T*&gt; <p>The Pointer classes are automatically generated by Rice to wrap C++ arrays and pointers to fundamental types. Use Buffers to manipulate the pointer's memory.</p>"},{"location":"types/strings/","title":"Strings","text":"<p>Ruby and C++ handle strings very differently. In Ruby, every string is associated with an encoding, such as UTF-8. Strings with encodings of binary, or USASCII-8bit, are treated as byte arrays</p> <p>In contrast, C++ has no concept of encodings. It is up to the progammer to figure out how data is stored in a string.</p> <p>Rice handles this difference by converting strings between the language as-is. In other words, it simply copies bytes from a Ruby string to a C++ string and vice versa. Thus any C++ string returned to Ruby will have its encoding set to binary.</p> <p>If you know that a C++ API requires a certain encoding, such as UTF-8, then first convert the string in Ruby before passing it to C++. Or, if you know a C++ string is in a specific encoding then call <code>String::force_encoding</code> in Ruby.</p>"},{"location":"types/verification/","title":"Type Verification","text":"<p>Rice is very picky about types - it will throw an exception on startup if it comes across a type that has not been defined. Hopefully this will not come as a surprise to most C++ developers.</p> <p>For example, let's look at the following contrived example:</p> <pre><code>class MyClass\n{\n};\n\nusing Fancy_T = std::vector&lt;std::unique_ptr&lt;std::pair&lt;std::string, MyClass&gt;&gt;&gt;\n\nclass Factory\n{\n  Fancy_T&amp; make_fancy_type();\n};\n\nvoid setupRice()\n{\n  define_class&lt;Factory&gt;(\"Factory\").\n    define_method(\"make_fancy_type\", &amp;Factory::make_fancy_type);\n}\n</code></pre> <p>When Ruby loads the Rice extension above it will throw an exception. The reason is that <code>MyClass</code> has not yet been defined to Rice.</p> <p>When <code>define_method</code> is called, Rice will see that the return type for <code>&amp;Factory::make_fancy_type</code> is <code>Fancy_T</code>. It will then drill down through the vector to the unique_ptr to the pair to <code>MyClass</code>. When it encounters <code>MyClass</code> it will check its internal <code>TypeRegistry</code> and realize it has not yet been defined and throw a <code>std::runtime_exception</code>.</p> <p>To fix this requires first defining <code>MyClass</code> like this:</p> <pre><code>void setupRice()\n{\n  define_class&lt;MyClass&gt;(\"MyClass\");\n\n  define_class&lt;Factory&gt;(\"Factory\").\n    define_method(\"make_fancy_type\", &amp;Factory::make_fancy_type);\n}\n</code></pre>"},{"location":"types/wrapping/","title":"Type Wrapping","text":"<p>Type conversion usually does not make sense for C++ compound types. You likely do not want to copy instances of simple C++ structures to Ruby, and you almost never want to copy instances of C++ classes. There are a lot of reasons for this, including:</p> <ul> <li>C++ objects may contain uncopyable internal state, such as a database connection or an open file handle</li> <li>C++ has complex object lifetime rules that control how objects are created, copied and destructed that do not translate to Ruby</li> <li>A C++ object may use a lot of memory, such as a million element vector, that makes it untenable to copy it to Ruby.</li> <li>Copying data, by definition, creates two separate versions making it impossible to share data between the two languages.</li> </ul> <p>As a result, a more practical approach is to create Ruby wrapper classes that allow Ruby to access C++ objects and C++ to access Ruby objects. Ruby wrappers are created via <code>define_enum</code>, <code>define_class</code>, etc. as described in other parts of the documentation.</p> <p>The way wrapped C++ objects are stored internally depends on how they were returned to Rice. Returned references are stored as references, pointers and pointers and values are either move constructed or copy constructed.</p> <p>On the flip side, from C++ you may wish to manipulate Ruby objects. This can be done by using Rice's object-oriented C++ API that provides C++ wrapper classes for Ruby objects. This allows C++ code to manipulate Ruby objects.</p>"},{"location":"types/wrapping/#conversions-for-wrapped-c-types","title":"Conversions for wrapped C++ types","text":"<p>Take another look at the wrapper we wrote for the <code>Test</code> class:</p> <pre><code>extern \"C\"\nvoid Init_test()\n{\n  Data_Type&lt;Test&gt; rb_cTest =\n    define_class&lt;Test&gt;(\"Test\")\n    .define_constructor(Constructor&lt;Test&gt;())\n    .define_method(\"hello\", &amp;Test::hello);\n}\n</code></pre> <p>When we called <code>define_class&lt;Test&gt;</code>, it created a Class for us and automatically registered the new Class with the type system.</p> <p>The <code>Data_Object</code> class can be used to wrap a C++ object in a Ruby object:</p> <pre><code>Data_Object&lt;Foo&gt; obj(new Foo);\n</code></pre> <p>We can then convert it back to C++:</p> <pre><code>Foo *f = detail::From_Ruby&lt;Foo *&gt;().convert(obj);\n</code></pre> <p>The <code>Data_Object</code> class is a wrapper for the <code>TypedData_Wrap_Struct</code> and the <code>TypedData_Get_Struct</code> macros in C extensions. It can be used to wrap or unwrap any class that has been previously defined using a <code>Data_Type</code>.</p> <p>A <code>Data_Object</code> functions like a smart pointer:</p> <pre><code>Data_Object&lt;Foo&gt; foo(obj);\nfoo-&gt;foo();\nstd::cout &lt;&lt; *foo &lt;&lt; std::endl;\n</code></pre> <p>Like a <code>VALUE</code> or an <code>Object</code>, data stored in a <code>Data_Object</code> will be marked by the garbage collector as long as the <code>Data_Object</code> is on the stack.</p> <p>Last, <code>Data_Object</code> inherits from <code>Object</code>, so any Object member functions work with <code>Data_Object</code>:</p> <pre><code>Object object_id = obj.call(\"object_id\");\nstd::cout &lt;&lt; object_id &lt;&lt; std::endl;\n</code></pre>"}]}