<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Rice: Rice - Ruby Interface for C++ Extensions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Rice
   &#160;<span id="projectnumber">3.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Rice - Ruby Interface for C++ Extensions </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="mainpage"></a> </p>
<h1><a class="anchor" id="intro"></a>
Introduction</h1>
<p>Rice is a C++ interface to Ruby's C API. It provides a type-safe and exception-safe interface in order to make embedding Ruby and writing Ruby extensions with C++ easier. It is similar to Boost.Python or pybind11 in many ways, but also attempts to provide an object-oriented interface to all of the Ruby C API.</p>
<p>What Rice gives you:</p><ul>
<li>A simple C++-based syntax for wrapping and defining classes</li>
<li>Automatic conversion of exceptions between C++ and Ruby</li>
<li>Smart pointers for handling garbage collection</li>
<li>Wrappers for most builtin types to simplify calling code</li>
</ul>
<h1><a class="anchor" id="autotoc_md0"></a>
Version Differences 3.x vs 4.x and later</h1>
<p>This documentation and branch are for the 3.x line of Rice. For the header-only version of Rice use the <code>master</code> branch and any version from 4.x onward.</p>
<p>The documentation for the 4.x line is found at <a href="http://jasonroelofs/rice/4.x">http://jasonroelofs/rice/4.x</a>.</p>
<h1><a class="anchor" id="project"></a>
Project Details</h1>
<p>The source is hosted on GitHub: <a href="http://github.com/jasonroelofs/rice">http://github.com/jasonroelofs/rice</a></p>
<p>Bug tracking: <a href="http://github.com/jasonroelofs/rice/issues">http://github.com/jasonroelofs/rice/issues</a></p>
<p>API documentation: <a href="http://jasonroelofs.github.io/rice">http://jasonroelofs.github.io/rice</a></p>
<h1><a class="anchor" id="installation"></a>
Installation</h1>
<div class="fragment"><div class="line">gem install rice</div>
</div><!-- fragment --><p>Building it locally from a clone of the repository is as follows:</p>
<div class="fragment"><div class="line">./bootstrap</div>
<div class="line">ruby extconf.rb</div>
<div class="line">make</div>
</div><!-- fragment --><p>Rice is known to work on *nix, OSX, and Windows.</p>
<p>Rice requires a C++ compiler with support for C++14 or later.</p>
<h1><a class="anchor" id="tutorial"></a>
Tutorial</h1>
<h2><a class="anchor" id="getting_started"></a>
Getting started</h2>
<p>Writing an extension with Rice is very similar to writing an extension with the C API.</p>
<p>The first step is to create an extconf.rb file:</p>
<div class="fragment"><div class="line">require <span class="stringliteral">&#39;mkmf-rice&#39;</span></div>
<div class="line">create_makefile(<span class="stringliteral">&#39;test&#39;</span>)</div>
</div><!-- fragment --><p>Note that we use <code>mkmf-rice</code> instead of <code>mkmf</code>. This will ensure that the extension will be linked with standard C++ library along with the Rice library, and allow access to the Rice header files.</p>
<p>Next we create our extension and save it to test.cpp:</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line"><span class="keywordtype">void</span> Init_test()</div>
<div class="line">{</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note the extern "C" line above. This tells the compiler that the function <code>Init_test</code> should have C linkage and calling convention. This turns off name mangling so that the Ruby interpreter will be able to find the function (remember that Ruby is written in C, not C++).</p>
<p>So far we haven't put anything into the extension, so it isn't particularly useful. The next step is to define a class so we can add methods to it.</p>
<h2><a class="anchor" id="classes"></a>
Defining clases</h2>
<p>Defining a class in Rice is a single call:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;rice/Class.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>Rice;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line"><span class="keywordtype">void</span> Init_test()</div>
<div class="line">{</div>
<div class="line">  Class rb_cTest = define_class(<span class="stringliteral">&quot;Test&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>This will create a class called <code>Test</code> that inherits from <code>Object</code>. If we wanted to inherit from a different class, we do so with the second parameter:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;rice/Class.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>Rice;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line"><span class="keywordtype">void</span> Init_test()</div>
<div class="line">{</div>
<div class="line">  Class rb_cMySocket = define_class(<span class="stringliteral">&quot;MySocket&quot;</span>, rb_cIO);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note the prefix rb_c on the name of the class. This is a convention that the Ruby interpreter and many extensions tend to use. It signifies that this is a class and not some other type of object. Some other naming conventions that are commonly used:</p>
<ul>
<li>rb_c variable name prefix for a Class</li>
<li>rb_m variable name prefix for a Module</li>
<li>rb_e variable name prefix for an Exception type</li>
<li>rb_ function prefix for a function in the Ruby C API</li>
<li>rb_f_ function prefix to differentiate between an API function that takes Ruby objects as arguments and one that takes C argument types</li>
<li>rb_*_s_ indicates the function is a singleton function</li>
<li>*_m suffix to indicate the function takes variable number of arguments</li>
</ul>
<p>Also note that we don't include "ruby.h" directly. Rice has a wrapper for ruby.h that handles some compatibility issues across platforms and Ruby versions. Always include Rice headers before including anything that might include "ruby.h".</p>
<h2><a class="anchor" id="methods"></a>
Defining methods</h2>
<p>Now let's add a method to our class:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;rice/Class.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;rice/String.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>Rice;</div>
<div class="line"> </div>
<div class="line">Object test_hello(Object <span class="comment">/* self */</span>)</div>
<div class="line">{</div>
<div class="line">  String str(<span class="stringliteral">&quot;hello, world&quot;</span>);</div>
<div class="line">  <span class="keywordflow">return</span> str;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line"><span class="keywordtype">void</span> Init_test()</div>
<div class="line">{</div>
<div class="line">  Class rb_cTest =</div>
<div class="line">    define_class(<span class="stringliteral">&quot;Test&quot;</span>)</div>
<div class="line">    .<a class="code" href="classRice_1_1Module__impl.html#af28e40414700af89982ff493f31ffa9f">define_method</a>(<span class="stringliteral">&quot;hello&quot;</span>, &amp;test_hello);</div>
<div class="line">}</div>
<div class="ttc" id="aclassRice_1_1Module__impl_html_af28e40414700af89982ff493f31ffa9f"><div class="ttname"><a href="classRice_1_1Module__impl.html#af28e40414700af89982ff493f31ffa9f">Rice::Module_impl::define_method</a></div><div class="ttdeci">Derived_T &amp; define_method(Identifier name, Func_T func, Arguments *arguments=0)</div><div class="ttdoc">Define an instance method.</div></div>
</div><!-- fragment --><p>Here we add a method <code>Test#hello</code> that returns the string "Hello, World". The method takes self as an implicit parameter, but isn't used, so we comment it out to prevent a compiler warning.</p>
<p>We could also add an <code>#initialize</code> method to our class:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;rice/Class.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;rice/String.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>Rice;</div>
<div class="line"> </div>
<div class="line">Object test_initialize(Object <span class="keyword">self</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">self</span>.iv_set(<span class="stringliteral">&quot;@foo&quot;</span>, 42);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">Object test_hello(Object <span class="comment">/* self */</span>)</div>
<div class="line">{</div>
<div class="line">  String str(<span class="stringliteral">&quot;hello, world&quot;</span>);</div>
<div class="line">  <span class="keywordflow">return</span> str;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line"><span class="keywordtype">void</span> Init_test()</div>
<div class="line">{</div>
<div class="line">  Class rb_cTest =</div>
<div class="line">    define_class(<span class="stringliteral">&quot;Test&quot;</span>)</div>
<div class="line">    .<a class="code" href="classRice_1_1Module__impl.html#af28e40414700af89982ff493f31ffa9f">define_method</a>(<span class="stringliteral">&quot;initialize&quot;</span>, &amp;test_initialize)</div>
<div class="line">    .<a class="code" href="classRice_1_1Module__impl.html#af28e40414700af89982ff493f31ffa9f">define_method</a>(<span class="stringliteral">&quot;hello&quot;</span>, &amp;test_hello);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>initialize</code> method sets an instance variable <code>@foo</code> to the value 42. The number is automatically converted to a <code>Fixnum</code> before doing the assignment.</p>
<p>Note that we're chaining calls on the <code>Class</code> object. Most member functions in <code>Module</code> and <code>Class</code> return a reference to <code>self</code>, so we can chain as many calls as we want to define as many methods as we want.</p>
<h2><a class="anchor" id="data_types"></a>
Wrapping C++ Types</h2>
<p>It's useful to be able to define Ruby classes in a C++ style rather than using the Ruby API directly, but the real power Rice is in wrapping already-defined C++ types.</p>
<p>Let's assume we have the following C++ class that we want to wrap:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Test</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  Test();</div>
<div class="line">  std::string hello();</div>
<div class="line">};</div>
</div><!-- fragment --><p>This is a C++ version of the Ruby class we just created in the previous section. To wrap it:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;rice/Data_Type.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;rice/Constructor.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>Rice;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line"><span class="keywordtype">void</span> Init_test()</div>
<div class="line">{</div>
<div class="line">  Data_Type&lt;Test&gt; rb_cTest =</div>
<div class="line">    define_class&lt;Test&gt;(<span class="stringliteral">&quot;Test&quot;</span>)</div>
<div class="line">    .define_constructor(Constructor&lt;Test&gt;())</div>
<div class="line">    .define_method(<span class="stringliteral">&quot;hello&quot;</span>, &amp;Test::hello);</div>
<div class="line">}</div>
</div><!-- fragment --><p>This example is similar to the one before, but we use <code>Data_Type&lt;&gt;</code> instead of <code>Class</code> and the template version of define_class() instead of the non-template version. This creates a binding in the Rice library between the Ruby class <code>Test</code> and the C++ class Test such that Rice passes member function pointers to <code>define_method()</code>.</p>
<p>It is possible to write the conversion functions ourself (as we'll see below), but Rice does all the dirty work for us.</p>
<h2><a class="anchor" id="conversions"></a>
Type conversions</h2>
<p>Let's look again at our example class:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Test</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  Test();</div>
<div class="line">  std::string hello();</div>
<div class="line">};</div>
</div><!-- fragment --><p>When we wrote our class, we never wrote a single line of code to convert the <code>std::string</code> returned by <code>hello()</code> into a Ruby type. Neverthless, the conversion works, and when we write:</p>
<div class="fragment"><div class="line">test = Test.new</div>
<div class="line">puts test.hello</div>
</div><!-- fragment --><p>We get the expected result.</p>
<p>Rice has two template conversion functions to convert between C++ and Ruby types:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">T from_ruby(Object x);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">Object to_ruby(T <span class="keyword">const</span> &amp; x);</div>
</div><!-- fragment --><p>Rice includes default specializations for many of the builtin types. To define your own conversion, write a template specialization:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;&gt;</div>
<div class="line">Foo from_ruby&lt;Foo&gt;(Object x)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span>&lt;&gt;</div>
<div class="line">Object to_ruby&lt;Foo&gt;(Foo <span class="keyword">const</span> &amp; x)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>The implementation of these functions would, of course, depend on the implementation of <code>Foo</code>.</p>
<h2><a class="anchor" id="data_conversions"></a>
Conversions for wrapped C++ types</h2>
<p>Take another look at the wrapper we wrote for the <code>Test</code> class:</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line"><span class="keywordtype">void</span> Init_test()</div>
<div class="line">{</div>
<div class="line">  Data_Type&lt;Test&gt; rb_cTest =</div>
<div class="line">    define_class&lt;Test&gt;(<span class="stringliteral">&quot;Test&quot;</span>)</div>
<div class="line">    .define_constructor(Constructor&lt;Test&gt;())</div>
<div class="line">    .define_method(<span class="stringliteral">&quot;hello&quot;</span>, &amp;Test::hello);</div>
<div class="line">}</div>
</div><!-- fragment --><p>When we called <code>define_class&lt;Test&gt;</code>, it created a Class for us and automatically registered the new Class with the type system, so that the calls:</p>
<div class="fragment"><div class="line">Data_Object&lt;Foo&gt; obj(<span class="keyword">new</span> Foo);</div>
<div class="line">Foo * f = from_ruby&lt;Foo *&gt;(obj);</div>
<div class="line">Foo <span class="keyword">const</span> * f = from_ruby&lt;Foo const *&gt;(obj);</div>
</div><!-- fragment --><p>works as expected.</p>
<p>The <code>Data_Object</code> class is a wrapper for the <code>Data_Wrap_Struct</code> and the <code>Data_Get_Struct</code> macros in C extensions. It can be used to wrap or unwrap any class that has been assigned to a <code>Data_Type</code>. It inherits from <code>Object</code>, so any member functions we can call on an <code>Object</code> we can also call on a <code>Data_Object</code>:</p>
<div class="fragment"><div class="line">Object object_id = obj.call(<span class="stringliteral">&quot;object_id&quot;</span>);</div>
<div class="line">std::cout &lt;&lt; object_id &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>The <code>Data_Object</code> class can be used to wrap a newly-created object:</p>
<div class="fragment"><div class="line">Data_Object&lt;Foo&gt; foo(<span class="keyword">new</span> Foo);</div>
</div><!-- fragment --><p>or to unwrap an already-created object:</p>
<div class="fragment"><div class="line">VALUE obj = ...;</div>
<div class="line">Data_Object&lt;Foo&gt; foo(obj);</div>
</div><!-- fragment --><p>A <code>Data_Object</code> functions like a smart pointer:</p>
<div class="fragment"><div class="line">Data_Object&lt;Foo&gt; foo(obj);</div>
<div class="line">foo-&gt;foo();</div>
<div class="line">std::cout &lt;&lt; *foo &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>Like a <code>VALUE</code> or an <code>Object</code>, data stored in a <code>Data_Object</code> will be marked by the garbage collector as long as the <code>Data_Object</code> is on the stack.</p>
<h2><a class="anchor" id="exception"></a>
Exceptions</h2>
<p>Suppose we added a member function to our example class that throws an exception:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyException</div>
<div class="line">  : <span class="keyword">public</span> std::exception</div>
<div class="line">{</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Test</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  Test();</div>
<div class="line">  std::string hello();</div>
<div class="line">  <span class="keywordtype">void</span> error();</div>
<div class="line">};</div>
</div><!-- fragment --><p>If we were to wrap this function:</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line"><span class="keywordtype">void</span> Init_test()</div>
<div class="line">{</div>
<div class="line">  Data_Type&lt;Test&gt; rb_cTest =</div>
<div class="line">    define_class&lt;Test&gt;(<span class="stringliteral">&quot;Test&quot;</span>)</div>
<div class="line">    .define_constructor(Constructor&lt;Test&gt;())</div>
<div class="line">    .define_method(<span class="stringliteral">&quot;hello&quot;</span>, &amp;Test::hello)</div>
<div class="line">    .define_method(<span class="stringliteral">&quot;error&quot;</span>, &amp;Test::error);</div>
<div class="line">}</div>
</div><!-- fragment --><p>and call it from inside Ruby:</p>
<div class="fragment"><div class="line">test = Test.new</div>
<div class="line">test.error()</div>
</div><!-- fragment --><p>we would get an exception. Rice will automatically convert any C++ exception it catches into a Ruby exception. But what if we wanted to use a custom error message when we convert the exception, or what if we wanted to convert to a different type of exception? We can write an exception handler like so:</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line"><span class="keywordtype">void</span> Init_test()</div>
<div class="line">{</div>
<div class="line">  Data_Type&lt;Test&gt; rb_cTest =</div>
<div class="line">    define_class&lt;Test&gt;(<span class="stringliteral">&quot;Test&quot;</span>)</div>
<div class="line">    .add_handler&lt;MyException&gt;(handle_my_exception)</div>
<div class="line">    .define_constructor(Constructor&lt;Test&gt;())</div>
<div class="line">    .define_method(<span class="stringliteral">&quot;hello&quot;</span>, &amp;Test::hello)</div>
<div class="line">    .define_method(<span class="stringliteral">&quot;error&quot;</span>, &amp;Test::error);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>handle_my_exception</code> function need only rethrow the exception as a <code><a class="el" href="classRice_1_1Exception.html" title="A placeholder for Ruby exceptions.">Rice::Exception</a></code>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> handle_my_exception(MyException <span class="keyword">const</span> &amp; ex)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">throw</span> Exception(rb_eRuntimeError, <span class="stringliteral">&quot;Goodnight, moon&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>And what if we want to call Ruby code from C++? These exceptions are also converted:</p>
<div class="fragment"><div class="line">Object o;</div>
<div class="line">o.call(<span class="stringliteral">&quot;some_function_that_raises&quot;</span>, 42);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="protect_8hpp.html#afef5fe4b20cbdd88c66335fdfd167b09">protect</a>(rb_raise, rb_eRuntimeError, <span class="stringliteral">&quot;some exception msg&quot;</span>);</div>
<div class="ttc" id="aprotect_8hpp_html_afef5fe4b20cbdd88c66335fdfd167b09"><div class="ttname"><a href="protect_8hpp.html#afef5fe4b20cbdd88c66335fdfd167b09">Rice::protect</a></div><div class="ttdeci">VALUE protect(Fun fun, ArgT const &amp;... args)</div><div class="ttdoc">Call the C function f with arguments (arg1, arg2, ...).</div></div>
</div><!-- fragment --><p>Internally whenever Rice catches a C++ or a Ruby exception, it converts it to an <code>Exception</code> object. This object will later be re-raised as a Ruby exception when control is returned to the Ruby VM.</p>
<p>Rice uses a similar class called <code>Jump_Tag</code> to handle symbols thrown by Ruby's <code>throw</code>/<code>catch</code> or other non-local jumps from inside the Ruby VM.</p>
<h2><a class="anchor" id="builtin"></a>
Builtin Types</h2>
<p>You've seen this example:</p>
<div class="fragment"><div class="line">Object object_id = obj.call(<span class="stringliteral">&quot;object_id&quot;</span>);</div>
<div class="line">std::cout &lt;&lt; object_id &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>Rice mimics the Ruby class hierarchy as closely as it can. In fact, the above code also works for Classes:</p>
<div class="fragment"><div class="line">Class rb_cTest = define_class&lt;Test&gt;(<span class="stringliteral">&quot;Test&quot;</span>);</div>
<div class="line">Object object_id = rb_cTest.call(<span class="stringliteral">&quot;object_id&quot;</span>);</div>
<div class="line">std::cout &lt;&lt; object_id &lt;&lt; std::endl;</div>
</div><!-- fragment --><p>Rice provides builtin wrappers for many builtin Ruby types, including:</p>
<ul>
<li>Object</li>
<li>Module</li>
<li>Class</li>
<li>String</li>
<li>Array</li>
<li>Hash</li>
<li>Struct</li>
<li>Symbol</li>
<li>Exception</li>
</ul>
<p>The <code>Array</code> and <code>Hash</code> types can even be iterated over the same way one would iterate over an STL container:</p>
<div class="fragment"><div class="line">Array a;</div>
<div class="line">a.push(to_ruby(42));</div>
<div class="line">a.push(to_ruby(43));</div>
<div class="line">a.push(to_ruby(44));</div>
<div class="line">Array::iterator it = a.begin();</div>
<div class="line">Array::iterator end = a.end();</div>
<div class="line"><span class="keywordflow">for</span>(; it != end; ++it)</div>
<div class="line">{</div>
<div class="line">  std::cout &lt;&lt; *it &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p>STL algorithms should also work as expected on <code>Array</code> and <code>Hash</code> containers.</p>
<h2><a class="anchor" id="inheritance"></a>
Inheritance</h2>
<p>Inheritance is a tricky problem to solve in extensions. This is because wrapper functions for base classes typically don't know how to accept pointers to derived classes. It is possible to write this logic, but the code is nontrivial.</p>
<p>Rice also provides a solution to this problem:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Base</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> foo();</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Derived</div>
<div class="line">  : <span class="keyword">public</span> Base</div>
<div class="line">{</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line"><span class="keywordtype">void</span> Init_test()</div>
<div class="line">{</div>
<div class="line">  Data_Type&lt;Base&gt; rb_cBase =</div>
<div class="line">    define_class&lt;Base&gt;(<span class="stringliteral">&quot;Base&quot;</span>)</div>
<div class="line">    .define_method(<span class="stringliteral">&quot;foo&quot;</span>, &amp;Base::foo);</div>
<div class="line">  Data_Type&lt;Derived&gt; rb_cDerived =</div>
<div class="line">    define_class&lt;Derived, Base&gt;(<span class="stringliteral">&quot;Derived&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The second template parameter to define_class indicates that <code>Derived</code> inherits from <code>Base</code>.</p>
<p>Rice does not support multiple inheritance.</p>
<h2><a class="anchor" id="overloading"></a>
Overloaded functions</h2>
<p>If you try to create a member function pointer to an overloaded function, you will get an error. So how do we wrap classes that have overloaded functions?</p>
<p>Consider a class that uses this idiom for accessors:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Container</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">size_t</span> capacity(); <span class="comment">// Get the capacity</span></div>
<div class="line">  <span class="keywordtype">void</span> capacity(<span class="keywordtype">size_t</span> cap); <span class="comment">// Set the capacity</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>We can wrap this class by using <code>typedef</code>s:</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line"><span class="keywordtype">void</span> Init_Container()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">typedef</span> size_t (Container::*get_capacity)();</div>
<div class="line">  <span class="keyword">typedef</span> void (Container::*set_capacity)(size_t);</div>
<div class="line"> </div>
<div class="line">  Data_Type&lt;Container&gt; rb_cContainer =</div>
<div class="line">    define_class&lt;Container&gt;(<span class="stringliteral">&quot;Container&quot;</span>)</div>
<div class="line">    .define_method(<span class="stringliteral">&quot;capacity&quot;</span>, get_capacity(&amp;Container::capacity))</div>
<div class="line">    .define_method(<span class="stringliteral">&quot;capacity=&quot;</span>, set_capacity(&amp;Container::capacity))</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="user_defined_conversions"></a>
User-defined type conversions</h2>
<p>Rice provides default conversions for many built-in types. Sometimes, however, the default conversion is not what is expected. For example, consider a function:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> foo(<span class="keywordtype">char</span> * x);</div>
</div><!-- fragment --><p>Is <code>x</code> a pointer to a single character or a pointer to the first character of a null-terminated string or a pointer to the first character of an array of char?</p>
<p>Because the second case is the most common use case (a pointer to the first character of a C string), Rice provides a default conversion that treats a <code>char *</code> as a C string. But suppose the above function actually expects to receive a pointer to a single char instead?</p>
<p>If we write this:</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line"><span class="keywordtype">void</span> Init_test()</div>
<div class="line">{</div>
<div class="line">  define_global_function(<span class="stringliteral">&quot;foo&quot;</span>, &amp;foo);</div>
<div class="line">}</div>
</div><!-- fragment --><p>It will likely have the wrong behavior.</p>
<p>To avoid this problem, it is necessary to write a wrapper function where the extension can be more explicit about how to handle the parameters:</p>
<div class="fragment"><div class="line">Object wrap_foo(Object o)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">char</span> c = from_ruby&lt;char&gt;(o);</div>
<div class="line">  foo(&amp;c);</div>
<div class="line">  <span class="keywordflow">return</span> to_ruby(c);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line"><span class="keywordtype">void</span> Init_test()</div>
<div class="line">{</div>
<div class="line">  define_global_function(<span class="stringliteral">&quot;foo&quot;</span>, &amp;wrap_foo);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that the out parameter is returned from <code>wrap_foo</code>, as Ruby does not have pass-by-variable-reference (it uses pass-by-object-reference).</p>
<h2><a class="anchor" id="default_arguments"></a>
Default Arguments</h2>
<p>Going back to our initial C++ class example, lets say that <code>hello()</code> now takes more arguments, one of which has a default value:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Test</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  Test();</div>
<div class="line">  std::string hello(std::string first, std::string second = <span class="stringliteral">&quot;world&quot;</span>);</div>
<div class="line">};</div>
</div><!-- fragment --><p>As default parameter information is not available through templates, it is necessary to define this in Rice explicitly using <code><a class="el" href="classRice_1_1Arg.html" title="Helper for defining default arguments of a method.">Rice::Arg</a></code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;rice/Data_Type.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;rice/Constructor.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>Rice;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line"><span class="keywordtype">void</span> Init_test()</div>
<div class="line">{</div>
<div class="line">  Data_Type&lt;Test&gt; rb_cTest =</div>
<div class="line">    define_class&lt;Test&gt;(<span class="stringliteral">&quot;Test&quot;</span>)</div>
<div class="line">    .define_constructor(Constructor&lt;Test&gt;())</div>
<div class="line">    .define_method(<span class="stringliteral">&quot;hello&quot;</span>,</div>
<div class="line">       &amp;Test::hello,</div>
<div class="line">       (Arg(<span class="stringliteral">&quot;hello&quot;</span>), Arg(<span class="stringliteral">&quot;second&quot;</span>) = <span class="stringliteral">&quot;world&quot;</span>)</div>
<div class="line">    );</div>
<div class="line">}</div>
</div><!-- fragment --><p>The syntax here is <code>Arg(nameOfParameter)[ = defaultValue]</code>. The name of the parameter is not important here (it is for readability), but the value set via <code>operator=</code> must match the type of the parameter. As such it may be necessary to explicitly cast the default value.</p>
<div class="fragment"><div class="line">.define_method(<span class="stringliteral">&quot;hello&quot;</span>,</div>
<div class="line">   &amp;Test::hello,</div>
<div class="line">   (Arg(<span class="stringliteral">&quot;hello&quot;</span>), Arg(<span class="stringliteral">&quot;second&quot;</span>) = (std::string)<span class="stringliteral">&quot;world&quot;</span>)</div>
<div class="line">);</div>
</div><!-- fragment --><p>These <code><a class="el" href="classRice_1_1Arg.html" title="Helper for defining default arguments of a method.">Rice::Arg</a></code> objects must be in the correct order and must be surrounded with parentheses if more than one exists.</p>
<p>Now, Ruby will now know about the default arguments, and this wrapper can be used as expected:</p>
<div class="fragment"><div class="line">t = Test.new</div>
<div class="line">t.hello(<span class="stringliteral">&quot;hello&quot;</span>)</div>
<div class="line">t.hello(<span class="stringliteral">&quot;goodnight&quot;</span>, <span class="stringliteral">&quot;moon&quot;</span>)</div>
</div><!-- fragment --><p>This also works with Constructors:</p>
<div class="fragment"><div class="line">.define_constructor(Constructor&lt;SomeClass, int, int&gt;(),</div>
<div class="line">    ( Arg(<span class="stringliteral">&quot;arg1&quot;</span>) = 1, Arg(<span class="stringliteral">&quot;otherArg&quot;</span>) = 12 );</div>
</div><!-- fragment --><h2><a class="anchor" id="director"></a>
Director</h2>
<p>Polymorphism creates yet another wrinkle in building exceptions around C++ code, because now we have to deal with cross-language polymorphism, where C++ can call into a Ruby subclass, and a Ruby subclass can <code>super</code> back into C++ land. <code>super</code> calls already work through define_class, but making code travel from C++ into Ruby via polymorphism is tricker. Rice provides the <code><a class="el" href="classRice_1_1Director.html">Rice::Director</a></code> class and the <code>define_director</code> method to enable this code path.</p>
<p>Like <code>SWIG_Director</code>, <code><a class="el" href="classRice_1_1Director.html">Rice::Director</a></code> is a class that is used to build a proxy class to properly send execution up or down the object hierarchy for that class. Take the following class:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>VirtualBase {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    VirtualBase();</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> doWork();</div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> processWorker() = 0;</div>
<div class="line">};</div>
</div><!-- fragment --><p>Due to the abstract nature of this class, we cannot directly wrap it in Rice, as any C++ compiler will complain about trying to instantiate a virtual class. Even without the pure virtual function, any call to <code>VirtualBase::doWork</code> will stop at the C++ level and execution will not pass down into any Ruby subclasses.</p>
<p>To properly wrap both of these methods, use a <code><a class="el" href="classRice_1_1Director.html">Rice::Director</a></code> subclass as a proxy and use this new proxy class as the type to wrap with <code>define_class</code>:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;rice/Director.hpp&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>VirtualBaseProxy : <span class="keyword">public</span> VirtualBase, <span class="keyword">public</span> <a class="code" href="classRice_1_1Director.html">Rice::Director</a> {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    VirtualBaseProxy(Object <span class="keyword">self</span>) : Rice::Director(self) { }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> doWork() {</div>
<div class="line">      <span class="keywordflow">return</span> from_ruby&lt;int&gt;( <a class="code" href="classRice_1_1Director.html#af637f3b8cd23f6f255f7c40c45f11232">getSelf</a>().call(<span class="stringliteral">&quot;do_work&quot;</span>) );</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> default_doWork() {</div>
<div class="line">      <span class="keywordflow">return</span> VirtualBase::doWork();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">int</span> processWorker() {</div>
<div class="line">      <span class="keywordflow">return</span> from_ruby&lt;int&gt;( <a class="code" href="classRice_1_1Director.html#af637f3b8cd23f6f255f7c40c45f11232">getSelf</a>().call(<span class="stringliteral">&quot;process_worker&quot;</span>) );</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">int</span> default_processWorker() {</div>
<div class="line">      <a class="code" href="classRice_1_1Director.html#acbbb2d2939fd499f2ff21433b6737ef7">raisePureVirtual</a>();</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="aclassRice_1_1Director_html"><div class="ttname"><a href="classRice_1_1Director.html">Rice::Director</a></div><div class="ttdef"><b>Definition:</b> Director.hpp:14</div></div>
<div class="ttc" id="aclassRice_1_1Director_html_acbbb2d2939fd499f2ff21433b6737ef7"><div class="ttname"><a href="classRice_1_1Director.html#acbbb2d2939fd499f2ff21433b6737ef7">Rice::Director::raisePureVirtual</a></div><div class="ttdeci">void raisePureVirtual() const</div><div class="ttdoc">Raise a ruby exception when a call comes through for a pure virtual method.</div></div>
<div class="ttc" id="aclassRice_1_1Director_html_af637f3b8cd23f6f255f7c40c45f11232"><div class="ttname"><a href="classRice_1_1Director.html#af637f3b8cd23f6f255f7c40c45f11232">Rice::Director::getSelf</a></div><div class="ttdeci">Object getSelf() const</div><div class="ttdoc">Get the Ruby object linked to this C++ instance.</div><div class="ttdef"><b>Definition:</b> Director.hpp:29</div></div>
</div><!-- fragment --><p>There is a lot going on here, so we'll go through each part.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>VirtualBaseProxy : <span class="keyword">public</span> Virtualbase, <span class="keyword">public</span> <a class="code" href="classRice_1_1Director.html">Rice::Director</a> {</div>
</div><!-- fragment --><p>First, the class needs to subclass both the virtual class in question and <code><a class="el" href="classRice_1_1Director.html">Rice::Director</a></code>.</p>
<div class="fragment"><div class="line"><span class="keyword">public</span>:</div>
<div class="line">  VirtualBaseProxy(Object <span class="keyword">self</span>) : Rice::Director(self) { }</div>
</div><!-- fragment --><p>For <code><a class="el" href="classRice_1_1Director.html">Rice::Director</a></code> to work its magic, every instance of this class needs to have a handle to its Ruby instance. The constructor must take a <code><a class="el" href="classRice_1_1Object.html" title="The base class for all Objects.">Rice::Object</a></code> as the first argument and pass it up into <code><a class="el" href="classRice_1_1Director.html">Rice::Director</a></code>. The code here is the minimum required for a <code><a class="el" href="classRice_1_1Director.html">Rice::Director</a></code> proxy.</p>
<div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">int</span> doWork() {</div>
<div class="line">  <span class="keywordflow">return</span> from_ruby&lt;int&gt;( getSelf().call(<span class="stringliteral">&quot;do_work&quot;</span>) );</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> default_doWork() {</div>
<div class="line">  <span class="keywordflow">return</span> VirtualBase::doWork();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Here the proxy class implements the virtual methods and provides implementations that delegate execution in the correct direction. The actual method calls into Ruby, providing all necessary type conversions to and from C++ types. The other method is how Ruby calls back into C++ and is the method that must be exposed with <code>define_method</code>. The <code>default_</code> prefix is a naming convention to help keep straight which methods perform which function. If Ruby should never call into C++, then the <code>default_</code> implementation should call <code>raisePureVirtual()</code>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> default_processWorker() {</div>
<div class="line">  raisePureVirtual();</div>
<div class="line">}</div>
</div><!-- fragment --><p>The method <code>raisePureVirtual()</code> exists to allow wrapping a pure virtual method into Ruby (and ensuring compliation is possible) but making sure any users of this extension are informed quickly that there's nothing callable in the C++ side of the library.</p>
<p>Once the proxy class is built, it's time to wrap it into Ruby:</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line"><span class="keywordtype">void</span> Init_virtual() {</div>
<div class="line">  define_class&lt;VirtualBase&gt;(<span class="stringliteral">&quot;VirtualBase&quot;</span>)</div>
<div class="line">    .define_director&lt;VirtualBaseProxy&gt;()</div>
<div class="line">    .define_constructor(Constructor&lt;VirtualBaseProxy, Rice::Object&gt;())</div>
<div class="line">    .define_method(<span class="stringliteral">&quot;do_work&quot;</span>, &amp;VirtualBaseProxy::default_doWork)</div>
<div class="line">    .define_method(<span class="stringliteral">&quot;process_worker&quot;</span>, &amp;VirtualBaseProxy::default_processWorker);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The wrapping is the same as is described earlier in this document. Expose the class <code>VirtualBase</code>, and register <code>VirtualBaseProxy</code> as a director proxy of <code>VirtualBase</code> with <code><a class="el" href="classRice_1_1Data__Type.html#ab2e02473df755b6b4e45a2f8b933d1f8" title="Register a Director class for this class.">Rice::Data_Type::define_director</a></code>, then <code>define_method</code>s pointing to the proxy methods as necessary.</p>
<p>You must use the <code><a class="el" href="classRice_1_1Director.html">Rice::Director</a></code> proxy class in the Constructor line, this allows proper object construction / destruction of the types in question.</p>
<h2><a class="anchor" id="implicit_cast"></a>
Implicit Casting</h2>
<p>There are times when a library exposes classes that, while unrelated, are built to be interchangeable across the library. One example of this is found in the Open Source 3d rendering engine <a href="http://www.ogre3d.org/">OGRE</a>: Ogre::Degree and Ogre::Radian. When a given method takes a Radian, you're free to pass in a Degree, and vice versa.</p>
<p>Rice cannot automatically figure out if this kind of functionality is possible in a given library but it does provide an API for defining these relationships: <code>Rice::define_implicit_cast&lt;From, To&gt;()</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Degree { ... };</div>
<div class="line"><span class="keyword">class </span>Radian { ... };</div>
<div class="line"> </div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line"><span class="keywordtype">void</span> Init_implicit() {</div>
<div class="line">  define_class&lt;Degree&gt;()</div>
<div class="line">    ...;</div>
<div class="line">  define_class&lt;Radian&gt;()</div>
<div class="line">    ...;</div>
<div class="line"> </div>
<div class="line">  define_implicit_cast&lt;Degree, Radian&gt;();</div>
<div class="line">  define_implicit_cast&lt;Radian, Degree&gt;();</div>
<div class="line">}</div>
</div><!-- fragment --><p>Using <code>Rice::define_implicit_cast</code> has the following requirements:</p>
<ul>
<li>The two types must be bound in Rice before defining the cast.</li>
<li>The classes must have constructors that take the other type.</li>
<li>This feature cannot be used with fundamental types.</li>
</ul>
<p>To see a full example of this feature, please check out test/test_Data_Type.cpp.</p>
<h1><a class="anchor" id="motivation"></a>
Motivation</h1>
<p>There are a number of common problems when writing C or C++ extensions for Ruby:</p>
<ul>
<li>Type safety. It is easy to mix-up integral types such as ID and VALUE. Some of the functions in the Ruby API are not consistent with which types they take (e.g. rb_const_defined takes an ID and rb_mod_remove_const takes a Symbol).</li>
<li>DRY principle. Specifying the number of arguments that each wrapped function takes is easy to get wrong. Adding a new argument to the function means that the number of arguments passed to rb_define_method must also be updated.</li>
<li>Type conversion. There are many different functions to convert data to and from ruby types. Many of them have different semantics or different forms. For example, to convert a string, one might use the StringValue macro, but to convert a fixnum, one might use FIX2INT. Unwrapping previously wrapped C data uses yet another form.</li>
<li>Exception safety. It is imperative that C++ exceptions never make their way into C code, and it is also imperative that a Ruby exception never escape while there are objects on the stack with nontrivial destructors. Rules for when it is okay to use which exceptions are difficult to get right, especially as code is maintained through time.</li>
<li>Thread safety. Because the Ruby interpreter is not thread-safe, the Ruby interpreter must not be run from more than one thread. Because of tricks the GC and scheduler play with the C stack, it's not enough to ensure that only one thread runs the interpreter at any given time; once the interpreter has been run from one thread, it must only ever be run from that thread in the future. Additionally, because Ruby copies the stack when it switches threads, C++ code must be careful not to access objects in one Ruby thread that were created on the stack in another Ruby thread.</li>
<li>C-based API. The Ruby API is not always convenient for accessing Ruby data structurs such as Hash and Array, especially when writing C++ code, as the interface for these containers is not consistent with standard containers.</li>
<li>Calling convention. Function pointers passed into the Ruby API must follow the C calling convention. This means that it is not possible to pass a pointer to a template function or static member function (that is, it will work on some platforms, but isn't portable).</li>
<li>Inheritance. When wrapping C++ objects, it is easy to store a pointer to a derived class, but then methods in the base class must have knowledge of the derived class in order to unwrap the object. It is possible to always store a pointer to the base class and then dynamic_cast the pointer to the derived type when necessary, but this can be slow and cumbersome, and it isn't likely to work with multiple inheritance. A system that properly handles inheritance for all corner cases is nontrivial.</li>
<li>Multiple inheritance. C++ supports true multiple inheritance, but the Ruby object model uses single inheritance with mixins. When wrapping a library whose public interface uses multiple inheritance, care must be taken in constructing the mapping.</li>
<li>GC safety. All live Ruby objects must be marked during the garbage collector's mark phase, otherwise they will be prematurely destroyed. The general rule is that object references stored on the heap should be either registered with rb_gc_register_address or marked by a data object's mark function; object references stored on the stack will be automatically marked, provided the Ruby interpreter was properly initialized at startup.</li>
<li>Callbacks. C implements callbacks via function pointers, while Ruby typically implements callbacks via procs. Writing an adapter function to call the proc is not difficult, but there is much opportunity for error (particularly with exception-safety).</li>
<li>Data serialization. By default data objects defined at the C layer are not marshalable. The user must explicitly define functions to marshal the data member-by-member.</li>
</ul>
<p>Rice addresses these issues in many ways:</p>
<ul>
<li>Type safety. Rice provides encapsulation for all builtin types, such as Object, Identifier, Class, Module, and String. It automatically checks the dynamic type of an object before constructing an instance of a wrapper.</li>
<li>DRY principle. Rice uses introspection through the use of templates and function overloading to automatically determine the number and types of arguments to functions. Default arguments must still be handled explicitly, however.</li>
<li>Type conversions. Rice provides cast-style to_ruby&lt;&gt; and from_ruby&lt;&gt; template functions to simplify explicit type conversions. Automatic type conversions for parameters and return values are generated for all wrapped functions.</li>
<li>Exception safety. Rice automatically converts common exceptions and provides a mechanism for converting user-defined exception types. Rice also provides convenience functions for converting exceptions when calling back into ruby code.</li>
<li>Thread safety. Rice provides no mechanisms for dealing with thread safety. Many common thread safety issues should be alleviated by YARV, which supports POSIX threads.</li>
<li>C++-based API. Rice provides an object-oriented C++-style API to most common functions in the Ruby C API.</li>
<li>Calling convention. Rice automatically uses C calling convention for all function pointers passed into the Ruby API.</li>
<li>Inheritance. Rice provides automatic conversion to the base class type when a wrapped member function is called on the base class.</li>
<li>Multiple inheritance. Rice provides no mechanism for multiple inheritance. Multiple inheritance can be simulated via mixins, though this is not yet as easy as it could be.</li>
<li>GC safety. Rice provides a handful of convenience classes for interacting with the garbage collector. There are still basic rules which must be followed to ensure that objects get properly destroyed.</li>
<li>Callbacks. Rice provides a handful of convenience classes for dealing with callbacks.</li>
<li>Data serialization. Rice provides no mechanism for data serialization, but it is likely this may be added in a future release.</li>
</ul>
<h1><a class="anchor" id="what_not"></a>
What Rice is Not</h1>
<p>There are a number projects which server similar functions to Rice. Two such popular projects are SWIG and Boost.Python. Rice has some distinct features which set it apart from both of these projects.</p>
<p>Rice is not trying to replace SWIG. Rice is not a generic wrapper interface generator. Rice is a C++ library for interfacing with the Ruby C API. This provides a very natural way for C++ programmers to wrap their C++ code, without having to learn a new domain-specific language. However, there is no reason why SWIG and Rice could not work together; a SWIG module could be written to generate Rice code. Such a module would combine the portability of SWIG with the maintainability of Rice (I have written extensions using both, and I have found Rice extensions to be more maintainable when the interface is constantly changing. Your mileage may vary).</p>
<p>Rice is also not trying to simply be a Ruby version of Boost.Python. Rice does use some of the same template tricks that Boost.Python uses, however there are some important distinctions. First of all, Boost.Python attempts to create a declarative DSL in C++ using templates. Rice is a wrapper around the Ruby C API and attempts to make its interface look like an OO version of the API; this means that class declarations look procedural rather than declarative. Secondly, the Ruby object model is different from the python object model. This is reflected in the interface to Rice; it mimics the Ruby object model at the C++ level. Thirdly, Rice uses Ruby as a code generator; I find this to be much more readable than using the Boost preprocessor library.</p>
<h1><a class="anchor" id="history"></a>
History</h1>
<p>Rice originated as Excruby, a project to interface with C++-based trading software at Automated Trading Desk in Mount Pleasant, South Carolina. The Ruby bindings for Swig were at the time less mature than they are today, and did not suit the needs of the project.</p>
<p>Excruby was written not as a wrapper for the Ruby API, but rather as a set of helper functions and classes for interfacing with the Ruby interpreter in an exception-safe manner. Over the course of five years, the project grew into wrappers for pieces of the API, but the original helper functions remained as part of the public interface.</p>
<p>This created confusion for the users of the library, because there were multiple ways of accomplishing most tasks &ndash; directly through the C API, through a low-level wrapper around the C API, and through a high-level abstraction of the lower-level interfaces.</p>
<p>Rice was then born in an attempt to clean up the interface. Rice keeps the lower-level wrappers, but as an implementation detail; the public interface is truly a high-level abstraction around the Ruby C API.</p>
<h1><a class="anchor" id="gc"></a>
The GC</h1>
<ul>
<li>Objects are not automatically registered with the garbage collector.</li>
<li>If an Object is on the stack, it does not need to be registered with the garbage collector.</li>
<li>If an Object is allocated on the heap or if it is a member of an object that might be allocated on the heap, use an <a class="el" href="classRice_1_1Address__Registration__Guard.html" title="A guard to register a given address with the GC.">Rice::Address_Registration_Guard</a> to register the object with the garbage collector.</li>
<li>If a reference counted object is being wrapped, or if another type of smart pointer is wrapped, ensure that only one mechanism is used to destroy the object. In general, the smart pointer manages the allocation of the object, and Ruby should hold only a reference to the smart pointer. When the garbage collector determines that it is time to clean up the object, the smart pointer will be destroyed, decrementing the reference count; when the reference count drops to 0, underlying object will be destroyed. </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Mar 14 2021 15:53:00 for Rice by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.0
</small></address>
</body>
</html>
